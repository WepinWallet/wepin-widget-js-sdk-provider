var Ze = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Cy(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function xp(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function i() {
      return this instanceof i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(i) {
    var s = Object.getOwnPropertyDescriptor(e, i);
    Object.defineProperty(n, i, s.get ? s : {
      enumerable: !0,
      get: function() {
        return e[i];
      }
    });
  }), n;
}
var pr = {}, Ma = {}, Ti = {};
Object.defineProperty(Ti, "__esModule", { value: !0 });
Ti.getUniqueId = void 0;
const Ep = 4294967295;
let Ef = Math.floor(Math.random() * Ep);
function Ny() {
  return Ef = (Ef + 1) % Ep, Ef;
}
Ti.getUniqueId = Ny;
Object.defineProperty(Ma, "__esModule", { value: !0 });
Ma.createIdRemapMiddleware = void 0;
const Ly = Ti;
function ky() {
  return (e, t, n, i) => {
    const s = e.id, r = Ly.getUniqueId();
    e.id = r, t.id = r, n((o) => {
      e.id = s, t.id = s, o();
    });
  };
}
Ma.createIdRemapMiddleware = ky;
var Ra = {};
Object.defineProperty(Ra, "__esModule", { value: !0 });
Ra.createAsyncMiddleware = void 0;
function jy(e) {
  return async (t, n, i, s) => {
    let r;
    const o = new Promise((f) => {
      r = f;
    });
    let u = null, c = !1;
    const h = async () => {
      c = !0, i((f) => {
        u = f, r();
      }), await o;
    };
    try {
      await e(t, n, h), c ? (await o, u(null)) : s(null);
    } catch (f) {
      u ? u(f) : s(f);
    }
  };
}
Ra.createAsyncMiddleware = jy;
var Ba = {};
Object.defineProperty(Ba, "__esModule", { value: !0 });
Ba.createScaffoldMiddleware = void 0;
function qy(e) {
  return (t, n, i, s) => {
    const r = e[t.method];
    return r === void 0 ? i() : typeof r == "function" ? r(t, n, i, s) : (n.result = r, s());
  };
}
Ba.createScaffoldMiddleware = qy;
var Oi = {}, Ia = {}, _c = { exports: {} }, Hn = typeof Reflect == "object" ? Reflect : null, R0 = Hn && typeof Hn.apply == "function" ? Hn.apply : function(t, n, i) {
  return Function.prototype.apply.call(t, n, i);
}, da;
Hn && typeof Hn.ownKeys == "function" ? da = Hn.ownKeys : Object.getOwnPropertySymbols ? da = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : da = function(t) {
  return Object.getOwnPropertyNames(t);
};
function Dy(e) {
  console && console.warn && console.warn(e);
}
var Sp = Number.isNaN || function(t) {
  return t !== t;
};
function Nt() {
  Nt.init.call(this);
}
_c.exports = Nt;
_c.exports.once = Hy;
Nt.EventEmitter = Nt;
Nt.prototype._events = void 0;
Nt.prototype._eventsCount = 0;
Nt.prototype._maxListeners = void 0;
var B0 = 10;
function Ta(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(Nt, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return B0;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || Sp(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    B0 = e;
  }
});
Nt.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Nt.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || Sp(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function Ap(e) {
  return e._maxListeners === void 0 ? Nt.defaultMaxListeners : e._maxListeners;
}
Nt.prototype.getMaxListeners = function() {
  return Ap(this);
};
Nt.prototype.emit = function(t) {
  for (var n = [], i = 1; i < arguments.length; i++)
    n.push(arguments[i]);
  var s = t === "error", r = this._events;
  if (r !== void 0)
    s = s && r.error === void 0;
  else if (!s)
    return !1;
  if (s) {
    var o;
    if (n.length > 0 && (o = n[0]), o instanceof Error)
      throw o;
    var u = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
    throw u.context = o, u;
  }
  var c = r[t];
  if (c === void 0)
    return !1;
  if (typeof c == "function")
    R0(c, this, n);
  else
    for (var h = c.length, f = Tp(c, h), i = 0; i < h; ++i)
      R0(f[i], this, n);
  return !0;
};
function Mp(e, t, n, i) {
  var s, r, o;
  if (Ta(n), r = e._events, r === void 0 ? (r = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (r.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    n.listener ? n.listener : n
  ), r = e._events), o = r[t]), o === void 0)
    o = r[t] = n, ++e._eventsCount;
  else if (typeof o == "function" ? o = r[t] = i ? [n, o] : [o, n] : i ? o.unshift(n) : o.push(n), s = Ap(e), s > 0 && o.length > s && !o.warned) {
    o.warned = !0;
    var u = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    u.name = "MaxListenersExceededWarning", u.emitter = e, u.type = t, u.count = o.length, Dy(u);
  }
  return e;
}
Nt.prototype.addListener = function(t, n) {
  return Mp(this, t, n, !1);
};
Nt.prototype.on = Nt.prototype.addListener;
Nt.prototype.prependListener = function(t, n) {
  return Mp(this, t, n, !0);
};
function $y() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function Rp(e, t, n) {
  var i = { fired: !1, wrapFn: void 0, target: e, type: t, listener: n }, s = $y.bind(i);
  return s.listener = n, i.wrapFn = s, s;
}
Nt.prototype.once = function(t, n) {
  return Ta(n), this.on(t, Rp(this, t, n)), this;
};
Nt.prototype.prependOnceListener = function(t, n) {
  return Ta(n), this.prependListener(t, Rp(this, t, n)), this;
};
Nt.prototype.removeListener = function(t, n) {
  var i, s, r, o, u;
  if (Ta(n), s = this._events, s === void 0)
    return this;
  if (i = s[t], i === void 0)
    return this;
  if (i === n || i.listener === n)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete s[t], s.removeListener && this.emit("removeListener", t, i.listener || n));
  else if (typeof i != "function") {
    for (r = -1, o = i.length - 1; o >= 0; o--)
      if (i[o] === n || i[o].listener === n) {
        u = i[o].listener, r = o;
        break;
      }
    if (r < 0)
      return this;
    r === 0 ? i.shift() : Uy(i, r), i.length === 1 && (s[t] = i[0]), s.removeListener !== void 0 && this.emit("removeListener", t, u || n);
  }
  return this;
};
Nt.prototype.off = Nt.prototype.removeListener;
Nt.prototype.removeAllListeners = function(t) {
  var n, i, s;
  if (i = this._events, i === void 0)
    return this;
  if (i.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : i[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete i[t]), this;
  if (arguments.length === 0) {
    var r = Object.keys(i), o;
    for (s = 0; s < r.length; ++s)
      o = r[s], o !== "removeListener" && this.removeAllListeners(o);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (n = i[t], typeof n == "function")
    this.removeListener(t, n);
  else if (n !== void 0)
    for (s = n.length - 1; s >= 0; s--)
      this.removeListener(t, n[s]);
  return this;
};
function Bp(e, t, n) {
  var i = e._events;
  if (i === void 0)
    return [];
  var s = i[t];
  return s === void 0 ? [] : typeof s == "function" ? n ? [s.listener || s] : [s] : n ? Fy(s) : Tp(s, s.length);
}
Nt.prototype.listeners = function(t) {
  return Bp(this, t, !0);
};
Nt.prototype.rawListeners = function(t) {
  return Bp(this, t, !1);
};
Nt.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : Ip.call(e, t);
};
Nt.prototype.listenerCount = Ip;
function Ip(e) {
  var t = this._events;
  if (t !== void 0) {
    var n = t[e];
    if (typeof n == "function")
      return 1;
    if (n !== void 0)
      return n.length;
  }
  return 0;
}
Nt.prototype.eventNames = function() {
  return this._eventsCount > 0 ? da(this._events) : [];
};
function Tp(e, t) {
  for (var n = new Array(t), i = 0; i < t; ++i)
    n[i] = e[i];
  return n;
}
function Uy(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function Fy(e) {
  for (var t = new Array(e.length), n = 0; n < t.length; ++n)
    t[n] = e[n].listener || e[n];
  return t;
}
function Hy(e, t) {
  return new Promise(function(n, i) {
    function s(o) {
      e.removeListener(t, r), i(o);
    }
    function r() {
      typeof e.removeListener == "function" && e.removeListener("error", s), n([].slice.call(arguments));
    }
    Op(e, t, r, { once: !0 }), t !== "error" && zy(e, s, { once: !0 });
  });
}
function zy(e, t, n) {
  typeof e.on == "function" && Op(e, "error", t, n);
}
function Op(e, t, n, i) {
  if (typeof e.on == "function")
    i.once ? e.once(t, n) : e.on(t, n);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function s(r) {
      i.once && e.removeEventListener(t, s), n(r);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var ii = _c.exports;
Object.defineProperty(Ia, "__esModule", { value: !0 });
const Vy = ii;
function I0(e, t, n) {
  try {
    Reflect.apply(e, t, n);
  } catch (i) {
    setTimeout(() => {
      throw i;
    });
  }
}
function Ky(e) {
  const t = e.length, n = new Array(t);
  for (let i = 0; i < t; i += 1)
    n[i] = e[i];
  return n;
}
let Zy = class extends Vy.EventEmitter {
  emit(t, ...n) {
    let i = t === "error";
    const s = this._events;
    if (s !== void 0)
      i = i && s.error === void 0;
    else if (!i)
      return !1;
    if (i) {
      let o;
      if (n.length > 0 && ([o] = n), o instanceof Error)
        throw o;
      const u = new Error(`Unhandled error.${o ? ` (${o.message})` : ""}`);
      throw u.context = o, u;
    }
    const r = s[t];
    if (r === void 0)
      return !1;
    if (typeof r == "function")
      I0(r, this, n);
    else {
      const o = r.length, u = Ky(r);
      for (let c = 0; c < o; c += 1)
        I0(u[c], this, n);
    }
    return !0;
  }
};
Ia.default = Zy;
var Zt = {}, pn = {}, Gy = Ei;
Ei.default = Ei;
Ei.stable = Np;
Ei.stableStringify = Np;
var ba = "[...]", Pp = "[Circular]", Rn = [], Sn = [];
function Cp() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function Ei(e, t, n, i) {
  typeof i > "u" && (i = Cp()), nc(e, "", 0, [], void 0, 0, i);
  var s;
  try {
    Sn.length === 0 ? s = JSON.stringify(e, t, n) : s = JSON.stringify(e, Lp(t), n);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; Rn.length !== 0; ) {
      var r = Rn.pop();
      r.length === 4 ? Object.defineProperty(r[0], r[1], r[3]) : r[0][r[1]] = r[2];
    }
  }
  return s;
}
function zn(e, t, n, i) {
  var s = Object.getOwnPropertyDescriptor(i, n);
  s.get !== void 0 ? s.configurable ? (Object.defineProperty(i, n, { value: e }), Rn.push([i, n, t, s])) : Sn.push([t, n, e]) : (i[n] = e, Rn.push([i, n, t]));
}
function nc(e, t, n, i, s, r, o) {
  r += 1;
  var u;
  if (typeof e == "object" && e !== null) {
    for (u = 0; u < i.length; u++)
      if (i[u] === e) {
        zn(Pp, e, t, s);
        return;
      }
    if (typeof o.depthLimit < "u" && r > o.depthLimit) {
      zn(ba, e, t, s);
      return;
    }
    if (typeof o.edgesLimit < "u" && n + 1 > o.edgesLimit) {
      zn(ba, e, t, s);
      return;
    }
    if (i.push(e), Array.isArray(e))
      for (u = 0; u < e.length; u++)
        nc(e[u], u, u, i, e, r, o);
    else {
      var c = Object.keys(e);
      for (u = 0; u < c.length; u++) {
        var h = c[u];
        nc(e[h], h, u, i, e, r, o);
      }
    }
    i.pop();
  }
}
function Wy(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function Np(e, t, n, i) {
  typeof i > "u" && (i = Cp());
  var s = ic(e, "", 0, [], void 0, 0, i) || e, r;
  try {
    Sn.length === 0 ? r = JSON.stringify(s, t, n) : r = JSON.stringify(s, Lp(t), n);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; Rn.length !== 0; ) {
      var o = Rn.pop();
      o.length === 4 ? Object.defineProperty(o[0], o[1], o[3]) : o[0][o[1]] = o[2];
    }
  }
  return r;
}
function ic(e, t, n, i, s, r, o) {
  r += 1;
  var u;
  if (typeof e == "object" && e !== null) {
    for (u = 0; u < i.length; u++)
      if (i[u] === e) {
        zn(Pp, e, t, s);
        return;
      }
    try {
      if (typeof e.toJSON == "function")
        return;
    } catch {
      return;
    }
    if (typeof o.depthLimit < "u" && r > o.depthLimit) {
      zn(ba, e, t, s);
      return;
    }
    if (typeof o.edgesLimit < "u" && n + 1 > o.edgesLimit) {
      zn(ba, e, t, s);
      return;
    }
    if (i.push(e), Array.isArray(e))
      for (u = 0; u < e.length; u++)
        ic(e[u], u, u, i, e, r, o);
    else {
      var c = {}, h = Object.keys(e).sort(Wy);
      for (u = 0; u < h.length; u++) {
        var f = h[u];
        ic(e[f], f, u, i, e, r, o), c[f] = e[f];
      }
      if (typeof s < "u")
        Rn.push([s, t, e]), s[t] = c;
      else
        return c;
    }
    i.pop();
  }
}
function Lp(e) {
  return e = typeof e < "u" ? e : function(t, n) {
    return n;
  }, function(t, n) {
    if (Sn.length > 0)
      for (var i = 0; i < Sn.length; i++) {
        var s = Sn[i];
        if (s[1] === t && s[0] === n) {
          n = s[2], Sn.splice(i, 1);
          break;
        }
      }
    return e.call(this, t, n);
  };
}
Object.defineProperty(pn, "__esModule", { value: !0 });
pn.EthereumProviderError = pn.EthereumRpcError = void 0;
const Jy = Gy;
class kp extends Error {
  constructor(t, n, i) {
    if (!Number.isInteger(t))
      throw new Error('"code" must be an integer.');
    if (!n || typeof n != "string")
      throw new Error('"message" must be a nonempty string.');
    super(n), this.code = t, i !== void 0 && (this.data = i);
  }
  /**
   * Returns a plain object with all public class properties.
   */
  serialize() {
    const t = {
      code: this.code,
      message: this.message
    };
    return this.data !== void 0 && (t.data = this.data), this.stack && (t.stack = this.stack), t;
  }
  /**
   * Return a string representation of the serialized error, omitting
   * any circular references.
   */
  toString() {
    return Jy.default(this.serialize(), Qy, 2);
  }
}
pn.EthereumRpcError = kp;
class Xy extends kp {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(t, n, i) {
    if (!Yy(t))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(t, n, i);
  }
}
pn.EthereumProviderError = Xy;
function Yy(e) {
  return Number.isInteger(e) && e >= 1e3 && e <= 4999;
}
function Qy(e, t) {
  if (t !== "[Circular]")
    return t;
}
var wc = {}, vn = {};
Object.defineProperty(vn, "__esModule", { value: !0 });
vn.errorValues = vn.errorCodes = void 0;
vn.errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901
  }
};
vn.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  4100: {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.serializeError = e.isValidCode = e.getMessageFromCode = e.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const t = vn, n = pn, i = t.errorCodes.rpc.internal, s = "Unspecified error message. This is a bug, please report it.", r = {
    code: i,
    message: o(i)
  };
  e.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
  function o(v, m = s) {
    if (Number.isInteger(v)) {
      const E = v.toString();
      if (b(t.errorValues, E))
        return t.errorValues[E].message;
      if (h(v))
        return e.JSON_RPC_SERVER_ERROR_MESSAGE;
    }
    return m;
  }
  e.getMessageFromCode = o;
  function u(v) {
    if (!Number.isInteger(v))
      return !1;
    const m = v.toString();
    return !!(t.errorValues[m] || h(v));
  }
  e.isValidCode = u;
  function c(v, { fallbackError: m = r, shouldIncludeStack: E = !1 } = {}) {
    var M, B;
    if (!m || !Number.isInteger(m.code) || typeof m.message != "string")
      throw new Error("Must provide fallback error with integer number code and string message.");
    if (v instanceof n.EthereumRpcError)
      return v.serialize();
    const I = {};
    if (v && typeof v == "object" && !Array.isArray(v) && b(v, "code") && u(v.code)) {
      const k = v;
      I.code = k.code, k.message && typeof k.message == "string" ? (I.message = k.message, b(k, "data") && (I.data = k.data)) : (I.message = o(I.code), I.data = { originalError: f(v) });
    } else {
      I.code = m.code;
      const k = (M = v) === null || M === void 0 ? void 0 : M.message;
      I.message = k && typeof k == "string" ? k : m.message, I.data = { originalError: f(v) };
    }
    const T = (B = v) === null || B === void 0 ? void 0 : B.stack;
    return E && v && T && typeof T == "string" && (I.stack = T), I;
  }
  e.serializeError = c;
  function h(v) {
    return v >= -32099 && v <= -32e3;
  }
  function f(v) {
    return v && typeof v == "object" && !Array.isArray(v) ? Object.assign({}, v) : v;
  }
  function b(v, m) {
    return Object.prototype.hasOwnProperty.call(v, m);
  }
})(wc);
var Oa = {};
Object.defineProperty(Oa, "__esModule", { value: !0 });
Oa.ethErrors = void 0;
const xc = pn, jp = wc, ir = vn;
Oa.ethErrors = {
  rpc: {
    /**
     * Get a JSON RPC 2.0 Parse (-32700) error.
     */
    parse: (e) => vr(ir.errorCodes.rpc.parse, e),
    /**
     * Get a JSON RPC 2.0 Invalid Request (-32600) error.
     */
    invalidRequest: (e) => vr(ir.errorCodes.rpc.invalidRequest, e),
    /**
     * Get a JSON RPC 2.0 Invalid Params (-32602) error.
     */
    invalidParams: (e) => vr(ir.errorCodes.rpc.invalidParams, e),
    /**
     * Get a JSON RPC 2.0 Method Not Found (-32601) error.
     */
    methodNotFound: (e) => vr(ir.errorCodes.rpc.methodNotFound, e),
    /**
     * Get a JSON RPC 2.0 Internal (-32603) error.
     */
    internal: (e) => vr(ir.errorCodes.rpc.internal, e),
    /**
     * Get a JSON RPC 2.0 Server error.
     * Permits integer error codes in the [ -32099 <= -32005 ] range.
     * Codes -32000 through -32004 are reserved by EIP-1474.
     */
    server: (e) => {
      if (!e || typeof e != "object" || Array.isArray(e))
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      const { code: t } = e;
      if (!Number.isInteger(t) || t > -32005 || t < -32099)
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      return vr(t, e);
    },
    /**
     * Get an Ethereum JSON RPC Invalid Input (-32000) error.
     */
    invalidInput: (e) => vr(ir.errorCodes.rpc.invalidInput, e),
    /**
     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
     */
    resourceNotFound: (e) => vr(ir.errorCodes.rpc.resourceNotFound, e),
    /**
     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
     */
    resourceUnavailable: (e) => vr(ir.errorCodes.rpc.resourceUnavailable, e),
    /**
     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
     */
    transactionRejected: (e) => vr(ir.errorCodes.rpc.transactionRejected, e),
    /**
     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
     */
    methodNotSupported: (e) => vr(ir.errorCodes.rpc.methodNotSupported, e),
    /**
     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
     */
    limitExceeded: (e) => vr(ir.errorCodes.rpc.limitExceeded, e)
  },
  provider: {
    /**
     * Get an Ethereum Provider User Rejected Request (4001) error.
     */
    userRejectedRequest: (e) => li(ir.errorCodes.provider.userRejectedRequest, e),
    /**
     * Get an Ethereum Provider Unauthorized (4100) error.
     */
    unauthorized: (e) => li(ir.errorCodes.provider.unauthorized, e),
    /**
     * Get an Ethereum Provider Unsupported Method (4200) error.
     */
    unsupportedMethod: (e) => li(ir.errorCodes.provider.unsupportedMethod, e),
    /**
     * Get an Ethereum Provider Not Connected (4900) error.
     */
    disconnected: (e) => li(ir.errorCodes.provider.disconnected, e),
    /**
     * Get an Ethereum Provider Chain Not Connected (4901) error.
     */
    chainDisconnected: (e) => li(ir.errorCodes.provider.chainDisconnected, e),
    /**
     * Get a custom Ethereum Provider error.
     */
    custom: (e) => {
      if (!e || typeof e != "object" || Array.isArray(e))
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      const { code: t, message: n, data: i } = e;
      if (!n || typeof n != "string")
        throw new Error('"message" must be a nonempty string');
      return new xc.EthereumProviderError(t, n, i);
    }
  }
};
function vr(e, t) {
  const [n, i] = qp(t);
  return new xc.EthereumRpcError(e, n || jp.getMessageFromCode(e), i);
}
function li(e, t) {
  const [n, i] = qp(t);
  return new xc.EthereumProviderError(e, n || jp.getMessageFromCode(e), i);
}
function qp(e) {
  if (e) {
    if (typeof e == "string")
      return [e];
    if (typeof e == "object" && !Array.isArray(e)) {
      const { message: t, data: n } = e;
      if (t && typeof t != "string")
        throw new Error("Must specify string message.");
      return [t || void 0, n];
    }
  }
  return [];
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getMessageFromCode = e.serializeError = e.EthereumProviderError = e.EthereumRpcError = e.ethErrors = e.errorCodes = void 0;
  const t = pn;
  Object.defineProperty(e, "EthereumRpcError", { enumerable: !0, get: function() {
    return t.EthereumRpcError;
  } }), Object.defineProperty(e, "EthereumProviderError", { enumerable: !0, get: function() {
    return t.EthereumProviderError;
  } });
  const n = wc;
  Object.defineProperty(e, "serializeError", { enumerable: !0, get: function() {
    return n.serializeError;
  } }), Object.defineProperty(e, "getMessageFromCode", { enumerable: !0, get: function() {
    return n.getMessageFromCode;
  } });
  const i = Oa;
  Object.defineProperty(e, "ethErrors", { enumerable: !0, get: function() {
    return i.ethErrors;
  } });
  const s = vn;
  Object.defineProperty(e, "errorCodes", { enumerable: !0, get: function() {
    return s.errorCodes;
  } });
})(Zt);
var eg = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Oi, "__esModule", { value: !0 });
Oi.JsonRpcEngine = void 0;
const tg = eg(Ia), br = Zt;
class Xr extends tg.default {
  constructor() {
    super(), this._middleware = [];
  }
  /**
   * Add a middleware function to the engine's middleware stack.
   *
   * @param middleware - The middleware function to add.
   */
  push(t) {
    this._middleware.push(t);
  }
  handle(t, n) {
    if (n && typeof n != "function")
      throw new Error('"callback" must be a function if provided.');
    return Array.isArray(t) ? n ? this._handleBatch(t, n) : this._handleBatch(t) : n ? this._handle(t, n) : this._promiseHandle(t);
  }
  /**
   * Returns this engine as a middleware function that can be pushed to other
   * engines.
   *
   * @returns This engine as a middleware function.
   */
  asMiddleware() {
    return async (t, n, i, s) => {
      try {
        const [r, o, u] = await Xr._runAllMiddleware(t, n, this._middleware);
        return o ? (await Xr._runReturnHandlers(u), s(r)) : i(async (c) => {
          try {
            await Xr._runReturnHandlers(u);
          } catch (h) {
            return c(h);
          }
          return c();
        });
      } catch (r) {
        return s(r);
      }
    };
  }
  async _handleBatch(t, n) {
    try {
      const i = await Promise.all(
        // 1. Begin executing each request in the order received
        t.map(this._promiseHandle.bind(this))
      );
      return n ? n(null, i) : i;
    } catch (i) {
      if (n)
        return n(i);
      throw i;
    }
  }
  /**
   * A promise-wrapped _handle.
   */
  _promiseHandle(t) {
    return new Promise((n) => {
      this._handle(t, (i, s) => {
        n(s);
      });
    });
  }
  /**
   * Ensures that the request object is valid, processes it, and passes any
   * error and the response object to the given callback.
   *
   * Does not reject.
   */
  async _handle(t, n) {
    if (!t || Array.isArray(t) || typeof t != "object") {
      const o = new br.EthereumRpcError(br.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof t}`, { request: t });
      return n(o, { id: void 0, jsonrpc: "2.0", error: o });
    }
    if (typeof t.method != "string") {
      const o = new br.EthereumRpcError(br.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof t.method}`, { request: t });
      return n(o, { id: t.id, jsonrpc: "2.0", error: o });
    }
    const i = Object.assign({}, t), s = {
      id: i.id,
      jsonrpc: i.jsonrpc
    };
    let r = null;
    try {
      await this._processRequest(i, s);
    } catch (o) {
      r = o;
    }
    return r && (delete s.result, s.error || (s.error = br.serializeError(r))), n(r, s);
  }
  /**
   * For the given request and response, runs all middleware and their return
   * handlers, if any, and ensures that internal request processing semantics
   * are satisfied.
   */
  async _processRequest(t, n) {
    const [i, s, r] = await Xr._runAllMiddleware(t, n, this._middleware);
    if (Xr._checkForCompletion(t, n, s), await Xr._runReturnHandlers(r), i)
      throw i;
  }
  /**
   * Serially executes the given stack of middleware.
   *
   * @returns An array of any error encountered during middleware execution,
   * a boolean indicating whether the request was completed, and an array of
   * middleware-defined return handlers.
   */
  static async _runAllMiddleware(t, n, i) {
    const s = [];
    let r = null, o = !1;
    for (const u of i)
      if ([r, o] = await Xr._runMiddleware(t, n, u, s), o)
        break;
    return [r, o, s.reverse()];
  }
  /**
   * Runs an individual middleware.
   *
   * @returns An array of any error encountered during middleware exection,
   * and a boolean indicating whether the request should end.
   */
  static _runMiddleware(t, n, i, s) {
    return new Promise((r) => {
      const o = (c) => {
        const h = c || n.error;
        h && (n.error = br.serializeError(h)), r([h, !0]);
      }, u = (c) => {
        n.error ? o(n.error) : (c && (typeof c != "function" && o(new br.EthereumRpcError(br.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof c}" for request:
${Sf(t)}`, { request: t })), s.push(c)), r([null, !1]));
      };
      try {
        i(t, n, u, o);
      } catch (c) {
        o(c);
      }
    });
  }
  /**
   * Serially executes array of return handlers. The request and response are
   * assumed to be in their scope.
   */
  static async _runReturnHandlers(t) {
    for (const n of t)
      await new Promise((i, s) => {
        n((r) => r ? s(r) : i());
      });
  }
  /**
   * Throws an error if the response has neither a result nor an error, or if
   * the "isComplete" flag is falsy.
   */
  static _checkForCompletion(t, n, i) {
    if (!("result" in n) && !("error" in n))
      throw new br.EthereumRpcError(br.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${Sf(t)}`, { request: t });
    if (!i)
      throw new br.EthereumRpcError(br.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${Sf(t)}`, { request: t });
  }
}
Oi.JsonRpcEngine = Xr;
function Sf(e) {
  return JSON.stringify(e, null, 2);
}
var Pa = {};
Object.defineProperty(Pa, "__esModule", { value: !0 });
Pa.mergeMiddleware = void 0;
const rg = Oi;
function ng(e) {
  const t = new rg.JsonRpcEngine();
  return e.forEach((n) => t.push(n)), t.asMiddleware();
}
Pa.mergeMiddleware = ng;
(function(e) {
  var t = Ze && Ze.__createBinding || (Object.create ? function(i, s, r, o) {
    o === void 0 && (o = r), Object.defineProperty(i, o, { enumerable: !0, get: function() {
      return s[r];
    } });
  } : function(i, s, r, o) {
    o === void 0 && (o = r), i[o] = s[r];
  }), n = Ze && Ze.__exportStar || function(i, s) {
    for (var r in i)
      r !== "default" && !Object.prototype.hasOwnProperty.call(s, r) && t(s, i, r);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), n(Ma, e), n(Ra, e), n(Ba, e), n(Ti, e), n(Oi, e), n(Pa, e);
})(pr);
var ig = function e(t, n) {
  if (t === n)
    return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor)
      return !1;
    var i, s, r;
    if (Array.isArray(t)) {
      if (i = t.length, i != n.length)
        return !1;
      for (s = i; s-- !== 0; )
        if (!e(t[s], n[s]))
          return !1;
      return !0;
    }
    if (t.constructor === RegExp)
      return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf)
      return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString)
      return t.toString() === n.toString();
    if (r = Object.keys(t), i = r.length, i !== Object.keys(n).length)
      return !1;
    for (s = i; s-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, r[s]))
        return !1;
    for (s = i; s-- !== 0; ) {
      var o = r[s];
      if (!e(t[o], n[o]))
        return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
};
const ag = /* @__PURE__ */ Cy(ig), fg = (e, t, n = !0) => (i, s) => {
  i || s.error ? t(i || s.error) : !n || Array.isArray(s) ? e(s) : e(s.result);
}, og = (e) => !!e && typeof e == "string" && e.startsWith("0x");
function T0(e, t, n) {
  try {
    Reflect.apply(e, t, n);
  } catch (i) {
    setTimeout(() => {
      throw i;
    });
  }
}
function sg(e) {
  const t = e.length, n = new Array(t);
  for (let i = 0; i < t; i += 1)
    n[i] = e[i];
  return n;
}
class ug extends ii.EventEmitter {
  emit(t, ...n) {
    let i = t === "error";
    const s = this._events;
    if (s !== void 0)
      i = i && s.error === void 0;
    else if (!i)
      return !1;
    if (i) {
      let o;
      if (n.length > 0 && ([o] = n), o instanceof Error)
        throw o;
      const u = new Error(`Unhandled error.${o ? ` (${o.message})` : ""}`);
      throw u.context = o, u;
    }
    const r = s[t];
    if (r === void 0)
      return !1;
    if (typeof r == "function")
      T0(r, this, n);
    else {
      const o = r.length, u = sg(r);
      for (let c = 0; c < o; c += 1)
        T0(u[c], this, n);
    }
    return !0;
  }
}
const Dp = class $p extends ug {
  constructor({
    logger: t = console,
    maxEventListeners: n = 100,
    rpcMiddleware: i = []
  } = {}) {
    super(), this.uuid = "wepinprovider", this.name = "Wepin", this._log = t, this.setMaxListeners(n), this._state = {
      ...$p._defaultState
    }, this.selectedAddress = null, this.chainId = null, this._handleAccountsChanged = this._handleAccountsChanged.bind(this), this._handleConnect = this._handleConnect.bind(this), this._handleChainChanged = this._handleChainChanged.bind(this), this._handleDisconnect = this._handleDisconnect.bind(this), this._rpcRequest = this._rpcRequest.bind(this), this.request = this.request.bind(this);
    const s = new pr.JsonRpcEngine();
    i.forEach((r) => s.push(r)), this._rpcEngine = s;
  }
  async request(t) {
    if (!t || typeof t != "object" || Array.isArray(t))
      throw Zt.ethErrors.rpc.invalidRequest({
        message: "Invalid request arguments",
        data: t
      });
    this._log.debug("[RPC Request]: requesting args", t);
    const { method: n, params: i, id: s = (/* @__PURE__ */ new Date()).getTime() } = t;
    if (typeof n != "string" || n.length === 0)
      throw Zt.ethErrors.rpc.invalidRequest({
        message: "Invalid request methods",
        data: t
      });
    if (i !== void 0 && !Array.isArray(i) && (typeof i != "object" || i === null))
      throw Zt.ethErrors.rpc.invalidRequest({
        message: "Invalid request params",
        data: t
      });
    return new Promise((r, o) => {
      this._rpcRequest(
        { method: n, params: i, id: s },
        fg(r, o)
      );
    });
  }
  /**
   * Initialize provider
   *
   * @param initialState
   */
  _initializeState(t) {
    if (this._state.initialized === !0)
      throw new Error("Provider already initialized.");
    if (t) {
      const { accounts: n, chainId: i, networkVersion: s } = t;
      this._handleConnect(i), this._handleChainChanged({ chainId: i, networkVersion: s }), this._handleAccountsChanged(n);
    }
    this._state.initialized = !0, this.emit("_initialized");
  }
  _rpcRequest(t, n) {
    let i = n;
    return Array.isArray(t) ? this._rpcEngine.handle(t, i) : (t.jsonrpc || (t.jsonrpc = "2.0"), (t.method === "eth_accounts" || t.method === "klay_accounts" || t.method === "eth_requestAccounts" || t.method === "klay_requestAccounts") && (i = (s, r) => {
      this._log.debug("_rpcRequest to handler account changes", s, r), this._handleAccountsChanged(
        r.result || [],
        t.method === "eth_accounts"
      ), n(s, r);
    }), this._rpcEngine.handle(t, i));
  }
  _handleConnect(t) {
    this._state.isConnected || (this._state.isConnected = !0, this.emit("connect", { chainId: t }));
  }
  _handleDisconnect(t, n) {
    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !t) {
      this._state.isConnected = !1;
      let i;
      t ? (i = new Zt.EthereumRpcError(
        1013,
        // Try again later
        n || "Provider diconnected"
      ), this._log.debug(i)) : (i = new Zt.EthereumRpcError(
        1011,
        // Internal error
        n || "Provider permenantly disconnected"
      ), this._log.error(i), this.chainId = null, this._state.accounts = null, this.selectedAddress = null, this._state.isPermanentlyDisconnected = !0), this.emit("disconnect", i);
    }
  }
  _handleChainChanged({
    chainId: t
  } = {}) {
    if (!og(t)) {
      this._log.error("Invalid network params", { chainId: t });
      return;
    }
    this._handleConnect(t), t !== this.chainId && (this.chainId = t, this._state.initialized && this.emit("chainChanged", this.chainId));
  }
  _handleAccountsChanged(t, n = !1) {
    let i = t;
    Array.isArray(t) || (this._log.error(
      "Received invalid accounts parameter. Please report this bug.",
      t
    ), i = []);
    for (const s of t)
      if (typeof s != "string") {
        this._log.error(
          "Received non-string account. Please report this bug.",
          t
        ), i = [];
        break;
      }
    ag(this._state.accounts, i) || (n && this._state.accounts !== null && this._log.error(
      "'eth_accounts' unexpectedly updated accounts. Please report this bug.",
      i
    ), this._state.accounts = i, this.selectedAddress !== i[0] && (this.selectedAddress = i[0] || null), this._state.initialized && this.emit("accountsChanged", i));
  }
};
Dp._defaultState = {
  accounts: null,
  isConnected: !1,
  initialized: !1,
  isPermanentlyDisconnected: !1
};
let Up = Dp;
const cg = () => (/* @__PURE__ */ new Date()).getTime(), Pi = ({
  wepin: e,
  network: t,
  req: n,
  res: i,
  next: s,
  end: r,
  command: o,
  parameter: u
}) => {
  var f;
  const c = cg();
  e.once(c.toString(), (b) => {
    if (b.body.data === "User Cancel")
      throw Zt.ethErrors.provider.userRejectedRequest();
    i.result = b.body.data === "User Cancel" ? "" : b.body.data, r();
  });
  const h = {
    header: {
      request_from: "web",
      request_to: "wepin_widget",
      id: c
    },
    body: {
      command: o,
      parameter: u
    }
  };
  e.queue.push(h), (f = e.Widget) != null && f.isOpen || e.openWidget();
}, ya = ({ wepin: e, network: t }) => (n, i, s, r) => {
  if (!e._isInitialized)
    throw Zt.ethErrors.provider.unauthorized();
  const o = {
    network: t
  }, { ethereum: u } = window;
  u != null && u.selectedAddress ? (i.result = [u.selectedAddress], r()) : Pi({
    wepin: e,
    network: t,
    req: n,
    res: i,
    next: s,
    end: r,
    command: "request_enable",
    parameter: o
  });
}, Fp = ({ wepin: e, network: t }) => (n, i, s, r) => {
  if (!e._isInitialized)
    throw Zt.ethErrors.provider.unauthorized();
  const o = Array.isArray(n.params) ? n.params[0] : n.params;
  Object.values(o).forEach((c) => {
    if (c && !c.startsWith("0x"))
      throw console.error(`${c} is not start with '0x'`), Zt.ethErrors.rpc.invalidParams();
  });
  const u = {
    account: {
      address: n.params[0].from,
      network: t
    },
    ...n.params[0]
  };
  Pi({
    wepin: e,
    network: t,
    req: n,
    res: i,
    next: s,
    end: r,
    command: "sign_transaction",
    parameter: u
  });
}, Hp = ({ wepin: e, network: t }) => (n, i, s, r) => {
  if (!e._isInitialized)
    throw Zt.ethErrors.provider.unauthorized();
  const o = Array.isArray(n.params) ? n.params[0] : n.params;
  Object.values(o).forEach((u) => {
    if (u && !u.startsWith("0x"))
      throw console.error(`${u} is not start with '0x'`), Zt.ethErrors.rpc.invalidParams();
  }), Pi({
    wepin: e,
    network: t,
    req: n,
    res: i,
    next: s,
    end: r,
    command: "send_transaction",
    parameter: {
      account: {
        address: n.params[0].from,
        network: t
      },
      ...n.params[0]
    }
  });
}, Vn = ({
  wepin: e,
  network: t,
  version: n
}) => (i, s, r, o) => {
  if (!e._isInitialized)
    throw Zt.ethErrors.provider.unauthorized();
  if (i.params.length !== 2)
    throw Zt.ethErrors.rpc.invalidParams;
  const u = {
    account: {
      network: t,
      address: i.params[0]
    },
    data: i.params[1],
    version: n
  };
  Pi({
    wepin: e,
    network: t,
    req: i,
    res: s,
    next: r,
    end: o,
    command: "sign_typed_data",
    parameter: u
  });
}, ga = ({
  wepin: e,
  network: t,
  isPersonal: n
}) => (i, s, r, o) => {
  if (!e._isInitialized)
    throw Zt.ethErrors.provider.unauthorized();
  if (i.params.length !== 2)
    throw Zt.ethErrors.rpc.invalidParams;
  const u = {
    account: {
      network: t,
      address: n ? i.params[1] : i.params[0]
    },
    data: n ? i.params[0] : i.params[1]
  };
  Pi({
    wepin: e,
    network: t,
    req: i,
    res: s,
    next: r,
    end: o,
    command: "sign",
    parameter: u
  });
}, hg = ({
  wepin: e,
  network: t
}) => pr.createScaffoldMiddleware({
  eth_requestAccounts: ya({ wepin: e, network: t }),
  eth_accounts: ya({ wepin: e, network: t }),
  eth_signTransaction: Fp({ wepin: e, network: t }),
  eth_sendTransaction: Hp({ wepin: e, network: t }),
  eth_signTypedData_v1: Vn({ wepin: e, network: t, version: "V1" }),
  eth_signTypedData_v3: Vn({ wepin: e, network: t, version: "V3" }),
  eth_signTypedData_v4: Vn({ wepin: e, network: t, version: "V4" }),
  eth_sign: ga({ wepin: e, network: t, isPersonal: !1 }),
  personal_sign: ga({ wepin: e, network: t, isPersonal: !0 })
});
var Ec = {}, Ca = {}, ai = {}, zp = {}, er = {};
class Vp extends TypeError {
  constructor(t, n) {
    let i;
    const { message: s, explanation: r, ...o } = t, { path: u } = t, c = u.length === 0 ? s : `At path: ${u.join(".")} -- ${s}`;
    super(r ?? c), r != null && (this.cause = c), Object.assign(this, o), this.name = this.constructor.name, this.failures = () => i ?? (i = [t, ...n()]);
  }
}
function lg(e) {
  return Ir(e) && typeof e[Symbol.iterator] == "function";
}
function Ir(e) {
  return typeof e == "object" && e != null;
}
function O0(e) {
  if (Object.prototype.toString.call(e) !== "[object Object]")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype;
}
function Gt(e) {
  return typeof e == "symbol" ? e.toString() : typeof e == "string" ? JSON.stringify(e) : `${e}`;
}
function dg(e) {
  const { done: t, value: n } = e.next();
  return t ? void 0 : n;
}
function pg(e, t, n, i) {
  if (e === !0)
    return;
  e === !1 ? e = {} : typeof e == "string" && (e = { message: e });
  const { path: s, branch: r } = t, { type: o } = n, { refinement: u, message: c = `Expected a value of type \`${o}\`${u ? ` with refinement \`${u}\`` : ""}, but received: \`${Gt(i)}\`` } = e;
  return {
    value: i,
    type: o,
    refinement: u,
    key: s[s.length - 1],
    path: s,
    branch: r,
    ...e,
    message: c
  };
}
function* ac(e, t, n, i) {
  lg(e) || (e = [e]);
  for (const s of e) {
    const r = pg(s, t, n, i);
    r && (yield r);
  }
}
function* Sc(e, t, n = {}) {
  const { path: i = [], branch: s = [e], coerce: r = !1, mask: o = !1 } = n, u = { path: i, branch: s };
  if (r && (e = t.coercer(e, u), o && t.type !== "type" && Ir(t.schema) && Ir(e) && !Array.isArray(e)))
    for (const h in e)
      t.schema[h] === void 0 && delete e[h];
  let c = "valid";
  for (const h of t.validator(e, u))
    h.explanation = n.message, c = "not_valid", yield [h, void 0];
  for (let [h, f, b] of t.entries(e, u)) {
    const v = Sc(f, b, {
      path: h === void 0 ? i : [...i, h],
      branch: h === void 0 ? s : [...s, f],
      coerce: r,
      mask: o,
      message: n.message
    });
    for (const m of v)
      m[0] ? (c = m[0].refinement != null ? "not_refined" : "not_valid", yield [m[0], void 0]) : r && (f = m[1], h === void 0 ? e = f : e instanceof Map ? e.set(h, f) : e instanceof Set ? e.add(f) : Ir(e) && (f !== void 0 || h in e) && (e[h] = f));
  }
  if (c !== "not_valid")
    for (const h of t.refiner(e, u))
      h.explanation = n.message, c = "not_refined", yield [h, void 0];
  c === "valid" && (yield [void 0, e]);
}
class zt {
  constructor(t) {
    const { type: n, schema: i, validator: s, refiner: r, coercer: o = (c) => c, entries: u = function* () {
    } } = t;
    this.type = n, this.schema = i, this.entries = u, this.coercer = o, s ? this.validator = (c, h) => {
      const f = s(c, h);
      return ac(f, h, this, c);
    } : this.validator = () => [], r ? this.refiner = (c, h) => {
      const f = r(c, h);
      return ac(f, h, this, c);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(t, n) {
    return Kp(t, this, n);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(t, n) {
    return Zp(t, this, n);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(t) {
    return Ac(t, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(t, n) {
    return Gp(t, this, n);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(t, n = {}) {
    return fi(t, this, n);
  }
}
function Kp(e, t, n) {
  const i = fi(e, t, { message: n });
  if (i[0])
    throw i[0];
}
function Zp(e, t, n) {
  const i = fi(e, t, { coerce: !0, message: n });
  if (i[0])
    throw i[0];
  return i[1];
}
function Gp(e, t, n) {
  const i = fi(e, t, { coerce: !0, mask: !0, message: n });
  if (i[0])
    throw i[0];
  return i[1];
}
function Ac(e, t) {
  return !fi(e, t)[0];
}
function fi(e, t, n = {}) {
  const i = Sc(e, t, n), s = dg(i);
  return s[0] ? [new Vp(s[0], function* () {
    for (const o of i)
      o[0] && (yield o[0]);
  }), void 0] : [void 0, s[1]];
}
function vg(...e) {
  const t = e[0].type === "type", n = e.map((s) => s.schema), i = Object.assign({}, ...n);
  return t ? Rc(i) : Ci(i);
}
function ur(e, t) {
  return new zt({ type: e, schema: null, validator: t });
}
function bg(e, t) {
  return new zt({
    ...e,
    refiner: (n, i) => n === void 0 || e.refiner(n, i),
    validator(n, i) {
      return n === void 0 ? !0 : (t(n, i), e.validator(n, i));
    }
  });
}
function yg(e) {
  return new zt({
    type: "dynamic",
    schema: null,
    *entries(t, n) {
      yield* e(t, n).entries(t, n);
    },
    validator(t, n) {
      return e(t, n).validator(t, n);
    },
    coercer(t, n) {
      return e(t, n).coercer(t, n);
    },
    refiner(t, n) {
      return e(t, n).refiner(t, n);
    }
  });
}
function gg(e) {
  let t;
  return new zt({
    type: "lazy",
    schema: null,
    *entries(n, i) {
      t ?? (t = e()), yield* t.entries(n, i);
    },
    validator(n, i) {
      return t ?? (t = e()), t.validator(n, i);
    },
    coercer(n, i) {
      return t ?? (t = e()), t.coercer(n, i);
    },
    refiner(n, i) {
      return t ?? (t = e()), t.refiner(n, i);
    }
  });
}
function mg(e, t) {
  const { schema: n } = e, i = { ...n };
  for (const s of t)
    delete i[s];
  switch (e.type) {
    case "type":
      return Rc(i);
    default:
      return Ci(i);
  }
}
function _g(e) {
  const t = e instanceof zt ? { ...e.schema } : { ...e };
  for (const n in t)
    t[n] = Wp(t[n]);
  return Ci(t);
}
function wg(e, t) {
  const { schema: n } = e, i = {};
  for (const s of t)
    i[s] = n[s];
  return Ci(i);
}
function xg(e, t) {
  return console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`."), ur(e, t);
}
function Eg() {
  return ur("any", () => !0);
}
function Sg(e) {
  return new zt({
    type: "array",
    schema: e,
    *entries(t) {
      if (e && Array.isArray(t))
        for (const [n, i] of t.entries())
          yield [n, i, e];
    },
    coercer(t) {
      return Array.isArray(t) ? t.slice() : t;
    },
    validator(t) {
      return Array.isArray(t) || `Expected an array value, but received: ${Gt(t)}`;
    }
  });
}
function Ag() {
  return ur("bigint", (e) => typeof e == "bigint");
}
function Mg() {
  return ur("boolean", (e) => typeof e == "boolean");
}
function Rg() {
  return ur("date", (e) => e instanceof Date && !isNaN(e.getTime()) || `Expected a valid \`Date\` object, but received: ${Gt(e)}`);
}
function Bg(e) {
  const t = {}, n = e.map((i) => Gt(i)).join();
  for (const i of e)
    t[i] = i;
  return new zt({
    type: "enums",
    schema: t,
    validator(i) {
      return e.includes(i) || `Expected one of \`${n}\`, but received: ${Gt(i)}`;
    }
  });
}
function Ig() {
  return ur("func", (e) => typeof e == "function" || `Expected a function, but received: ${Gt(e)}`);
}
function Tg(e) {
  return ur("instance", (t) => t instanceof e || `Expected a \`${e.name}\` instance, but received: ${Gt(t)}`);
}
function Og() {
  return ur("integer", (e) => typeof e == "number" && !isNaN(e) && Number.isInteger(e) || `Expected an integer, but received: ${Gt(e)}`);
}
function Pg(e) {
  return new zt({
    type: "intersection",
    schema: null,
    *entries(t, n) {
      for (const i of e)
        yield* i.entries(t, n);
    },
    *validator(t, n) {
      for (const i of e)
        yield* i.validator(t, n);
    },
    *refiner(t, n) {
      for (const i of e)
        yield* i.refiner(t, n);
    }
  });
}
function Cg(e) {
  const t = Gt(e), n = typeof e;
  return new zt({
    type: "literal",
    schema: n === "string" || n === "number" || n === "boolean" ? e : null,
    validator(i) {
      return i === e || `Expected the literal \`${t}\`, but received: ${Gt(i)}`;
    }
  });
}
function Ng(e, t) {
  return new zt({
    type: "map",
    schema: null,
    *entries(n) {
      if (e && t && n instanceof Map)
        for (const [i, s] of n.entries())
          yield [i, i, e], yield [i, s, t];
    },
    coercer(n) {
      return n instanceof Map ? new Map(n) : n;
    },
    validator(n) {
      return n instanceof Map || `Expected a \`Map\` object, but received: ${Gt(n)}`;
    }
  });
}
function Mc() {
  return ur("never", () => !1);
}
function Lg(e) {
  return new zt({
    ...e,
    validator: (t, n) => t === null || e.validator(t, n),
    refiner: (t, n) => t === null || e.refiner(t, n)
  });
}
function kg() {
  return ur("number", (e) => typeof e == "number" && !isNaN(e) || `Expected a number, but received: ${Gt(e)}`);
}
function Ci(e) {
  const t = e ? Object.keys(e) : [], n = Mc();
  return new zt({
    type: "object",
    schema: e || null,
    *entries(i) {
      if (e && Ir(i)) {
        const s = new Set(Object.keys(i));
        for (const r of t)
          s.delete(r), yield [r, i[r], e[r]];
        for (const r of s)
          yield [r, i[r], n];
      }
    },
    validator(i) {
      return Ir(i) || `Expected an object, but received: ${Gt(i)}`;
    },
    coercer(i) {
      return Ir(i) ? { ...i } : i;
    }
  });
}
function Wp(e) {
  return new zt({
    ...e,
    validator: (t, n) => t === void 0 || e.validator(t, n),
    refiner: (t, n) => t === void 0 || e.refiner(t, n)
  });
}
function jg(e, t) {
  return new zt({
    type: "record",
    schema: null,
    *entries(n) {
      if (Ir(n))
        for (const i in n) {
          const s = n[i];
          yield [i, i, e], yield [i, s, t];
        }
    },
    validator(n) {
      return Ir(n) || `Expected an object, but received: ${Gt(n)}`;
    }
  });
}
function qg() {
  return ur("regexp", (e) => e instanceof RegExp);
}
function Dg(e) {
  return new zt({
    type: "set",
    schema: null,
    *entries(t) {
      if (e && t instanceof Set)
        for (const n of t)
          yield [n, n, e];
    },
    coercer(t) {
      return t instanceof Set ? new Set(t) : t;
    },
    validator(t) {
      return t instanceof Set || `Expected a \`Set\` object, but received: ${Gt(t)}`;
    }
  });
}
function Jp() {
  return ur("string", (e) => typeof e == "string" || `Expected a string, but received: ${Gt(e)}`);
}
function $g(e) {
  const t = Mc();
  return new zt({
    type: "tuple",
    schema: null,
    *entries(n) {
      if (Array.isArray(n)) {
        const i = Math.max(e.length, n.length);
        for (let s = 0; s < i; s++)
          yield [s, n[s], e[s] || t];
      }
    },
    validator(n) {
      return Array.isArray(n) || `Expected an array, but received: ${Gt(n)}`;
    }
  });
}
function Rc(e) {
  const t = Object.keys(e);
  return new zt({
    type: "type",
    schema: e,
    *entries(n) {
      if (Ir(n))
        for (const i of t)
          yield [i, n[i], e[i]];
    },
    validator(n) {
      return Ir(n) || `Expected an object, but received: ${Gt(n)}`;
    },
    coercer(n) {
      return Ir(n) ? { ...n } : n;
    }
  });
}
function Ug(e) {
  const t = e.map((n) => n.type).join(" | ");
  return new zt({
    type: "union",
    schema: null,
    coercer(n) {
      for (const i of e) {
        const [s, r] = i.validate(n, { coerce: !0 });
        if (!s)
          return r;
      }
      return n;
    },
    validator(n, i) {
      const s = [];
      for (const r of e) {
        const [...o] = Sc(n, r, i), [u] = o;
        if (u[0])
          for (const [c] of o)
            c && s.push(c);
        else
          return [];
      }
      return [
        `Expected the value to satisfy a union of \`${t}\`, but received: ${Gt(n)}`,
        ...s
      ];
    }
  });
}
function Xp() {
  return ur("unknown", () => !0);
}
function Bc(e, t, n) {
  return new zt({
    ...e,
    coercer: (i, s) => Ac(i, t) ? e.coercer(n(i, s), s) : e.coercer(i, s)
  });
}
function Fg(e, t, n = {}) {
  return Bc(e, Xp(), (i) => {
    const s = typeof t == "function" ? t() : t;
    if (i === void 0)
      return s;
    if (!n.strict && O0(i) && O0(s)) {
      const r = { ...i };
      let o = !1;
      for (const u in s)
        r[u] === void 0 && (r[u] = s[u], o = !0);
      if (o)
        return r;
    }
    return i;
  });
}
function Hg(e) {
  return Bc(e, Jp(), (t) => t.trim());
}
function zg(e) {
  return On(e, "empty", (t) => {
    const n = Yp(t);
    return n === 0 || `Expected an empty ${e.type} but received one with a size of \`${n}\``;
  });
}
function Yp(e) {
  return e instanceof Map || e instanceof Set ? e.size : e.length;
}
function Vg(e, t, n = {}) {
  const { exclusive: i } = n;
  return On(e, "max", (s) => i ? s < t : s <= t || `Expected a ${e.type} less than ${i ? "" : "or equal to "}${t} but received \`${s}\``);
}
function Kg(e, t, n = {}) {
  const { exclusive: i } = n;
  return On(e, "min", (s) => i ? s > t : s >= t || `Expected a ${e.type} greater than ${i ? "" : "or equal to "}${t} but received \`${s}\``);
}
function Zg(e) {
  return On(e, "nonempty", (t) => Yp(t) > 0 || `Expected a nonempty ${e.type} but received an empty one`);
}
function Gg(e, t) {
  return On(e, "pattern", (n) => t.test(n) || `Expected a ${e.type} matching \`/${t.source}/\` but received "${n}"`);
}
function Wg(e, t, n = t) {
  const i = `Expected a ${e.type}`, s = t === n ? `of \`${t}\`` : `between \`${t}\` and \`${n}\``;
  return On(e, "size", (r) => {
    if (typeof r == "number" || r instanceof Date)
      return t <= r && r <= n || `${i} ${s} but received \`${r}\``;
    if (r instanceof Map || r instanceof Set) {
      const { size: o } = r;
      return t <= o && o <= n || `${i} with a size ${s} but received one with a size of \`${o}\``;
    } else {
      const { length: o } = r;
      return t <= o && o <= n || `${i} with a length ${s} but received one with a length of \`${o}\``;
    }
  });
}
function On(e, t, n) {
  return new zt({
    ...e,
    *refiner(i, s) {
      yield* e.refiner(i, s);
      const r = n(i, s), o = ac(r, s, e, i);
      for (const u of o)
        yield { ...u, refinement: t };
    }
  });
}
const Jg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Struct: zt,
  StructError: Vp,
  any: Eg,
  array: Sg,
  assert: Kp,
  assign: vg,
  bigint: Ag,
  boolean: Mg,
  coerce: Bc,
  create: Zp,
  date: Rg,
  defaulted: Fg,
  define: ur,
  deprecated: bg,
  dynamic: yg,
  empty: zg,
  enums: Bg,
  func: Ig,
  instance: Tg,
  integer: Og,
  intersection: Pg,
  is: Ac,
  lazy: gg,
  literal: Cg,
  map: Ng,
  mask: Gp,
  max: Vg,
  min: Kg,
  never: Mc,
  nonempty: Zg,
  nullable: Lg,
  number: kg,
  object: Ci,
  omit: mg,
  optional: Wp,
  partial: _g,
  pattern: Gg,
  pick: wg,
  record: jg,
  refine: On,
  regexp: qg,
  set: Dg,
  size: Wg,
  string: Jp,
  struct: xg,
  trimmed: Hg,
  tuple: $g,
  type: Rc,
  union: Ug,
  unknown: Xp,
  validate: fi
}, Symbol.toStringTag, { value: "Module" })), Pn = /* @__PURE__ */ xp(Jg);
Object.defineProperty(er, "__esModule", { value: !0 });
er.assertExhaustive = er.assertStruct = er.assert = er.AssertionError = void 0;
const Xg = Pn;
function Yg(e) {
  return typeof e == "object" && e !== null && "message" in e;
}
function Qg(e) {
  var t, n;
  return typeof ((n = (t = e == null ? void 0 : e.prototype) === null || t === void 0 ? void 0 : t.constructor) === null || n === void 0 ? void 0 : n.name) == "string";
}
function e2(e) {
  const t = Yg(e) ? e.message : String(e);
  return t.endsWith(".") ? t.slice(0, -1) : t;
}
function Qp(e, t) {
  return Qg(e) ? new e({
    message: t
  }) : e({
    message: t
  });
}
class Ic extends Error {
  constructor(t) {
    super(t.message), this.code = "ERR_ASSERTION";
  }
}
er.AssertionError = Ic;
function t2(e, t = "Assertion failed.", n = Ic) {
  if (!e)
    throw t instanceof Error ? t : Qp(n, t);
}
er.assert = t2;
function r2(e, t, n = "Assertion failed", i = Ic) {
  try {
    (0, Xg.assert)(e, t);
  } catch (s) {
    throw Qp(i, `${n}: ${e2(s)}.`);
  }
}
er.assertStruct = r2;
function n2(e) {
  throw new Error("Invalid branch reached. Should be detected during compilation.");
}
er.assertExhaustive = n2;
var Ni = {};
Object.defineProperty(Ni, "__esModule", { value: !0 });
Ni.base64 = void 0;
const i2 = Pn, a2 = er, f2 = (e, t = {}) => {
  var n, i;
  const s = (n = t.paddingRequired) !== null && n !== void 0 ? n : !1, r = (i = t.characterSet) !== null && i !== void 0 ? i : "base64";
  let o;
  r === "base64" ? o = String.raw`[A-Za-z0-9+\/]` : ((0, a2.assert)(r === "base64url"), o = String.raw`[-_A-Za-z0-9]`);
  let u;
  return s ? u = new RegExp(`^(?:${o}{4})*(?:${o}{3}=|${o}{2}==)?$`, "u") : u = new RegExp(`^(?:${o}{4})*(?:${o}{2,3}|${o}{3}=|${o}{2}==)?$`, "u"), (0, i2.pattern)(e, u);
};
Ni.base64 = f2;
var Tt = {}, Li = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.remove0x = e.add0x = e.assertIsStrictHexString = e.assertIsHexString = e.isStrictHexString = e.isHexString = e.StrictHexStruct = e.HexStruct = void 0;
  const t = Pn, n = er;
  e.HexStruct = (0, t.pattern)((0, t.string)(), /^(?:0x)?[0-9a-f]+$/iu), e.StrictHexStruct = (0, t.pattern)((0, t.string)(), /^0x[0-9a-f]+$/iu);
  function i(h) {
    return (0, t.is)(h, e.HexStruct);
  }
  e.isHexString = i;
  function s(h) {
    return (0, t.is)(h, e.StrictHexStruct);
  }
  e.isStrictHexString = s;
  function r(h) {
    (0, n.assert)(i(h), "Value must be a hexadecimal string.");
  }
  e.assertIsHexString = r;
  function o(h) {
    (0, n.assert)(s(h), 'Value must be a hexadecimal string, starting with "0x".');
  }
  e.assertIsStrictHexString = o;
  function u(h) {
    return h.startsWith("0x") ? h : h.startsWith("0X") ? `0x${h.substring(2)}` : `0x${h}`;
  }
  e.add0x = u;
  function c(h) {
    return h.startsWith("0x") || h.startsWith("0X") ? h.substring(2) : h;
  }
  e.remove0x = c;
})(Li);
Object.defineProperty(Tt, "__esModule", { value: !0 });
Tt.createDataView = Tt.concatBytes = Tt.valueToBytes = Tt.stringToBytes = Tt.numberToBytes = Tt.signedBigIntToBytes = Tt.bigIntToBytes = Tt.hexToBytes = Tt.bytesToString = Tt.bytesToNumber = Tt.bytesToSignedBigInt = Tt.bytesToBigInt = Tt.bytesToHex = Tt.assertIsBytes = Tt.isBytes = void 0;
const lr = er, fc = Li, P0 = 48, C0 = 58, N0 = 87;
function o2() {
  const e = [];
  return () => {
    if (e.length === 0)
      for (let t = 0; t < 256; t++)
        e.push(t.toString(16).padStart(2, "0"));
    return e;
  };
}
const s2 = o2();
function Tc(e) {
  return e instanceof Uint8Array;
}
Tt.isBytes = Tc;
function oi(e) {
  (0, lr.assert)(Tc(e), "Value must be a Uint8Array.");
}
Tt.assertIsBytes = oi;
function ev(e) {
  if (oi(e), e.length === 0)
    return "0x";
  const t = s2(), n = new Array(e.length);
  for (let i = 0; i < e.length; i++)
    n[i] = t[e[i]];
  return (0, fc.add0x)(n.join(""));
}
Tt.bytesToHex = ev;
function tv(e) {
  oi(e);
  const t = ev(e);
  return BigInt(t);
}
Tt.bytesToBigInt = tv;
function u2(e) {
  oi(e);
  let t = BigInt(0);
  for (const n of e)
    t = (t << BigInt(8)) + BigInt(n);
  return BigInt.asIntN(e.length * 8, t);
}
Tt.bytesToSignedBigInt = u2;
function c2(e) {
  oi(e);
  const t = tv(e);
  return (0, lr.assert)(t <= BigInt(Number.MAX_SAFE_INTEGER), "Number is not a safe integer. Use `bytesToBigInt` instead."), Number(t);
}
Tt.bytesToNumber = c2;
function h2(e) {
  return oi(e), new TextDecoder().decode(e);
}
Tt.bytesToString = h2;
function Na(e) {
  var t;
  if (((t = e == null ? void 0 : e.toLowerCase) === null || t === void 0 ? void 0 : t.call(e)) === "0x")
    return new Uint8Array();
  (0, fc.assertIsHexString)(e);
  const n = (0, fc.remove0x)(e).toLowerCase(), i = n.length % 2 === 0 ? n : `0${n}`, s = new Uint8Array(i.length / 2);
  for (let r = 0; r < s.length; r++) {
    const o = i.charCodeAt(r * 2), u = i.charCodeAt(r * 2 + 1), c = o - (o < C0 ? P0 : N0), h = u - (u < C0 ? P0 : N0);
    s[r] = c * 16 + h;
  }
  return s;
}
Tt.hexToBytes = Na;
function rv(e) {
  (0, lr.assert)(typeof e == "bigint", "Value must be a bigint."), (0, lr.assert)(e >= BigInt(0), "Value must be a non-negative bigint.");
  const t = e.toString(16);
  return Na(t);
}
Tt.bigIntToBytes = rv;
function l2(e, t) {
  (0, lr.assert)(t > 0);
  const n = e >> BigInt(31);
  return !((~e & n) + (e & ~n) >> BigInt(t * 8 + -1));
}
function d2(e, t) {
  (0, lr.assert)(typeof e == "bigint", "Value must be a bigint."), (0, lr.assert)(typeof t == "number", "Byte length must be a number."), (0, lr.assert)(t > 0, "Byte length must be greater than 0."), (0, lr.assert)(l2(e, t), "Byte length is too small to represent the given value.");
  let n = e;
  const i = new Uint8Array(t);
  for (let s = 0; s < i.length; s++)
    i[s] = Number(BigInt.asUintN(8, n)), n >>= BigInt(8);
  return i.reverse();
}
Tt.signedBigIntToBytes = d2;
function nv(e) {
  (0, lr.assert)(typeof e == "number", "Value must be a number."), (0, lr.assert)(e >= 0, "Value must be a non-negative number."), (0, lr.assert)(Number.isSafeInteger(e), "Value is not a safe integer. Use `bigIntToBytes` instead.");
  const t = e.toString(16);
  return Na(t);
}
Tt.numberToBytes = nv;
function iv(e) {
  return (0, lr.assert)(typeof e == "string", "Value must be a string."), new TextEncoder().encode(e);
}
Tt.stringToBytes = iv;
function av(e) {
  if (typeof e == "bigint")
    return rv(e);
  if (typeof e == "number")
    return nv(e);
  if (typeof e == "string")
    return e.startsWith("0x") ? Na(e) : iv(e);
  if (Tc(e))
    return e;
  throw new TypeError(`Unsupported value type: "${typeof e}".`);
}
Tt.valueToBytes = av;
function p2(e) {
  const t = new Array(e.length);
  let n = 0;
  for (let s = 0; s < e.length; s++) {
    const r = av(e[s]);
    t[s] = r, n += r.length;
  }
  const i = new Uint8Array(n);
  for (let s = 0, r = 0; s < t.length; s++)
    i.set(t[s], r), r += t[s].length;
  return i;
}
Tt.concatBytes = p2;
function v2(e) {
  if (typeof Buffer < "u" && e instanceof Buffer) {
    const t = e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);
    return new DataView(t);
  }
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
Tt.createDataView = v2;
var La = {};
Object.defineProperty(La, "__esModule", { value: !0 });
La.ChecksumStruct = void 0;
const L0 = Pn, b2 = Ni;
La.ChecksumStruct = (0, L0.size)((0, b2.base64)((0, L0.string)(), { paddingRequired: !0 }), 44, 44);
var Vr = {};
Object.defineProperty(Vr, "__esModule", { value: !0 });
Vr.createHex = Vr.createBytes = Vr.createBigInt = Vr.createNumber = void 0;
const qt = Pn, y2 = er, fv = Tt, ka = Li, ov = (0, qt.union)([(0, qt.number)(), (0, qt.bigint)(), (0, qt.string)(), ka.StrictHexStruct]), g2 = (0, qt.coerce)((0, qt.number)(), ov, Number), m2 = (0, qt.coerce)((0, qt.bigint)(), ov, BigInt);
(0, qt.union)([ka.StrictHexStruct, (0, qt.instance)(Uint8Array)]);
const _2 = (0, qt.coerce)((0, qt.instance)(Uint8Array), (0, qt.union)([ka.StrictHexStruct]), fv.hexToBytes), w2 = (0, qt.coerce)(ka.StrictHexStruct, (0, qt.instance)(Uint8Array), fv.bytesToHex);
function x2(e) {
  try {
    const t = (0, qt.create)(e, g2);
    return (0, y2.assert)(Number.isFinite(t), `Expected a number-like value, got "${e}".`), t;
  } catch (t) {
    throw t instanceof qt.StructError ? new Error(`Expected a number-like value, got "${e}".`) : t;
  }
}
Vr.createNumber = x2;
function E2(e) {
  try {
    return (0, qt.create)(e, m2);
  } catch (t) {
    throw t instanceof qt.StructError ? new Error(`Expected a number-like value, got "${String(t.value)}".`) : t;
  }
}
Vr.createBigInt = E2;
function S2(e) {
  if (typeof e == "string" && e.toLowerCase() === "0x")
    return new Uint8Array();
  try {
    return (0, qt.create)(e, _2);
  } catch (t) {
    throw t instanceof qt.StructError ? new Error(`Expected a bytes-like value, got "${String(t.value)}".`) : t;
  }
}
Vr.createBytes = S2;
function A2(e) {
  if (e instanceof Uint8Array && e.length === 0 || typeof e == "string" && e.toLowerCase() === "0x")
    return "0x";
  try {
    return (0, qt.create)(e, w2);
  } catch (t) {
    throw t instanceof qt.StructError ? new Error(`Expected a bytes-like value, got "${String(t.value)}".`) : t;
  }
}
Vr.createHex = A2;
var Jn = {}, sv = Ze && Ze.__classPrivateFieldSet || function(e, t, n, i, s) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof t == "function" ? e !== t || !s : !t.has(e))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? s.call(e, n) : s ? s.value = n : t.set(e, n), n;
}, fr = Ze && Ze.__classPrivateFieldGet || function(e, t, n, i) {
  if (n === "a" && !i)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !i : !t.has(e))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? i : n === "a" ? i.call(e) : i ? i.value : t.get(e);
}, Pr, $r;
Object.defineProperty(Jn, "__esModule", { value: !0 });
Jn.FrozenSet = Jn.FrozenMap = void 0;
class Oc {
  constructor(t) {
    Pr.set(this, void 0), sv(this, Pr, new Map(t), "f"), Object.freeze(this);
  }
  get size() {
    return fr(this, Pr, "f").size;
  }
  [(Pr = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    return fr(this, Pr, "f")[Symbol.iterator]();
  }
  entries() {
    return fr(this, Pr, "f").entries();
  }
  forEach(t, n) {
    return fr(this, Pr, "f").forEach((i, s, r) => t.call(n, i, s, this));
  }
  get(t) {
    return fr(this, Pr, "f").get(t);
  }
  has(t) {
    return fr(this, Pr, "f").has(t);
  }
  keys() {
    return fr(this, Pr, "f").keys();
  }
  values() {
    return fr(this, Pr, "f").values();
  }
  toString() {
    return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([t, n]) => `${String(t)} => ${String(n)}`).join(", ")} ` : ""}}`;
  }
}
Jn.FrozenMap = Oc;
class Pc {
  constructor(t) {
    $r.set(this, void 0), sv(this, $r, new Set(t), "f"), Object.freeze(this);
  }
  get size() {
    return fr(this, $r, "f").size;
  }
  [($r = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    return fr(this, $r, "f")[Symbol.iterator]();
  }
  entries() {
    return fr(this, $r, "f").entries();
  }
  forEach(t, n) {
    return fr(this, $r, "f").forEach((i, s, r) => t.call(n, i, s, this));
  }
  has(t) {
    return fr(this, $r, "f").has(t);
  }
  keys() {
    return fr(this, $r, "f").keys();
  }
  values() {
    return fr(this, $r, "f").values();
  }
  toString() {
    return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map((t) => String(t)).join(", ")} ` : ""}}`;
  }
}
Jn.FrozenSet = Pc;
Object.freeze(Oc);
Object.freeze(Oc.prototype);
Object.freeze(Pc);
Object.freeze(Pc.prototype);
var uv = {}, Cc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.calculateNumberSize = e.calculateStringSize = e.isASCII = e.isPlainObject = e.ESCAPE_CHARACTERS_REGEXP = e.JsonSize = e.hasProperty = e.isObject = e.isNullOrUndefined = e.isNonEmptyArray = void 0;
  function t(h) {
    return Array.isArray(h) && h.length > 0;
  }
  e.isNonEmptyArray = t;
  function n(h) {
    return h == null;
  }
  e.isNullOrUndefined = n;
  function i(h) {
    return !!h && typeof h == "object" && !Array.isArray(h);
  }
  e.isObject = i;
  const s = (h, f) => Object.hasOwnProperty.call(h, f);
  e.hasProperty = s, function(h) {
    h[h.Null = 4] = "Null", h[h.Comma = 1] = "Comma", h[h.Wrapper = 1] = "Wrapper", h[h.True = 4] = "True", h[h.False = 5] = "False", h[h.Quote = 1] = "Quote", h[h.Colon = 1] = "Colon", h[h.Date = 24] = "Date";
  }(e.JsonSize || (e.JsonSize = {})), e.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
  function r(h) {
    if (typeof h != "object" || h === null)
      return !1;
    try {
      let f = h;
      for (; Object.getPrototypeOf(f) !== null; )
        f = Object.getPrototypeOf(f);
      return Object.getPrototypeOf(h) === f;
    } catch {
      return !1;
    }
  }
  e.isPlainObject = r;
  function o(h) {
    return h.charCodeAt(0) <= 127;
  }
  e.isASCII = o;
  function u(h) {
    var f;
    return h.split("").reduce((v, m) => o(m) ? v + 1 : v + 2, 0) + ((f = h.match(e.ESCAPE_CHARACTERS_REGEXP)) !== null && f !== void 0 ? f : []).length;
  }
  e.calculateStringSize = u;
  function c(h) {
    return h.toString().length;
  }
  e.calculateNumberSize = c;
})(Cc);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.validateJsonAndGetSize = e.getJsonRpcIdValidator = e.assertIsJsonRpcError = e.isJsonRpcError = e.assertIsJsonRpcFailure = e.isJsonRpcFailure = e.assertIsJsonRpcSuccess = e.isJsonRpcSuccess = e.assertIsJsonRpcResponse = e.isJsonRpcResponse = e.assertIsPendingJsonRpcResponse = e.isPendingJsonRpcResponse = e.JsonRpcResponseStruct = e.JsonRpcFailureStruct = e.JsonRpcSuccessStruct = e.PendingJsonRpcResponseStruct = e.assertIsJsonRpcRequest = e.isJsonRpcRequest = e.assertIsJsonRpcNotification = e.isJsonRpcNotification = e.JsonRpcNotificationStruct = e.JsonRpcRequestStruct = e.JsonRpcParamsStruct = e.JsonRpcErrorStruct = e.JsonRpcIdStruct = e.JsonRpcVersionStruct = e.jsonrpc2 = e.isValidJson = e.JsonStruct = void 0;
  const t = Pn, n = er, i = Cc;
  e.JsonStruct = (0, t.define)("Json", (N) => {
    const [q] = j(N, !0);
    return q ? !0 : "Expected a valid JSON-serializable value";
  });
  function s(N) {
    return (0, t.is)(N, e.JsonStruct);
  }
  e.isValidJson = s, e.jsonrpc2 = "2.0", e.JsonRpcVersionStruct = (0, t.literal)(e.jsonrpc2), e.JsonRpcIdStruct = (0, t.nullable)((0, t.union)([(0, t.number)(), (0, t.string)()])), e.JsonRpcErrorStruct = (0, t.object)({
    code: (0, t.integer)(),
    message: (0, t.string)(),
    data: (0, t.optional)(e.JsonStruct),
    stack: (0, t.optional)((0, t.string)())
  }), e.JsonRpcParamsStruct = (0, t.optional)((0, t.union)([(0, t.record)((0, t.string)(), e.JsonStruct), (0, t.array)(e.JsonStruct)])), e.JsonRpcRequestStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    method: (0, t.string)(),
    params: e.JsonRpcParamsStruct
  }), e.JsonRpcNotificationStruct = (0, t.omit)(e.JsonRpcRequestStruct, ["id"]);
  function r(N) {
    return (0, t.is)(N, e.JsonRpcNotificationStruct);
  }
  e.isJsonRpcNotification = r;
  function o(N, q) {
    (0, n.assertStruct)(N, e.JsonRpcNotificationStruct, "Invalid JSON-RPC notification", q);
  }
  e.assertIsJsonRpcNotification = o;
  function u(N) {
    return (0, t.is)(N, e.JsonRpcRequestStruct);
  }
  e.isJsonRpcRequest = u;
  function c(N, q) {
    (0, n.assertStruct)(N, e.JsonRpcRequestStruct, "Invalid JSON-RPC request", q);
  }
  e.assertIsJsonRpcRequest = c, e.PendingJsonRpcResponseStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    result: (0, t.optional)((0, t.unknown)()),
    error: (0, t.optional)(e.JsonRpcErrorStruct)
  }), e.JsonRpcSuccessStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    result: e.JsonStruct
  }), e.JsonRpcFailureStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    error: e.JsonRpcErrorStruct
  }), e.JsonRpcResponseStruct = (0, t.union)([
    e.JsonRpcSuccessStruct,
    e.JsonRpcFailureStruct
  ]);
  function h(N) {
    return (0, t.is)(N, e.PendingJsonRpcResponseStruct);
  }
  e.isPendingJsonRpcResponse = h;
  function f(N, q) {
    (0, n.assertStruct)(N, e.PendingJsonRpcResponseStruct, "Invalid pending JSON-RPC response", q);
  }
  e.assertIsPendingJsonRpcResponse = f;
  function b(N) {
    return (0, t.is)(N, e.JsonRpcResponseStruct);
  }
  e.isJsonRpcResponse = b;
  function v(N, q) {
    (0, n.assertStruct)(N, e.JsonRpcResponseStruct, "Invalid JSON-RPC response", q);
  }
  e.assertIsJsonRpcResponse = v;
  function m(N) {
    return (0, t.is)(N, e.JsonRpcSuccessStruct);
  }
  e.isJsonRpcSuccess = m;
  function E(N, q) {
    (0, n.assertStruct)(N, e.JsonRpcSuccessStruct, "Invalid JSON-RPC success response", q);
  }
  e.assertIsJsonRpcSuccess = E;
  function M(N) {
    return (0, t.is)(N, e.JsonRpcFailureStruct);
  }
  e.isJsonRpcFailure = M;
  function B(N, q) {
    (0, n.assertStruct)(N, e.JsonRpcFailureStruct, "Invalid JSON-RPC failure response", q);
  }
  e.assertIsJsonRpcFailure = B;
  function I(N) {
    return (0, t.is)(N, e.JsonRpcErrorStruct);
  }
  e.isJsonRpcError = I;
  function T(N, q) {
    (0, n.assertStruct)(N, e.JsonRpcErrorStruct, "Invalid JSON-RPC error", q);
  }
  e.assertIsJsonRpcError = T;
  function k(N) {
    const { permitEmptyString: q, permitFractions: D, permitNull: re } = Object.assign({ permitEmptyString: !0, permitFractions: !1, permitNull: !0 }, N);
    return (oe) => !!(typeof oe == "number" && (D || Number.isInteger(oe)) || typeof oe == "string" && (q || oe.length > 0) || re && oe === null);
  }
  e.getJsonRpcIdValidator = k;
  function j(N, q = !1) {
    const D = /* @__PURE__ */ new Set();
    function re(te, oe) {
      if (te === void 0)
        return [!1, 0];
      if (te === null)
        return [!0, oe ? 0 : i.JsonSize.Null];
      const U = typeof te;
      try {
        if (U === "function")
          return [!1, 0];
        if (U === "string" || te instanceof String)
          return [
            !0,
            oe ? 0 : (0, i.calculateStringSize)(te) + i.JsonSize.Quote * 2
          ];
        if (U === "boolean" || te instanceof Boolean)
          return oe ? [!0, 0] : [!0, te == !0 ? i.JsonSize.True : i.JsonSize.False];
        if (U === "number" || te instanceof Number)
          return oe ? [!0, 0] : [!0, (0, i.calculateNumberSize)(te)];
        if (te instanceof Date)
          return oe ? [!0, 0] : [
            !0,
            // Note: Invalid dates will serialize to null
            isNaN(te.getDate()) ? i.JsonSize.Null : i.JsonSize.Date + i.JsonSize.Quote * 2
          ];
      } catch {
        return [!1, 0];
      }
      if (!(0, i.isPlainObject)(te) && !Array.isArray(te))
        return [!1, 0];
      if (D.has(te))
        return [!1, 0];
      D.add(te);
      try {
        return [
          !0,
          Object.entries(te).reduce(
            (y, [p, a], l, _) => {
              let [x, A] = re(a, oe);
              if (!x)
                throw new Error("JSON validation did not pass. Validation process stopped.");
              if (D.delete(te), oe)
                return 0;
              const S = Array.isArray(te) ? 0 : p.length + i.JsonSize.Comma + i.JsonSize.Colon * 2, g = l < _.length - 1 ? i.JsonSize.Comma : 0;
              return y + S + A + g;
            },
            // Starts at 2 because the serialized JSON string data (plain text)
            // will minimally contain {}/[]
            oe ? 0 : i.JsonSize.Wrapper * 2
          )
        ];
      } catch {
        return [!1, 0];
      }
    }
    return re(N, q);
  }
  e.validateJsonAndGetSize = j;
})(uv);
var Xn = {}, oc = { exports: {} }, Af, k0;
function M2() {
  if (k0)
    return Af;
  k0 = 1;
  var e = 1e3, t = e * 60, n = t * 60, i = n * 24, s = i * 7, r = i * 365.25;
  Af = function(f, b) {
    b = b || {};
    var v = typeof f;
    if (v === "string" && f.length > 0)
      return o(f);
    if (v === "number" && isFinite(f))
      return b.long ? c(f) : u(f);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(f)
    );
  };
  function o(f) {
    if (f = String(f), !(f.length > 100)) {
      var b = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        f
      );
      if (b) {
        var v = parseFloat(b[1]), m = (b[2] || "ms").toLowerCase();
        switch (m) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return v * r;
          case "weeks":
          case "week":
          case "w":
            return v * s;
          case "days":
          case "day":
          case "d":
            return v * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return v * n;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return v * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return v * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return v;
          default:
            return;
        }
      }
    }
  }
  function u(f) {
    var b = Math.abs(f);
    return b >= i ? Math.round(f / i) + "d" : b >= n ? Math.round(f / n) + "h" : b >= t ? Math.round(f / t) + "m" : b >= e ? Math.round(f / e) + "s" : f + "ms";
  }
  function c(f) {
    var b = Math.abs(f);
    return b >= i ? h(f, b, i, "day") : b >= n ? h(f, b, n, "hour") : b >= t ? h(f, b, t, "minute") : b >= e ? h(f, b, e, "second") : f + " ms";
  }
  function h(f, b, v, m) {
    var E = b >= v * 1.5;
    return Math.round(f / v) + " " + m + (E ? "s" : "");
  }
  return Af;
}
function R2(e) {
  n.debug = n, n.default = n, n.coerce = c, n.disable = r, n.enable = s, n.enabled = o, n.humanize = M2(), n.destroy = h, Object.keys(e).forEach((f) => {
    n[f] = e[f];
  }), n.names = [], n.skips = [], n.formatters = {};
  function t(f) {
    let b = 0;
    for (let v = 0; v < f.length; v++)
      b = (b << 5) - b + f.charCodeAt(v), b |= 0;
    return n.colors[Math.abs(b) % n.colors.length];
  }
  n.selectColor = t;
  function n(f) {
    let b, v = null, m, E;
    function M(...B) {
      if (!M.enabled)
        return;
      const I = M, T = Number(/* @__PURE__ */ new Date()), k = T - (b || T);
      I.diff = k, I.prev = b, I.curr = T, b = T, B[0] = n.coerce(B[0]), typeof B[0] != "string" && B.unshift("%O");
      let j = 0;
      B[0] = B[0].replace(/%([a-zA-Z%])/g, (q, D) => {
        if (q === "%%")
          return "%";
        j++;
        const re = n.formatters[D];
        if (typeof re == "function") {
          const te = B[j];
          q = re.call(I, te), B.splice(j, 1), j--;
        }
        return q;
      }), n.formatArgs.call(I, B), (I.log || n.log).apply(I, B);
    }
    return M.namespace = f, M.useColors = n.useColors(), M.color = n.selectColor(f), M.extend = i, M.destroy = n.destroy, Object.defineProperty(M, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => v !== null ? v : (m !== n.namespaces && (m = n.namespaces, E = n.enabled(f)), E),
      set: (B) => {
        v = B;
      }
    }), typeof n.init == "function" && n.init(M), M;
  }
  function i(f, b) {
    const v = n(this.namespace + (typeof b > "u" ? ":" : b) + f);
    return v.log = this.log, v;
  }
  function s(f) {
    n.save(f), n.namespaces = f, n.names = [], n.skips = [];
    let b;
    const v = (typeof f == "string" ? f : "").split(/[\s,]+/), m = v.length;
    for (b = 0; b < m; b++)
      v[b] && (f = v[b].replace(/\*/g, ".*?"), f[0] === "-" ? n.skips.push(new RegExp("^" + f.slice(1) + "$")) : n.names.push(new RegExp("^" + f + "$")));
  }
  function r() {
    const f = [
      ...n.names.map(u),
      ...n.skips.map(u).map((b) => "-" + b)
    ].join(",");
    return n.enable(""), f;
  }
  function o(f) {
    if (f[f.length - 1] === "*")
      return !0;
    let b, v;
    for (b = 0, v = n.skips.length; b < v; b++)
      if (n.skips[b].test(f))
        return !1;
    for (b = 0, v = n.names.length; b < v; b++)
      if (n.names[b].test(f))
        return !0;
    return !1;
  }
  function u(f) {
    return f.toString().substring(2, f.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function c(f) {
    return f instanceof Error ? f.stack || f.message : f;
  }
  function h() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return n.enable(n.load()), n;
}
var B2 = R2;
(function(e, t) {
  t.formatArgs = i, t.save = s, t.load = r, t.useColors = n, t.storage = o(), t.destroy = (() => {
    let c = !1;
    return () => {
      c || (c = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function n() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function i(c) {
    if (c[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + c[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
      return;
    const h = "color: " + this.color;
    c.splice(1, 0, h, "color: inherit");
    let f = 0, b = 0;
    c[0].replace(/%[a-zA-Z%]/g, (v) => {
      v !== "%%" && (f++, v === "%c" && (b = f));
    }), c.splice(b, 0, h);
  }
  t.log = console.debug || console.log || (() => {
  });
  function s(c) {
    try {
      c ? t.storage.setItem("debug", c) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function r() {
    let c;
    try {
      c = t.storage.getItem("debug");
    } catch {
    }
    return !c && typeof process < "u" && "env" in process && (c = process.env.DEBUG), c;
  }
  function o() {
    try {
      return localStorage;
    } catch {
    }
  }
  e.exports = B2(t);
  const { formatters: u } = e.exports;
  u.j = function(c) {
    try {
      return JSON.stringify(c);
    } catch (h) {
      return "[UnexpectedJSONParseError]: " + h.message;
    }
  };
})(oc, oc.exports);
var I2 = oc.exports, T2 = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Xn, "__esModule", { value: !0 });
Xn.createModuleLogger = Xn.createProjectLogger = void 0;
const O2 = T2(I2), P2 = (0, O2.default)("metamask");
function C2(e) {
  return P2.extend(e);
}
Xn.createProjectLogger = C2;
function N2(e, t) {
  return e.extend(t);
}
Xn.createModuleLogger = N2;
var Kr = {};
Object.defineProperty(Kr, "__esModule", { value: !0 });
Kr.hexToBigInt = Kr.hexToNumber = Kr.bigIntToHex = Kr.numberToHex = void 0;
const Kn = er, Si = Li, L2 = (e) => ((0, Kn.assert)(typeof e == "number", "Value must be a number."), (0, Kn.assert)(e >= 0, "Value must be a non-negative number."), (0, Kn.assert)(Number.isSafeInteger(e), "Value is not a safe integer. Use `bigIntToHex` instead."), (0, Si.add0x)(e.toString(16)));
Kr.numberToHex = L2;
const k2 = (e) => ((0, Kn.assert)(typeof e == "bigint", "Value must be a bigint."), (0, Kn.assert)(e >= 0, "Value must be a non-negative bigint."), (0, Si.add0x)(e.toString(16)));
Kr.bigIntToHex = k2;
const j2 = (e) => {
  (0, Si.assertIsHexString)(e);
  const t = parseInt(e, 16);
  return (0, Kn.assert)(Number.isSafeInteger(t), "Value is not a safe integer. Use `hexToBigInt` instead."), t;
};
Kr.hexToNumber = j2;
const q2 = (e) => ((0, Si.assertIsHexString)(e), BigInt((0, Si.add0x)(e)));
Kr.hexToBigInt = q2;
var cv = {};
Object.defineProperty(cv, "__esModule", { value: !0 });
var hv = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.timeSince = e.inMilliseconds = e.Duration = void 0, function(r) {
    r[r.Millisecond = 1] = "Millisecond", r[r.Second = 1e3] = "Second", r[r.Minute = 6e4] = "Minute", r[r.Hour = 36e5] = "Hour", r[r.Day = 864e5] = "Day", r[r.Week = 6048e5] = "Week", r[r.Year = 31536e6] = "Year";
  }(e.Duration || (e.Duration = {}));
  const t = (r) => Number.isInteger(r) && r >= 0, n = (r, o) => {
    if (!t(r))
      throw new Error(`"${o}" must be a non-negative integer. Received: "${r}".`);
  };
  function i(r, o) {
    return n(r, "count"), r * o;
  }
  e.inMilliseconds = i;
  function s(r) {
    return n(r, "timestamp"), Date.now() - r;
  }
  e.timeSince = s;
})(hv);
var lv = {}, sc = { exports: {} };
const D2 = "2.0.0", dv = 256, $2 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, U2 = 16, F2 = dv - 6, H2 = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var ja = {
  MAX_LENGTH: dv,
  MAX_SAFE_COMPONENT_LENGTH: U2,
  MAX_SAFE_BUILD_LENGTH: F2,
  MAX_SAFE_INTEGER: $2,
  RELEASE_TYPES: H2,
  SEMVER_SPEC_VERSION: D2,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const z2 = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
};
var qa = z2;
(function(e, t) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: n,
    MAX_SAFE_BUILD_LENGTH: i,
    MAX_LENGTH: s
  } = ja, r = qa;
  t = e.exports = {};
  const o = t.re = [], u = t.safeRe = [], c = t.src = [], h = t.t = {};
  let f = 0;
  const b = "[a-zA-Z0-9-]", v = [
    ["\\s", 1],
    ["\\d", s],
    [b, i]
  ], m = (M) => {
    for (const [B, I] of v)
      M = M.split(`${B}*`).join(`${B}{0,${I}}`).split(`${B}+`).join(`${B}{1,${I}}`);
    return M;
  }, E = (M, B, I) => {
    const T = m(B), k = f++;
    r(M, k, B), h[M] = k, c[k] = B, o[k] = new RegExp(B, I ? "g" : void 0), u[k] = new RegExp(T, I ? "g" : void 0);
  };
  E("NUMERICIDENTIFIER", "0|[1-9]\\d*"), E("NUMERICIDENTIFIERLOOSE", "\\d+"), E("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${b}*`), E("MAINVERSION", `(${c[h.NUMERICIDENTIFIER]})\\.(${c[h.NUMERICIDENTIFIER]})\\.(${c[h.NUMERICIDENTIFIER]})`), E("MAINVERSIONLOOSE", `(${c[h.NUMERICIDENTIFIERLOOSE]})\\.(${c[h.NUMERICIDENTIFIERLOOSE]})\\.(${c[h.NUMERICIDENTIFIERLOOSE]})`), E("PRERELEASEIDENTIFIER", `(?:${c[h.NUMERICIDENTIFIER]}|${c[h.NONNUMERICIDENTIFIER]})`), E("PRERELEASEIDENTIFIERLOOSE", `(?:${c[h.NUMERICIDENTIFIERLOOSE]}|${c[h.NONNUMERICIDENTIFIER]})`), E("PRERELEASE", `(?:-(${c[h.PRERELEASEIDENTIFIER]}(?:\\.${c[h.PRERELEASEIDENTIFIER]})*))`), E("PRERELEASELOOSE", `(?:-?(${c[h.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${c[h.PRERELEASEIDENTIFIERLOOSE]})*))`), E("BUILDIDENTIFIER", `${b}+`), E("BUILD", `(?:\\+(${c[h.BUILDIDENTIFIER]}(?:\\.${c[h.BUILDIDENTIFIER]})*))`), E("FULLPLAIN", `v?${c[h.MAINVERSION]}${c[h.PRERELEASE]}?${c[h.BUILD]}?`), E("FULL", `^${c[h.FULLPLAIN]}$`), E("LOOSEPLAIN", `[v=\\s]*${c[h.MAINVERSIONLOOSE]}${c[h.PRERELEASELOOSE]}?${c[h.BUILD]}?`), E("LOOSE", `^${c[h.LOOSEPLAIN]}$`), E("GTLT", "((?:<|>)?=?)"), E("XRANGEIDENTIFIERLOOSE", `${c[h.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), E("XRANGEIDENTIFIER", `${c[h.NUMERICIDENTIFIER]}|x|X|\\*`), E("XRANGEPLAIN", `[v=\\s]*(${c[h.XRANGEIDENTIFIER]})(?:\\.(${c[h.XRANGEIDENTIFIER]})(?:\\.(${c[h.XRANGEIDENTIFIER]})(?:${c[h.PRERELEASE]})?${c[h.BUILD]}?)?)?`), E("XRANGEPLAINLOOSE", `[v=\\s]*(${c[h.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[h.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[h.XRANGEIDENTIFIERLOOSE]})(?:${c[h.PRERELEASELOOSE]})?${c[h.BUILD]}?)?)?`), E("XRANGE", `^${c[h.GTLT]}\\s*${c[h.XRANGEPLAIN]}$`), E("XRANGELOOSE", `^${c[h.GTLT]}\\s*${c[h.XRANGEPLAINLOOSE]}$`), E("COERCE", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?(?:$|[^\\d])`), E("COERCERTL", c[h.COERCE], !0), E("LONETILDE", "(?:~>?)"), E("TILDETRIM", `(\\s*)${c[h.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", E("TILDE", `^${c[h.LONETILDE]}${c[h.XRANGEPLAIN]}$`), E("TILDELOOSE", `^${c[h.LONETILDE]}${c[h.XRANGEPLAINLOOSE]}$`), E("LONECARET", "(?:\\^)"), E("CARETTRIM", `(\\s*)${c[h.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", E("CARET", `^${c[h.LONECARET]}${c[h.XRANGEPLAIN]}$`), E("CARETLOOSE", `^${c[h.LONECARET]}${c[h.XRANGEPLAINLOOSE]}$`), E("COMPARATORLOOSE", `^${c[h.GTLT]}\\s*(${c[h.LOOSEPLAIN]})$|^$`), E("COMPARATOR", `^${c[h.GTLT]}\\s*(${c[h.FULLPLAIN]})$|^$`), E("COMPARATORTRIM", `(\\s*)${c[h.GTLT]}\\s*(${c[h.LOOSEPLAIN]}|${c[h.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", E("HYPHENRANGE", `^\\s*(${c[h.XRANGEPLAIN]})\\s+-\\s+(${c[h.XRANGEPLAIN]})\\s*$`), E("HYPHENRANGELOOSE", `^\\s*(${c[h.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[h.XRANGEPLAINLOOSE]})\\s*$`), E("STAR", "(<|>)?=?\\s*\\*"), E("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), E("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(sc, sc.exports);
var ki = sc.exports;
const V2 = Object.freeze({ loose: !0 }), K2 = Object.freeze({}), Z2 = (e) => e ? typeof e != "object" ? V2 : e : K2;
var Nc = Z2;
const j0 = /^[0-9]+$/, pv = (e, t) => {
  const n = j0.test(e), i = j0.test(t);
  return n && i && (e = +e, t = +t), e === t ? 0 : n && !i ? -1 : i && !n ? 1 : e < t ? -1 : 1;
}, G2 = (e, t) => pv(t, e);
var vv = {
  compareIdentifiers: pv,
  rcompareIdentifiers: G2
};
const Vi = qa, { MAX_LENGTH: q0, MAX_SAFE_INTEGER: Ki } = ja, { safeRe: D0, t: $0 } = ki, W2 = Nc, { compareIdentifiers: Nn } = vv;
let J2 = class Fr {
  constructor(t, n) {
    if (n = W2(n), t instanceof Fr) {
      if (t.loose === !!n.loose && t.includePrerelease === !!n.includePrerelease)
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t}".`);
    if (t.length > q0)
      throw new TypeError(
        `version is longer than ${q0} characters`
      );
    Vi("SemVer", t, n), this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease;
    const i = t.trim().match(n.loose ? D0[$0.LOOSE] : D0[$0.FULL]);
    if (!i)
      throw new TypeError(`Invalid Version: ${t}`);
    if (this.raw = t, this.major = +i[1], this.minor = +i[2], this.patch = +i[3], this.major > Ki || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Ki || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Ki || this.patch < 0)
      throw new TypeError("Invalid patch version");
    i[4] ? this.prerelease = i[4].split(".").map((s) => {
      if (/^[0-9]+$/.test(s)) {
        const r = +s;
        if (r >= 0 && r < Ki)
          return r;
      }
      return s;
    }) : this.prerelease = [], this.build = i[5] ? i[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(t) {
    if (Vi("SemVer.compare", this.version, this.options, t), !(t instanceof Fr)) {
      if (typeof t == "string" && t === this.version)
        return 0;
      t = new Fr(t, this.options);
    }
    return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return t instanceof Fr || (t = new Fr(t, this.options)), Nn(this.major, t.major) || Nn(this.minor, t.minor) || Nn(this.patch, t.patch);
  }
  comparePre(t) {
    if (t instanceof Fr || (t = new Fr(t, this.options)), this.prerelease.length && !t.prerelease.length)
      return -1;
    if (!this.prerelease.length && t.prerelease.length)
      return 1;
    if (!this.prerelease.length && !t.prerelease.length)
      return 0;
    let n = 0;
    do {
      const i = this.prerelease[n], s = t.prerelease[n];
      if (Vi("prerelease compare", n, i, s), i === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (i === void 0)
        return -1;
      if (i === s)
        continue;
      return Nn(i, s);
    } while (++n);
  }
  compareBuild(t) {
    t instanceof Fr || (t = new Fr(t, this.options));
    let n = 0;
    do {
      const i = this.build[n], s = t.build[n];
      if (Vi("prerelease compare", n, i, s), i === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (i === void 0)
        return -1;
      if (i === s)
        continue;
      return Nn(i, s);
    } while (++n);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(t, n, i) {
    switch (t) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", n, i);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", n, i);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", n, i), this.inc("pre", n, i);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", n, i), this.inc("pre", n, i);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const s = Number(i) ? 1 : 0;
        if (!n && i === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (this.prerelease.length === 0)
          this.prerelease = [s];
        else {
          let r = this.prerelease.length;
          for (; --r >= 0; )
            typeof this.prerelease[r] == "number" && (this.prerelease[r]++, r = -2);
          if (r === -1) {
            if (n === this.prerelease.join(".") && i === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(s);
          }
        }
        if (n) {
          let r = [n, s];
          i === !1 && (r = [n]), Nn(this.prerelease[0], n) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = r) : this.prerelease = r;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var or = J2;
const U0 = or, X2 = (e, t, n = !1) => {
  if (e instanceof U0)
    return e;
  try {
    return new U0(e, t);
  } catch (i) {
    if (!n)
      return null;
    throw i;
  }
};
var si = X2;
const Y2 = si, Q2 = (e, t) => {
  const n = Y2(e, t);
  return n ? n.version : null;
};
var em = Q2;
const tm = si, rm = (e, t) => {
  const n = tm(e.trim().replace(/^[=v]+/, ""), t);
  return n ? n.version : null;
};
var nm = rm;
const F0 = or, im = (e, t, n, i, s) => {
  typeof n == "string" && (s = i, i = n, n = void 0);
  try {
    return new F0(
      e instanceof F0 ? e.version : e,
      n
    ).inc(t, i, s).version;
  } catch {
    return null;
  }
};
var am = im;
const H0 = si, fm = (e, t) => {
  const n = H0(e, null, !0), i = H0(t, null, !0), s = n.compare(i);
  if (s === 0)
    return null;
  const r = s > 0, o = r ? n : i, u = r ? i : n, c = !!o.prerelease.length;
  if (!!u.prerelease.length && !c)
    return !u.patch && !u.minor ? "major" : o.patch ? "patch" : o.minor ? "minor" : "major";
  const f = c ? "pre" : "";
  return n.major !== i.major ? f + "major" : n.minor !== i.minor ? f + "minor" : n.patch !== i.patch ? f + "patch" : "prerelease";
};
var om = fm;
const sm = or, um = (e, t) => new sm(e, t).major;
var cm = um;
const hm = or, lm = (e, t) => new hm(e, t).minor;
var dm = lm;
const pm = or, vm = (e, t) => new pm(e, t).patch;
var bm = vm;
const ym = si, gm = (e, t) => {
  const n = ym(e, t);
  return n && n.prerelease.length ? n.prerelease : null;
};
var mm = gm;
const z0 = or, _m = (e, t, n) => new z0(e, n).compare(new z0(t, n));
var qr = _m;
const wm = qr, xm = (e, t, n) => wm(t, e, n);
var Em = xm;
const Sm = qr, Am = (e, t) => Sm(e, t, !0);
var Mm = Am;
const V0 = or, Rm = (e, t, n) => {
  const i = new V0(e, n), s = new V0(t, n);
  return i.compare(s) || i.compareBuild(s);
};
var Lc = Rm;
const Bm = Lc, Im = (e, t) => e.sort((n, i) => Bm(n, i, t));
var Tm = Im;
const Om = Lc, Pm = (e, t) => e.sort((n, i) => Om(i, n, t));
var Cm = Pm;
const Nm = qr, Lm = (e, t, n) => Nm(e, t, n) > 0;
var Da = Lm;
const km = qr, jm = (e, t, n) => km(e, t, n) < 0;
var kc = jm;
const qm = qr, Dm = (e, t, n) => qm(e, t, n) === 0;
var bv = Dm;
const $m = qr, Um = (e, t, n) => $m(e, t, n) !== 0;
var yv = Um;
const Fm = qr, Hm = (e, t, n) => Fm(e, t, n) >= 0;
var jc = Hm;
const zm = qr, Vm = (e, t, n) => zm(e, t, n) <= 0;
var qc = Vm;
const Km = bv, Zm = yv, Gm = Da, Wm = jc, Jm = kc, Xm = qc, Ym = (e, t, n, i) => {
  switch (t) {
    case "===":
      return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e === n;
    case "!==":
      return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e !== n;
    case "":
    case "=":
    case "==":
      return Km(e, n, i);
    case "!=":
      return Zm(e, n, i);
    case ">":
      return Gm(e, n, i);
    case ">=":
      return Wm(e, n, i);
    case "<":
      return Jm(e, n, i);
    case "<=":
      return Xm(e, n, i);
    default:
      throw new TypeError(`Invalid operator: ${t}`);
  }
};
var gv = Ym;
const Qm = or, e6 = si, { safeRe: Zi, t: Gi } = ki, t6 = (e, t) => {
  if (e instanceof Qm)
    return e;
  if (typeof e == "number" && (e = String(e)), typeof e != "string")
    return null;
  t = t || {};
  let n = null;
  if (!t.rtl)
    n = e.match(Zi[Gi.COERCE]);
  else {
    let i;
    for (; (i = Zi[Gi.COERCERTL].exec(e)) && (!n || n.index + n[0].length !== e.length); )
      (!n || i.index + i[0].length !== n.index + n[0].length) && (n = i), Zi[Gi.COERCERTL].lastIndex = i.index + i[1].length + i[2].length;
    Zi[Gi.COERCERTL].lastIndex = -1;
  }
  return n === null ? null : e6(`${n[2]}.${n[3] || "0"}.${n[4] || "0"}`, t);
};
var r6 = t6, Mf, K0;
function n6() {
  return K0 || (K0 = 1, Mf = function(e) {
    e.prototype[Symbol.iterator] = function* () {
      for (let t = this.head; t; t = t.next)
        yield t.value;
    };
  }), Mf;
}
var i6 = Ot;
Ot.Node = Bn;
Ot.create = Ot;
function Ot(e) {
  var t = this;
  if (t instanceof Ot || (t = new Ot()), t.tail = null, t.head = null, t.length = 0, e && typeof e.forEach == "function")
    e.forEach(function(s) {
      t.push(s);
    });
  else if (arguments.length > 0)
    for (var n = 0, i = arguments.length; n < i; n++)
      t.push(arguments[n]);
  return t;
}
Ot.prototype.removeNode = function(e) {
  if (e.list !== this)
    throw new Error("removing node which does not belong to this list");
  var t = e.next, n = e.prev;
  return t && (t.prev = n), n && (n.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = n), e.list.length--, e.next = null, e.prev = null, e.list = null, t;
};
Ot.prototype.unshiftNode = function(e) {
  if (e !== this.head) {
    e.list && e.list.removeNode(e);
    var t = this.head;
    e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;
  }
};
Ot.prototype.pushNode = function(e) {
  if (e !== this.tail) {
    e.list && e.list.removeNode(e);
    var t = this.tail;
    e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++;
  }
};
Ot.prototype.push = function() {
  for (var e = 0, t = arguments.length; e < t; e++)
    f6(this, arguments[e]);
  return this.length;
};
Ot.prototype.unshift = function() {
  for (var e = 0, t = arguments.length; e < t; e++)
    o6(this, arguments[e]);
  return this.length;
};
Ot.prototype.pop = function() {
  if (this.tail) {
    var e = this.tail.value;
    return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;
  }
};
Ot.prototype.shift = function() {
  if (this.head) {
    var e = this.head.value;
    return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;
  }
};
Ot.prototype.forEach = function(e, t) {
  t = t || this;
  for (var n = this.head, i = 0; n !== null; i++)
    e.call(t, n.value, i, this), n = n.next;
};
Ot.prototype.forEachReverse = function(e, t) {
  t = t || this;
  for (var n = this.tail, i = this.length - 1; n !== null; i--)
    e.call(t, n.value, i, this), n = n.prev;
};
Ot.prototype.get = function(e) {
  for (var t = 0, n = this.head; n !== null && t < e; t++)
    n = n.next;
  if (t === e && n !== null)
    return n.value;
};
Ot.prototype.getReverse = function(e) {
  for (var t = 0, n = this.tail; n !== null && t < e; t++)
    n = n.prev;
  if (t === e && n !== null)
    return n.value;
};
Ot.prototype.map = function(e, t) {
  t = t || this;
  for (var n = new Ot(), i = this.head; i !== null; )
    n.push(e.call(t, i.value, this)), i = i.next;
  return n;
};
Ot.prototype.mapReverse = function(e, t) {
  t = t || this;
  for (var n = new Ot(), i = this.tail; i !== null; )
    n.push(e.call(t, i.value, this)), i = i.prev;
  return n;
};
Ot.prototype.reduce = function(e, t) {
  var n, i = this.head;
  if (arguments.length > 1)
    n = t;
  else if (this.head)
    i = this.head.next, n = this.head.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var s = 0; i !== null; s++)
    n = e(n, i.value, s), i = i.next;
  return n;
};
Ot.prototype.reduceReverse = function(e, t) {
  var n, i = this.tail;
  if (arguments.length > 1)
    n = t;
  else if (this.tail)
    i = this.tail.prev, n = this.tail.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var s = this.length - 1; i !== null; s--)
    n = e(n, i.value, s), i = i.prev;
  return n;
};
Ot.prototype.toArray = function() {
  for (var e = new Array(this.length), t = 0, n = this.head; n !== null; t++)
    e[t] = n.value, n = n.next;
  return e;
};
Ot.prototype.toArrayReverse = function() {
  for (var e = new Array(this.length), t = 0, n = this.tail; n !== null; t++)
    e[t] = n.value, n = n.prev;
  return e;
};
Ot.prototype.slice = function(e, t) {
  t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
  var n = new Ot();
  if (t < e || t < 0)
    return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var i = 0, s = this.head; s !== null && i < e; i++)
    s = s.next;
  for (; s !== null && i < t; i++, s = s.next)
    n.push(s.value);
  return n;
};
Ot.prototype.sliceReverse = function(e, t) {
  t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
  var n = new Ot();
  if (t < e || t < 0)
    return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var i = this.length, s = this.tail; s !== null && i > t; i--)
    s = s.prev;
  for (; s !== null && i > e; i--, s = s.prev)
    n.push(s.value);
  return n;
};
Ot.prototype.splice = function(e, t, ...n) {
  e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
  for (var i = 0, s = this.head; s !== null && i < e; i++)
    s = s.next;
  for (var r = [], i = 0; s && i < t; i++)
    r.push(s.value), s = this.removeNode(s);
  s === null && (s = this.tail), s !== this.head && s !== this.tail && (s = s.prev);
  for (var i = 0; i < n.length; i++)
    s = a6(this, s, n[i]);
  return r;
};
Ot.prototype.reverse = function() {
  for (var e = this.head, t = this.tail, n = e; n !== null; n = n.prev) {
    var i = n.prev;
    n.prev = n.next, n.next = i;
  }
  return this.head = t, this.tail = e, this;
};
function a6(e, t, n) {
  var i = t === e.head ? new Bn(n, null, t, e) : new Bn(n, t, t.next, e);
  return i.next === null && (e.tail = i), i.prev === null && (e.head = i), e.length++, i;
}
function f6(e, t) {
  e.tail = new Bn(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++;
}
function o6(e, t) {
  e.head = new Bn(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++;
}
function Bn(e, t, n, i) {
  if (!(this instanceof Bn))
    return new Bn(e, t, n, i);
  this.list = i, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, n ? (n.prev = this, this.next = n) : this.next = null;
}
try {
  n6()(Ot);
} catch {
}
const s6 = i6, xn = Symbol("max"), en = Symbol("length"), Ln = Symbol("lengthCalculator"), _i = Symbol("allowStale"), An = Symbol("maxAge"), Yr = Symbol("dispose"), Z0 = Symbol("noDisposeOnSet"), Jt = Symbol("lruList"), Lr = Symbol("cache"), mv = Symbol("updateAgeOnGet"), Rf = () => 1;
class u6 {
  constructor(t) {
    if (typeof t == "number" && (t = { max: t }), t || (t = {}), t.max && (typeof t.max != "number" || t.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[xn] = t.max || 1 / 0;
    const n = t.length || Rf;
    if (this[Ln] = typeof n != "function" ? Rf : n, this[_i] = t.stale || !1, t.maxAge && typeof t.maxAge != "number")
      throw new TypeError("maxAge must be a number");
    this[An] = t.maxAge || 0, this[Yr] = t.dispose, this[Z0] = t.noDisposeOnSet || !1, this[mv] = t.updateAgeOnGet || !1, this.reset();
  }
  // resize the cache when the max changes.
  set max(t) {
    if (typeof t != "number" || t < 0)
      throw new TypeError("max must be a non-negative number");
    this[xn] = t || 1 / 0, di(this);
  }
  get max() {
    return this[xn];
  }
  set allowStale(t) {
    this[_i] = !!t;
  }
  get allowStale() {
    return this[_i];
  }
  set maxAge(t) {
    if (typeof t != "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[An] = t, di(this);
  }
  get maxAge() {
    return this[An];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(t) {
    typeof t != "function" && (t = Rf), t !== this[Ln] && (this[Ln] = t, this[en] = 0, this[Jt].forEach((n) => {
      n.length = this[Ln](n.value, n.key), this[en] += n.length;
    })), di(this);
  }
  get lengthCalculator() {
    return this[Ln];
  }
  get length() {
    return this[en];
  }
  get itemCount() {
    return this[Jt].length;
  }
  rforEach(t, n) {
    n = n || this;
    for (let i = this[Jt].tail; i !== null; ) {
      const s = i.prev;
      G0(this, t, i, n), i = s;
    }
  }
  forEach(t, n) {
    n = n || this;
    for (let i = this[Jt].head; i !== null; ) {
      const s = i.next;
      G0(this, t, i, n), i = s;
    }
  }
  keys() {
    return this[Jt].toArray().map((t) => t.key);
  }
  values() {
    return this[Jt].toArray().map((t) => t.value);
  }
  reset() {
    this[Yr] && this[Jt] && this[Jt].length && this[Jt].forEach((t) => this[Yr](t.key, t.value)), this[Lr] = /* @__PURE__ */ new Map(), this[Jt] = new s6(), this[en] = 0;
  }
  dump() {
    return this[Jt].map((t) => ma(this, t) ? !1 : {
      k: t.key,
      v: t.value,
      e: t.now + (t.maxAge || 0)
    }).toArray().filter((t) => t);
  }
  dumpLru() {
    return this[Jt];
  }
  set(t, n, i) {
    if (i = i || this[An], i && typeof i != "number")
      throw new TypeError("maxAge must be a number");
    const s = i ? Date.now() : 0, r = this[Ln](n, t);
    if (this[Lr].has(t)) {
      if (r > this[xn])
        return Zn(this, this[Lr].get(t)), !1;
      const c = this[Lr].get(t).value;
      return this[Yr] && (this[Z0] || this[Yr](t, c.value)), c.now = s, c.maxAge = i, c.value = n, this[en] += r - c.length, c.length = r, this.get(t), di(this), !0;
    }
    const o = new c6(t, n, r, s, i);
    return o.length > this[xn] ? (this[Yr] && this[Yr](t, n), !1) : (this[en] += o.length, this[Jt].unshift(o), this[Lr].set(t, this[Jt].head), di(this), !0);
  }
  has(t) {
    if (!this[Lr].has(t))
      return !1;
    const n = this[Lr].get(t).value;
    return !ma(this, n);
  }
  get(t) {
    return Bf(this, t, !0);
  }
  peek(t) {
    return Bf(this, t, !1);
  }
  pop() {
    const t = this[Jt].tail;
    return t ? (Zn(this, t), t.value) : null;
  }
  del(t) {
    Zn(this, this[Lr].get(t));
  }
  load(t) {
    this.reset();
    const n = Date.now();
    for (let i = t.length - 1; i >= 0; i--) {
      const s = t[i], r = s.e || 0;
      if (r === 0)
        this.set(s.k, s.v);
      else {
        const o = r - n;
        o > 0 && this.set(s.k, s.v, o);
      }
    }
  }
  prune() {
    this[Lr].forEach((t, n) => Bf(this, n, !1));
  }
}
const Bf = (e, t, n) => {
  const i = e[Lr].get(t);
  if (i) {
    const s = i.value;
    if (ma(e, s)) {
      if (Zn(e, i), !e[_i])
        return;
    } else
      n && (e[mv] && (i.value.now = Date.now()), e[Jt].unshiftNode(i));
    return s.value;
  }
}, ma = (e, t) => {
  if (!t || !t.maxAge && !e[An])
    return !1;
  const n = Date.now() - t.now;
  return t.maxAge ? n > t.maxAge : e[An] && n > e[An];
}, di = (e) => {
  if (e[en] > e[xn])
    for (let t = e[Jt].tail; e[en] > e[xn] && t !== null; ) {
      const n = t.prev;
      Zn(e, t), t = n;
    }
}, Zn = (e, t) => {
  if (t) {
    const n = t.value;
    e[Yr] && e[Yr](n.key, n.value), e[en] -= n.length, e[Lr].delete(n.key), e[Jt].removeNode(t);
  }
};
class c6 {
  constructor(t, n, i, s, r) {
    this.key = t, this.value = n, this.length = i, this.now = s, this.maxAge = r || 0;
  }
}
const G0 = (e, t, n, i) => {
  let s = n.value;
  ma(e, s) && (Zn(e, n), e[_i] || (s = void 0)), s && t.call(i, s.value, s.key, e);
};
var h6 = u6, If, W0;
function Dr() {
  if (W0)
    return If;
  W0 = 1;
  class e {
    constructor(a, l) {
      if (l = i(l), a instanceof e)
        return a.loose === !!l.loose && a.includePrerelease === !!l.includePrerelease ? a : new e(a.raw, l);
      if (a instanceof s)
        return this.raw = a.value, this.set = [[a]], this.format(), this;
      if (this.options = l, this.loose = !!l.loose, this.includePrerelease = !!l.includePrerelease, this.raw = a.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((_) => this.parseRange(_.trim())).filter((_) => _.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const _ = this.set[0];
        if (this.set = this.set.filter((x) => !E(x[0])), this.set.length === 0)
          this.set = [_];
        else if (this.set.length > 1) {
          for (const x of this.set)
            if (x.length === 1 && M(x[0])) {
              this.set = [x];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map((a) => a.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(a) {
      const _ = ((this.options.includePrerelease && v) | (this.options.loose && m)) + ":" + a, x = n.get(_);
      if (x)
        return x;
      const A = this.options.loose, S = A ? u[c.HYPHENRANGELOOSE] : u[c.HYPHENRANGE];
      a = a.replace(S, U(this.options.includePrerelease)), r("hyphen replace", a), a = a.replace(u[c.COMPARATORTRIM], h), r("comparator trim", a), a = a.replace(u[c.TILDETRIM], f), r("tilde trim", a), a = a.replace(u[c.CARETTRIM], b), r("caret trim", a);
      let g = a.split(" ").map((G) => I(G, this.options)).join(" ").split(/\s+/).map((G) => oe(G, this.options));
      A && (g = g.filter((G) => (r("loose invalid filter", G, this.options), !!G.match(u[c.COMPARATORLOOSE])))), r("range list", g);
      const w = /* @__PURE__ */ new Map(), d = g.map((G) => new s(G, this.options));
      for (const G of d) {
        if (E(G))
          return [G];
        w.set(G.value, G);
      }
      w.size > 1 && w.has("") && w.delete("");
      const R = [...w.values()];
      return n.set(_, R), R;
    }
    intersects(a, l) {
      if (!(a instanceof e))
        throw new TypeError("a Range is required");
      return this.set.some((_) => B(_, l) && a.set.some((x) => B(x, l) && _.every((A) => x.every((S) => A.intersects(S, l)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(a) {
      if (!a)
        return !1;
      if (typeof a == "string")
        try {
          a = new o(a, this.options);
        } catch {
          return !1;
        }
      for (let l = 0; l < this.set.length; l++)
        if (y(this.set[l], a, this.options))
          return !0;
      return !1;
    }
  }
  If = e;
  const t = h6, n = new t({ max: 1e3 }), i = Nc, s = $a(), r = qa, o = or, {
    safeRe: u,
    t: c,
    comparatorTrimReplace: h,
    tildeTrimReplace: f,
    caretTrimReplace: b
  } = ki, { FLAG_INCLUDE_PRERELEASE: v, FLAG_LOOSE: m } = ja, E = (p) => p.value === "<0.0.0-0", M = (p) => p.value === "", B = (p, a) => {
    let l = !0;
    const _ = p.slice();
    let x = _.pop();
    for (; l && _.length; )
      l = _.every((A) => x.intersects(A, a)), x = _.pop();
    return l;
  }, I = (p, a) => (r("comp", p, a), p = N(p, a), r("caret", p), p = k(p, a), r("tildes", p), p = D(p, a), r("xrange", p), p = te(p, a), r("stars", p), p), T = (p) => !p || p.toLowerCase() === "x" || p === "*", k = (p, a) => p.trim().split(/\s+/).map((l) => j(l, a)).join(" "), j = (p, a) => {
    const l = a.loose ? u[c.TILDELOOSE] : u[c.TILDE];
    return p.replace(l, (_, x, A, S, g) => {
      r("tilde", p, _, x, A, S, g);
      let w;
      return T(x) ? w = "" : T(A) ? w = `>=${x}.0.0 <${+x + 1}.0.0-0` : T(S) ? w = `>=${x}.${A}.0 <${x}.${+A + 1}.0-0` : g ? (r("replaceTilde pr", g), w = `>=${x}.${A}.${S}-${g} <${x}.${+A + 1}.0-0`) : w = `>=${x}.${A}.${S} <${x}.${+A + 1}.0-0`, r("tilde return", w), w;
    });
  }, N = (p, a) => p.trim().split(/\s+/).map((l) => q(l, a)).join(" "), q = (p, a) => {
    r("caret", p, a);
    const l = a.loose ? u[c.CARETLOOSE] : u[c.CARET], _ = a.includePrerelease ? "-0" : "";
    return p.replace(l, (x, A, S, g, w) => {
      r("caret", p, x, A, S, g, w);
      let d;
      return T(A) ? d = "" : T(S) ? d = `>=${A}.0.0${_} <${+A + 1}.0.0-0` : T(g) ? A === "0" ? d = `>=${A}.${S}.0${_} <${A}.${+S + 1}.0-0` : d = `>=${A}.${S}.0${_} <${+A + 1}.0.0-0` : w ? (r("replaceCaret pr", w), A === "0" ? S === "0" ? d = `>=${A}.${S}.${g}-${w} <${A}.${S}.${+g + 1}-0` : d = `>=${A}.${S}.${g}-${w} <${A}.${+S + 1}.0-0` : d = `>=${A}.${S}.${g}-${w} <${+A + 1}.0.0-0`) : (r("no pr"), A === "0" ? S === "0" ? d = `>=${A}.${S}.${g}${_} <${A}.${S}.${+g + 1}-0` : d = `>=${A}.${S}.${g}${_} <${A}.${+S + 1}.0-0` : d = `>=${A}.${S}.${g} <${+A + 1}.0.0-0`), r("caret return", d), d;
    });
  }, D = (p, a) => (r("replaceXRanges", p, a), p.split(/\s+/).map((l) => re(l, a)).join(" ")), re = (p, a) => {
    p = p.trim();
    const l = a.loose ? u[c.XRANGELOOSE] : u[c.XRANGE];
    return p.replace(l, (_, x, A, S, g, w) => {
      r("xRange", p, _, x, A, S, g, w);
      const d = T(A), R = d || T(S), G = R || T(g), fe = G;
      return x === "=" && fe && (x = ""), w = a.includePrerelease ? "-0" : "", d ? x === ">" || x === "<" ? _ = "<0.0.0-0" : _ = "*" : x && fe ? (R && (S = 0), g = 0, x === ">" ? (x = ">=", R ? (A = +A + 1, S = 0, g = 0) : (S = +S + 1, g = 0)) : x === "<=" && (x = "<", R ? A = +A + 1 : S = +S + 1), x === "<" && (w = "-0"), _ = `${x + A}.${S}.${g}${w}`) : R ? _ = `>=${A}.0.0${w} <${+A + 1}.0.0-0` : G && (_ = `>=${A}.${S}.0${w} <${A}.${+S + 1}.0-0`), r("xRange return", _), _;
    });
  }, te = (p, a) => (r("replaceStars", p, a), p.trim().replace(u[c.STAR], "")), oe = (p, a) => (r("replaceGTE0", p, a), p.trim().replace(u[a.includePrerelease ? c.GTE0PRE : c.GTE0], "")), U = (p) => (a, l, _, x, A, S, g, w, d, R, G, fe, z) => (T(_) ? l = "" : T(x) ? l = `>=${_}.0.0${p ? "-0" : ""}` : T(A) ? l = `>=${_}.${x}.0${p ? "-0" : ""}` : S ? l = `>=${l}` : l = `>=${l}${p ? "-0" : ""}`, T(d) ? w = "" : T(R) ? w = `<${+d + 1}.0.0-0` : T(G) ? w = `<${d}.${+R + 1}.0-0` : fe ? w = `<=${d}.${R}.${G}-${fe}` : p ? w = `<${d}.${R}.${+G + 1}-0` : w = `<=${w}`, `${l} ${w}`.trim()), y = (p, a, l) => {
    for (let _ = 0; _ < p.length; _++)
      if (!p[_].test(a))
        return !1;
    if (a.prerelease.length && !l.includePrerelease) {
      for (let _ = 0; _ < p.length; _++)
        if (r(p[_].semver), p[_].semver !== s.ANY && p[_].semver.prerelease.length > 0) {
          const x = p[_].semver;
          if (x.major === a.major && x.minor === a.minor && x.patch === a.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return If;
}
var Tf, J0;
function $a() {
  if (J0)
    return Tf;
  J0 = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(f, b) {
      if (b = n(b), f instanceof t) {
        if (f.loose === !!b.loose)
          return f;
        f = f.value;
      }
      f = f.trim().split(/\s+/).join(" "), o("comparator", f, b), this.options = b, this.loose = !!b.loose, this.parse(f), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, o("comp", this);
    }
    parse(f) {
      const b = this.options.loose ? i[s.COMPARATORLOOSE] : i[s.COMPARATOR], v = f.match(b);
      if (!v)
        throw new TypeError(`Invalid comparator: ${f}`);
      this.operator = v[1] !== void 0 ? v[1] : "", this.operator === "=" && (this.operator = ""), v[2] ? this.semver = new u(v[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(f) {
      if (o("Comparator.test", f, this.options.loose), this.semver === e || f === e)
        return !0;
      if (typeof f == "string")
        try {
          f = new u(f, this.options);
        } catch {
          return !1;
        }
      return r(f, this.operator, this.semver, this.options);
    }
    intersects(f, b) {
      if (!(f instanceof t))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new c(f.value, b).test(this.value) : f.operator === "" ? f.value === "" ? !0 : new c(this.value, b).test(f.semver) : (b = n(b), b.includePrerelease && (this.value === "<0.0.0-0" || f.value === "<0.0.0-0") || !b.includePrerelease && (this.value.startsWith("<0.0.0") || f.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && f.operator.startsWith(">") || this.operator.startsWith("<") && f.operator.startsWith("<") || this.semver.version === f.semver.version && this.operator.includes("=") && f.operator.includes("=") || r(this.semver, "<", f.semver, b) && this.operator.startsWith(">") && f.operator.startsWith("<") || r(this.semver, ">", f.semver, b) && this.operator.startsWith("<") && f.operator.startsWith(">")));
    }
  }
  Tf = t;
  const n = Nc, { safeRe: i, t: s } = ki, r = gv, o = qa, u = or, c = Dr();
  return Tf;
}
const l6 = Dr(), d6 = (e, t, n) => {
  try {
    t = new l6(t, n);
  } catch {
    return !1;
  }
  return t.test(e);
};
var Ua = d6;
const p6 = Dr(), v6 = (e, t) => new p6(e, t).set.map((n) => n.map((i) => i.value).join(" ").trim().split(" "));
var b6 = v6;
const y6 = or, g6 = Dr(), m6 = (e, t, n) => {
  let i = null, s = null, r = null;
  try {
    r = new g6(t, n);
  } catch {
    return null;
  }
  return e.forEach((o) => {
    r.test(o) && (!i || s.compare(o) === -1) && (i = o, s = new y6(i, n));
  }), i;
};
var _6 = m6;
const w6 = or, x6 = Dr(), E6 = (e, t, n) => {
  let i = null, s = null, r = null;
  try {
    r = new x6(t, n);
  } catch {
    return null;
  }
  return e.forEach((o) => {
    r.test(o) && (!i || s.compare(o) === 1) && (i = o, s = new w6(i, n));
  }), i;
};
var S6 = E6;
const Of = or, A6 = Dr(), X0 = Da, M6 = (e, t) => {
  e = new A6(e, t);
  let n = new Of("0.0.0");
  if (e.test(n) || (n = new Of("0.0.0-0"), e.test(n)))
    return n;
  n = null;
  for (let i = 0; i < e.set.length; ++i) {
    const s = e.set[i];
    let r = null;
    s.forEach((o) => {
      const u = new Of(o.semver.version);
      switch (o.operator) {
        case ">":
          u.prerelease.length === 0 ? u.patch++ : u.prerelease.push(0), u.raw = u.format();
        case "":
        case ">=":
          (!r || X0(u, r)) && (r = u);
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${o.operator}`);
      }
    }), r && (!n || X0(n, r)) && (n = r);
  }
  return n && e.test(n) ? n : null;
};
var R6 = M6;
const B6 = Dr(), I6 = (e, t) => {
  try {
    return new B6(e, t).range || "*";
  } catch {
    return null;
  }
};
var T6 = I6;
const O6 = or, _v = $a(), { ANY: P6 } = _v, C6 = Dr(), N6 = Ua, Y0 = Da, Q0 = kc, L6 = qc, k6 = jc, j6 = (e, t, n, i) => {
  e = new O6(e, i), t = new C6(t, i);
  let s, r, o, u, c;
  switch (n) {
    case ">":
      s = Y0, r = L6, o = Q0, u = ">", c = ">=";
      break;
    case "<":
      s = Q0, r = k6, o = Y0, u = "<", c = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (N6(e, t, i))
    return !1;
  for (let h = 0; h < t.set.length; ++h) {
    const f = t.set[h];
    let b = null, v = null;
    if (f.forEach((m) => {
      m.semver === P6 && (m = new _v(">=0.0.0")), b = b || m, v = v || m, s(m.semver, b.semver, i) ? b = m : o(m.semver, v.semver, i) && (v = m);
    }), b.operator === u || b.operator === c || (!v.operator || v.operator === u) && r(e, v.semver))
      return !1;
    if (v.operator === c && o(e, v.semver))
      return !1;
  }
  return !0;
};
var Dc = j6;
const q6 = Dc, D6 = (e, t, n) => q6(e, t, ">", n);
var $6 = D6;
const U6 = Dc, F6 = (e, t, n) => U6(e, t, "<", n);
var H6 = F6;
const eh = Dr(), z6 = (e, t, n) => (e = new eh(e, n), t = new eh(t, n), e.intersects(t, n));
var V6 = z6;
const K6 = Ua, Z6 = qr;
var G6 = (e, t, n) => {
  const i = [];
  let s = null, r = null;
  const o = e.sort((f, b) => Z6(f, b, n));
  for (const f of o)
    K6(f, t, n) ? (r = f, s || (s = f)) : (r && i.push([s, r]), r = null, s = null);
  s && i.push([s, null]);
  const u = [];
  for (const [f, b] of i)
    f === b ? u.push(f) : !b && f === o[0] ? u.push("*") : b ? f === o[0] ? u.push(`<=${b}`) : u.push(`${f} - ${b}`) : u.push(`>=${f}`);
  const c = u.join(" || "), h = typeof t.raw == "string" ? t.raw : String(t);
  return c.length < h.length ? c : t;
};
const th = Dr(), $c = $a(), { ANY: Pf } = $c, pi = Ua, Uc = qr, W6 = (e, t, n = {}) => {
  if (e === t)
    return !0;
  e = new th(e, n), t = new th(t, n);
  let i = !1;
  e:
    for (const s of e.set) {
      for (const r of t.set) {
        const o = X6(s, r, n);
        if (i = i || o !== null, o)
          continue e;
      }
      if (i)
        return !1;
    }
  return !0;
}, J6 = [new $c(">=0.0.0-0")], rh = [new $c(">=0.0.0")], X6 = (e, t, n) => {
  if (e === t)
    return !0;
  if (e.length === 1 && e[0].semver === Pf) {
    if (t.length === 1 && t[0].semver === Pf)
      return !0;
    n.includePrerelease ? e = J6 : e = rh;
  }
  if (t.length === 1 && t[0].semver === Pf) {
    if (n.includePrerelease)
      return !0;
    t = rh;
  }
  const i = /* @__PURE__ */ new Set();
  let s, r;
  for (const m of e)
    m.operator === ">" || m.operator === ">=" ? s = nh(s, m, n) : m.operator === "<" || m.operator === "<=" ? r = ih(r, m, n) : i.add(m.semver);
  if (i.size > 1)
    return null;
  let o;
  if (s && r) {
    if (o = Uc(s.semver, r.semver, n), o > 0)
      return null;
    if (o === 0 && (s.operator !== ">=" || r.operator !== "<="))
      return null;
  }
  for (const m of i) {
    if (s && !pi(m, String(s), n) || r && !pi(m, String(r), n))
      return null;
    for (const E of t)
      if (!pi(m, String(E), n))
        return !1;
    return !0;
  }
  let u, c, h, f, b = r && !n.includePrerelease && r.semver.prerelease.length ? r.semver : !1, v = s && !n.includePrerelease && s.semver.prerelease.length ? s.semver : !1;
  b && b.prerelease.length === 1 && r.operator === "<" && b.prerelease[0] === 0 && (b = !1);
  for (const m of t) {
    if (f = f || m.operator === ">" || m.operator === ">=", h = h || m.operator === "<" || m.operator === "<=", s) {
      if (v && m.semver.prerelease && m.semver.prerelease.length && m.semver.major === v.major && m.semver.minor === v.minor && m.semver.patch === v.patch && (v = !1), m.operator === ">" || m.operator === ">=") {
        if (u = nh(s, m, n), u === m && u !== s)
          return !1;
      } else if (s.operator === ">=" && !pi(s.semver, String(m), n))
        return !1;
    }
    if (r) {
      if (b && m.semver.prerelease && m.semver.prerelease.length && m.semver.major === b.major && m.semver.minor === b.minor && m.semver.patch === b.patch && (b = !1), m.operator === "<" || m.operator === "<=") {
        if (c = ih(r, m, n), c === m && c !== r)
          return !1;
      } else if (r.operator === "<=" && !pi(r.semver, String(m), n))
        return !1;
    }
    if (!m.operator && (r || s) && o !== 0)
      return !1;
  }
  return !(s && h && !r && o !== 0 || r && f && !s && o !== 0 || v || b);
}, nh = (e, t, n) => {
  if (!e)
    return t;
  const i = Uc(e.semver, t.semver, n);
  return i > 0 ? e : i < 0 || t.operator === ">" && e.operator === ">=" ? t : e;
}, ih = (e, t, n) => {
  if (!e)
    return t;
  const i = Uc(e.semver, t.semver, n);
  return i < 0 ? e : i > 0 || t.operator === "<" && e.operator === "<=" ? t : e;
};
var Y6 = W6;
const Cf = ki, ah = ja, Q6 = or, fh = vv, e3 = si, t3 = em, r3 = nm, n3 = am, i3 = om, a3 = cm, f3 = dm, o3 = bm, s3 = mm, u3 = qr, c3 = Em, h3 = Mm, l3 = Lc, d3 = Tm, p3 = Cm, v3 = Da, b3 = kc, y3 = bv, g3 = yv, m3 = jc, _3 = qc, w3 = gv, x3 = r6, E3 = $a(), S3 = Dr(), A3 = Ua, M3 = b6, R3 = _6, B3 = S6, I3 = R6, T3 = T6, O3 = Dc, P3 = $6, C3 = H6, N3 = V6, L3 = G6, k3 = Y6;
var j3 = {
  parse: e3,
  valid: t3,
  clean: r3,
  inc: n3,
  diff: i3,
  major: a3,
  minor: f3,
  patch: o3,
  prerelease: s3,
  compare: u3,
  rcompare: c3,
  compareLoose: h3,
  compareBuild: l3,
  sort: d3,
  rsort: p3,
  gt: v3,
  lt: b3,
  eq: y3,
  neq: g3,
  gte: m3,
  lte: _3,
  cmp: w3,
  coerce: x3,
  Comparator: E3,
  Range: S3,
  satisfies: A3,
  toComparators: M3,
  maxSatisfying: R3,
  minSatisfying: B3,
  minVersion: I3,
  validRange: T3,
  outside: O3,
  gtr: P3,
  ltr: C3,
  intersects: N3,
  simplifyRange: L3,
  subset: k3,
  SemVer: Q6,
  re: Cf.re,
  src: Cf.src,
  tokens: Cf.t,
  SEMVER_SPEC_VERSION: ah.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: ah.RELEASE_TYPES,
  compareIdentifiers: fh.compareIdentifiers,
  rcompareIdentifiers: fh.rcompareIdentifiers
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.satisfiesVersionRange = e.gtRange = e.gtVersion = e.assertIsSemVerRange = e.assertIsSemVerVersion = e.isValidSemVerRange = e.isValidSemVerVersion = e.VersionRangeStruct = e.VersionStruct = void 0;
  const t = j3, n = Pn, i = er;
  e.VersionStruct = (0, n.refine)((0, n.string)(), "Version", (b) => (0, t.valid)(b) === null ? `Expected SemVer version, got "${b}"` : !0), e.VersionRangeStruct = (0, n.refine)((0, n.string)(), "Version range", (b) => (0, t.validRange)(b) === null ? `Expected SemVer range, got "${b}"` : !0);
  function s(b) {
    return (0, n.is)(b, e.VersionStruct);
  }
  e.isValidSemVerVersion = s;
  function r(b) {
    return (0, n.is)(b, e.VersionRangeStruct);
  }
  e.isValidSemVerRange = r;
  function o(b) {
    (0, i.assertStruct)(b, e.VersionStruct);
  }
  e.assertIsSemVerVersion = o;
  function u(b) {
    (0, i.assertStruct)(b, e.VersionRangeStruct);
  }
  e.assertIsSemVerRange = u;
  function c(b, v) {
    return (0, t.gt)(b, v);
  }
  e.gtVersion = c;
  function h(b, v) {
    return (0, t.gtr)(b, v);
  }
  e.gtRange = h;
  function f(b, v) {
    return (0, t.satisfies)(b, v, {
      includePrerelease: !0
    });
  }
  e.satisfiesVersionRange = f;
})(lv);
(function(e) {
  var t = Ze && Ze.__createBinding || (Object.create ? function(i, s, r, o) {
    o === void 0 && (o = r);
    var u = Object.getOwnPropertyDescriptor(s, r);
    (!u || ("get" in u ? !s.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
      return s[r];
    } }), Object.defineProperty(i, o, u);
  } : function(i, s, r, o) {
    o === void 0 && (o = r), i[o] = s[r];
  }), n = Ze && Ze.__exportStar || function(i, s) {
    for (var r in i)
      r !== "default" && !Object.prototype.hasOwnProperty.call(s, r) && t(s, i, r);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), n(er, e), n(Ni, e), n(Tt, e), n(La, e), n(Vr, e), n(Jn, e), n(Li, e), n(uv, e), n(Xn, e), n(Cc, e), n(Kr, e), n(cv, e), n(hv, e), n(lv, e);
})(zp);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.createModuleLogger = e.projectLogger = void 0;
  const t = zp;
  Object.defineProperty(e, "createModuleLogger", { enumerable: !0, get: function() {
    return t.createModuleLogger;
  } }), e.projectLogger = t.createProjectLogger("eth-json-rpc-middleware");
})(ai);
var Xt = {}, Wi = {}, Nf, oh;
function q3() {
  if (oh)
    return Nf;
  oh = 1;
  var e, t, n = {
    '"': '"',
    "\\": "\\",
    "/": "/",
    b: "\b",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "	"
  }, i;
  function s(m) {
    throw {
      name: "SyntaxError",
      message: m,
      at: e,
      text: i
    };
  }
  function r(m) {
    return m && m !== t && s("Expected '" + m + "' instead of '" + t + "'"), t = i.charAt(e), e += 1, t;
  }
  function o() {
    var m, E = "";
    for (t === "-" && (E = "-", r("-")); t >= "0" && t <= "9"; )
      E += t, r();
    if (t === ".")
      for (E += "."; r() && t >= "0" && t <= "9"; )
        E += t;
    if (t === "e" || t === "E")
      for (E += t, r(), (t === "-" || t === "+") && (E += t, r()); t >= "0" && t <= "9"; )
        E += t, r();
    return m = Number(E), isFinite(m) || s("Bad number"), m;
  }
  function u() {
    var m, E, M = "", B;
    if (t === '"')
      for (; r(); ) {
        if (t === '"')
          return r(), M;
        if (t === "\\")
          if (r(), t === "u") {
            for (B = 0, E = 0; E < 4 && (m = parseInt(r(), 16), !!isFinite(m)); E += 1)
              B = B * 16 + m;
            M += String.fromCharCode(B);
          } else if (typeof n[t] == "string")
            M += n[t];
          else
            break;
        else
          M += t;
      }
    s("Bad string");
  }
  function c() {
    for (; t && t <= " "; )
      r();
  }
  function h() {
    switch (t) {
      case "t":
        return r("t"), r("r"), r("u"), r("e"), !0;
      case "f":
        return r("f"), r("a"), r("l"), r("s"), r("e"), !1;
      case "n":
        return r("n"), r("u"), r("l"), r("l"), null;
      default:
        s("Unexpected '" + t + "'");
    }
  }
  function f() {
    var m = [];
    if (t === "[") {
      if (r("["), c(), t === "]")
        return r("]"), m;
      for (; t; ) {
        if (m.push(v()), c(), t === "]")
          return r("]"), m;
        r(","), c();
      }
    }
    s("Bad array");
  }
  function b() {
    var m, E = {};
    if (t === "{") {
      if (r("{"), c(), t === "}")
        return r("}"), E;
      for (; t; ) {
        if (m = u(), c(), r(":"), Object.prototype.hasOwnProperty.call(E, m) && s('Duplicate key "' + m + '"'), E[m] = v(), c(), t === "}")
          return r("}"), E;
        r(","), c();
      }
    }
    s("Bad object");
  }
  function v() {
    switch (c(), t) {
      case "{":
        return b();
      case "[":
        return f();
      case '"':
        return u();
      case "-":
        return o();
      default:
        return t >= "0" && t <= "9" ? o() : h();
    }
  }
  return Nf = function(m, E) {
    var M;
    return i = m, e = 0, t = " ", M = v(), c(), t && s("Syntax error"), typeof E == "function" ? function B(I, T) {
      var k, j, N = I[T];
      if (N && typeof N == "object")
        for (k in v)
          Object.prototype.hasOwnProperty.call(N, k) && (j = B(N, k), typeof j > "u" ? delete N[k] : N[k] = j);
      return E.call(I, T, N);
    }({ "": M }, "") : M;
  }, Nf;
}
var Lf, sh;
function D3() {
  if (sh)
    return Lf;
  sh = 1;
  var e = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, t, n, i = {
    // table of character substitutions
    "\b": "\\b",
    "	": "\\t",
    "\n": "\\n",
    "\f": "\\f",
    "\r": "\\r",
    '"': '\\"',
    "\\": "\\\\"
  }, s;
  function r(u) {
    return e.lastIndex = 0, e.test(u) ? '"' + u.replace(e, function(c) {
      var h = i[c];
      return typeof h == "string" ? h : "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + u + '"';
  }
  function o(u, c) {
    var h, f, b, v, m = t, E, M = c[u];
    switch (M && typeof M == "object" && typeof M.toJSON == "function" && (M = M.toJSON(u)), typeof s == "function" && (M = s.call(c, u, M)), typeof M) {
      case "string":
        return r(M);
      case "number":
        return isFinite(M) ? String(M) : "null";
      case "boolean":
      case "null":
        return String(M);
      case "object":
        if (!M)
          return "null";
        if (t += n, E = [], Object.prototype.toString.apply(M) === "[object Array]") {
          for (v = M.length, h = 0; h < v; h += 1)
            E[h] = o(h, M) || "null";
          return b = E.length === 0 ? "[]" : t ? `[
` + t + E.join(`,
` + t) + `
` + m + "]" : "[" + E.join(",") + "]", t = m, b;
        }
        if (s && typeof s == "object")
          for (v = s.length, h = 0; h < v; h += 1)
            f = s[h], typeof f == "string" && (b = o(f, M), b && E.push(r(f) + (t ? ": " : ":") + b));
        else
          for (f in M)
            Object.prototype.hasOwnProperty.call(M, f) && (b = o(f, M), b && E.push(r(f) + (t ? ": " : ":") + b));
        return b = E.length === 0 ? "{}" : t ? `{
` + t + E.join(`,
` + t) + `
` + m + "}" : "{" + E.join(",") + "}", t = m, b;
    }
  }
  return Lf = function(u, c, h) {
    var f;
    if (t = "", n = "", typeof h == "number")
      for (f = 0; f < h; f += 1)
        n += " ";
    else
      typeof h == "string" && (n = h);
    if (s = c, c && typeof c != "function" && (typeof c != "object" || typeof c.length != "number"))
      throw new Error("JSON.stringify");
    return o("", { "": u });
  }, Lf;
}
var uh;
function $3() {
  return uh || (uh = 1, Wi.parse = q3(), Wi.stringify = D3()), Wi;
}
var Ji = typeof JSON < "u" ? JSON : $3(), U3 = Array.isArray || function(e) {
  return {}.toString.call(e) === "[object Array]";
}, F3 = Object.keys || function(e) {
  var t = Object.prototype.hasOwnProperty || function() {
    return !0;
  }, n = [];
  for (var i in e)
    t.call(e, i) && n.push(i);
  return n;
}, H3 = function(e, t) {
  t || (t = {}), typeof t == "function" && (t = { cmp: t });
  var n = t.space || "";
  typeof n == "number" && (n = Array(n + 1).join(" "));
  var i = typeof t.cycles == "boolean" ? t.cycles : !1, s = t.replacer || function(u, c) {
    return c;
  }, r = t.cmp && function(u) {
    return function(c) {
      return function(h, f) {
        var b = { key: h, value: c[h] }, v = { key: f, value: c[f] };
        return u(b, v);
      };
    };
  }(t.cmp), o = [];
  return function u(c, h, f, b) {
    var v = n ? `
` + new Array(b + 1).join(n) : "", m = n ? ": " : ":";
    if (f && f.toJSON && typeof f.toJSON == "function" && (f = f.toJSON()), f = s.call(c, h, f), f !== void 0) {
      if (typeof f != "object" || f === null)
        return Ji.stringify(f);
      if (U3(f)) {
        for (var I = [], E = 0; E < f.length; E++) {
          var M = u(f, E, f[E], b + 1) || Ji.stringify(null);
          I.push(v + n + M);
        }
        return "[" + I.join(",") + v + "]";
      }
      if (o.indexOf(f) !== -1) {
        if (i)
          return Ji.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      } else
        o.push(f);
      for (var B = F3(f).sort(r && r(f)), I = [], E = 0; E < B.length; E++) {
        var h = B[E], T = u(f, h, f[h], b + 1);
        if (T) {
          var k = Ji.stringify(h) + m + T;
          I.push(v + n + k);
        }
      }
      return o.splice(o.indexOf(f), 1), "{" + I.join(",") + v + "}";
    }
  }({ "": e }, "", e, 0);
}, z3 = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Xt, "__esModule", { value: !0 });
Xt.cacheTypeForPayload = Xt.blockTagParamIndex = Xt.paramsWithoutBlockTag = Xt.blockTagForPayload = Xt.canCache = Xt.cacheIdentifierForPayload = void 0;
const V3 = z3(H3);
function K3(e, t) {
  var n;
  const i = t ? xv(e) : (n = e.params) !== null && n !== void 0 ? n : [];
  return wv(e) ? `${e.method}:${V3.default(i)}` : null;
}
Xt.cacheIdentifierForPayload = K3;
function wv(e) {
  return Ev(e) !== "never";
}
Xt.canCache = wv;
function Z3(e) {
  if (!e.params)
    return;
  const t = Fc(e);
  if (!(t === void 0 || t >= e.params.length))
    return e.params[t];
}
Xt.blockTagForPayload = Z3;
function xv(e) {
  if (!e.params)
    return [];
  const t = Fc(e);
  return t === void 0 || t >= e.params.length ? e.params : e.method === "eth_getBlockByNumber" ? e.params.slice(1) : e.params.slice(0, t);
}
Xt.paramsWithoutBlockTag = xv;
function Fc(e) {
  switch (e.method) {
    case "eth_getStorageAt":
      return 2;
    case "eth_getBalance":
    case "eth_getCode":
    case "eth_getTransactionCount":
    case "eth_call":
      return 1;
    case "eth_getBlockByNumber":
      return 0;
    default:
      return;
  }
}
Xt.blockTagParamIndex = Fc;
function Ev(e) {
  switch (e.method) {
    case "web3_clientVersion":
    case "web3_sha3":
    case "eth_protocolVersion":
    case "eth_getBlockTransactionCountByHash":
    case "eth_getUncleCountByBlockHash":
    case "eth_getCode":
    case "eth_getBlockByHash":
    case "eth_getTransactionByHash":
    case "eth_getTransactionByBlockHashAndIndex":
    case "eth_getTransactionReceipt":
    case "eth_getUncleByBlockHashAndIndex":
    case "eth_getCompilers":
    case "eth_compileLLL":
    case "eth_compileSolidity":
    case "eth_compileSerpent":
    case "shh_version":
    case "test_permaCache":
      return "perma";
    case "eth_getBlockByNumber":
    case "eth_getBlockTransactionCountByNumber":
    case "eth_getUncleCountByBlockNumber":
    case "eth_getTransactionByBlockNumberAndIndex":
    case "eth_getUncleByBlockNumberAndIndex":
    case "test_forkCache":
      return "fork";
    case "eth_gasPrice":
    case "eth_blockNumber":
    case "eth_getBalance":
    case "eth_getStorageAt":
    case "eth_getTransactionCount":
    case "eth_call":
    case "eth_estimateGas":
    case "eth_getFilterLogs":
    case "eth_getLogs":
    case "test_blockCache":
      return "block";
    default:
      return "never";
  }
}
Xt.cacheTypeForPayload = Ev;
Object.defineProperty(Ca, "__esModule", { value: !0 });
Ca.createBlockCacheMiddleware = void 0;
const G3 = pr, ch = ai, Fn = Xt, kn = ch.createModuleLogger(ch.projectLogger, "block-cache"), W3 = [void 0, null, "<nil>"];
class J3 {
  constructor() {
    this.cache = {};
  }
  getBlockCacheForPayload(t, n) {
    const i = Number.parseInt(n, 16);
    let s = this.cache[i];
    if (!s) {
      const r = {};
      this.cache[i] = r, s = r;
    }
    return s;
  }
  async get(t, n) {
    const i = this.getBlockCacheForPayload(t, n), s = Fn.cacheIdentifierForPayload(t, !0);
    return s ? i[s] : void 0;
  }
  async set(t, n, i) {
    if (!this.canCacheResult(t, i))
      return;
    const r = Fn.cacheIdentifierForPayload(t, !0);
    if (!r)
      return;
    const o = this.getBlockCacheForPayload(t, n);
    o[r] = i;
  }
  canCacheRequest(t) {
    return !(!Fn.canCache(t) || Fn.blockTagForPayload(t) === "pending");
  }
  canCacheResult(t, n) {
    return !(W3.includes(n) || t.method && ["eth_getTransactionByHash", "eth_getTransactionReceipt"].includes(t.method) && (!n || !n.blockHash || n.blockHash === "0x0000000000000000000000000000000000000000000000000000000000000000"));
  }
  // removes all block caches with block number lower than `oldBlockHex`
  clearBefore(t) {
    const n = Number.parseInt(t, 16);
    Object.keys(this.cache).map(Number).filter((i) => i < n).forEach((i) => delete this.cache[i]);
  }
}
function X3({ blockTracker: e } = {}) {
  if (!e)
    throw new Error("createBlockCacheMiddleware - No PollingBlockTracker specified");
  const t = new J3(), n = {
    perma: t,
    block: t,
    fork: t
  };
  return G3.createAsyncMiddleware(async (i, s, r) => {
    if (i.skipCache)
      return r();
    const o = Fn.cacheTypeForPayload(i), u = n[o];
    if (!u || !u.canCacheRequest(i))
      return r();
    let c = Fn.blockTagForPayload(i);
    c || (c = "latest"), kn("blockTag = %o, req = %o", c, i);
    let h;
    if (c === "earliest")
      h = "0x00";
    else if (c === "latest") {
      kn("Fetching latest block number to determine cache key");
      const b = await e.getLatestBlock();
      kn("Clearing values stored under block numbers before %o", b), t.clearBefore(b), h = b;
    } else
      h = c;
    const f = await u.get(i, h);
    f === void 0 ? (kn("No cache stored under block number %o, carrying request forward", h), await r(), kn("Populating cache with", s), await u.set(i, h, s.result)) : (kn("Cache hit, reusing cache result stored under block number %o", h), s.result = f);
  });
}
Ca.createBlockCacheMiddleware = X3;
var Fa = {};
Object.defineProperty(Fa, "__esModule", { value: !0 });
Fa.createBlockRefRewriteMiddleware = void 0;
const Y3 = pr, Q3 = Xt;
function e_({ blockTracker: e } = {}) {
  if (!e)
    throw Error('BlockRefRewriteMiddleware - mandatory "blockTracker" option is missing.');
  return Y3.createAsyncMiddleware(async (t, n, i) => {
    var s;
    const r = Q3.blockTagParamIndex(t);
    if (r === void 0)
      return i();
    let o = (s = t.params) === null || s === void 0 ? void 0 : s[r];
    if (o === void 0 && (o = "latest"), o !== "latest")
      return i();
    const u = await e.getLatestBlock();
    return t.params && (t.params[r] = u), i();
  });
}
Fa.createBlockRefRewriteMiddleware = e_;
var Ha = {}, Sv = { exports: {} };
(function(e) {
  var t = function() {
    function n(v, m) {
      return m != null && v instanceof m;
    }
    var i;
    try {
      i = Map;
    } catch {
      i = function() {
      };
    }
    var s;
    try {
      s = Set;
    } catch {
      s = function() {
      };
    }
    var r;
    try {
      r = Promise;
    } catch {
      r = function() {
      };
    }
    function o(v, m, E, M, B) {
      typeof m == "object" && (E = m.depth, M = m.prototype, B = m.includeNonEnumerable, m = m.circular);
      var I = [], T = [], k = typeof Buffer < "u";
      typeof m > "u" && (m = !0), typeof E > "u" && (E = 1 / 0);
      function j(N, q) {
        if (N === null)
          return null;
        if (q === 0)
          return N;
        var D, re;
        if (typeof N != "object")
          return N;
        if (n(N, i))
          D = new i();
        else if (n(N, s))
          D = new s();
        else if (n(N, r))
          D = new r(function(x, A) {
            N.then(function(S) {
              x(j(S, q - 1));
            }, function(S) {
              A(j(S, q - 1));
            });
          });
        else if (o.__isArray(N))
          D = [];
        else if (o.__isRegExp(N))
          D = new RegExp(N.source, b(N)), N.lastIndex && (D.lastIndex = N.lastIndex);
        else if (o.__isDate(N))
          D = new Date(N.getTime());
        else {
          if (k && Buffer.isBuffer(N))
            return Buffer.allocUnsafe ? D = Buffer.allocUnsafe(N.length) : D = new Buffer(N.length), N.copy(D), D;
          n(N, Error) ? D = Object.create(N) : typeof M > "u" ? (re = Object.getPrototypeOf(N), D = Object.create(re)) : (D = Object.create(M), re = M);
        }
        if (m) {
          var te = I.indexOf(N);
          if (te != -1)
            return T[te];
          I.push(N), T.push(D);
        }
        n(N, i) && N.forEach(function(x, A) {
          var S = j(A, q - 1), g = j(x, q - 1);
          D.set(S, g);
        }), n(N, s) && N.forEach(function(x) {
          var A = j(x, q - 1);
          D.add(A);
        });
        for (var oe in N) {
          var U;
          re && (U = Object.getOwnPropertyDescriptor(re, oe)), !(U && U.set == null) && (D[oe] = j(N[oe], q - 1));
        }
        if (Object.getOwnPropertySymbols)
          for (var y = Object.getOwnPropertySymbols(N), oe = 0; oe < y.length; oe++) {
            var p = y[oe], a = Object.getOwnPropertyDescriptor(N, p);
            a && !a.enumerable && !B || (D[p] = j(N[p], q - 1), a.enumerable || Object.defineProperty(D, p, {
              enumerable: !1
            }));
          }
        if (B)
          for (var l = Object.getOwnPropertyNames(N), oe = 0; oe < l.length; oe++) {
            var _ = l[oe], a = Object.getOwnPropertyDescriptor(N, _);
            a && a.enumerable || (D[_] = j(N[_], q - 1), Object.defineProperty(D, _, {
              enumerable: !1
            }));
          }
        return D;
      }
      return j(v, E);
    }
    o.clonePrototype = function(m) {
      if (m === null)
        return null;
      var E = function() {
      };
      return E.prototype = m, new E();
    };
    function u(v) {
      return Object.prototype.toString.call(v);
    }
    o.__objToStr = u;
    function c(v) {
      return typeof v == "object" && u(v) === "[object Date]";
    }
    o.__isDate = c;
    function h(v) {
      return typeof v == "object" && u(v) === "[object Array]";
    }
    o.__isArray = h;
    function f(v) {
      return typeof v == "object" && u(v) === "[object RegExp]";
    }
    o.__isRegExp = f;
    function b(v) {
      var m = "";
      return v.global && (m += "g"), v.ignoreCase && (m += "i"), v.multiline && (m += "m"), m;
    }
    return o.__getRegExpFlags = b, o;
  }();
  e.exports && (e.exports = t);
})(Sv);
var Hc = Sv.exports;
const hh = (e, t) => function() {
  const n = t.promiseModule, i = new Array(arguments.length);
  for (let s = 0; s < arguments.length; s++)
    i[s] = arguments[s];
  return new n((s, r) => {
    t.errorFirst ? i.push(function(o, u) {
      if (t.multiArgs) {
        const c = new Array(arguments.length - 1);
        for (let h = 1; h < arguments.length; h++)
          c[h - 1] = arguments[h];
        o ? (c.unshift(o), r(c)) : s(c);
      } else
        o ? r(o) : s(u);
    }) : i.push(function(o) {
      if (t.multiArgs) {
        const u = new Array(arguments.length - 1);
        for (let c = 0; c < arguments.length; c++)
          u[c] = arguments[c];
        s(u);
      } else
        s(o);
    }), e.apply(this, i);
  });
};
var Av = (e, t) => {
  t = Object.assign({
    exclude: [/.+(Sync|Stream)$/],
    errorFirst: !0,
    promiseModule: Promise
  }, t);
  const n = (s) => {
    const r = (o) => typeof o == "string" ? s === o : o.test(s);
    return t.include ? t.include.some(r) : !t.exclude.some(r);
  };
  let i;
  typeof e == "function" ? i = function() {
    return t.excludeMain ? e.apply(this, arguments) : hh(e, t).apply(this, arguments);
  } : i = Object.create(Object.getPrototypeOf(e));
  for (const s in e) {
    const r = e[s];
    i[s] = typeof r == "function" && n(s) ? hh(r, t) : r;
  }
  return i;
}, Mv = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Ha, "__esModule", { value: !0 });
Ha.createBlockRefMiddleware = void 0;
const t_ = pr, r_ = Mv(Hc), n_ = Mv(Av), lh = ai, i_ = Xt, kf = lh.createModuleLogger(lh.projectLogger, "block-ref");
function a_({ provider: e, blockTracker: t } = {}) {
  if (!e)
    throw Error('BlockRefMiddleware - mandatory "provider" option is missing.');
  if (!t)
    throw Error('BlockRefMiddleware - mandatory "blockTracker" option is missing.');
  return t_.createAsyncMiddleware(async (n, i, s) => {
    var r, o;
    const u = i_.blockTagParamIndex(n);
    if (u === void 0)
      return s();
    if (((o = (r = n.params) === null || r === void 0 ? void 0 : r[u]) !== null && o !== void 0 ? o : "latest") !== "latest")
      return kf('blockRef is not "latest", carrying request forward'), s();
    const h = await t.getLatestBlock();
    kf(`blockRef is "latest", setting param ${u} to latest block ${h}`);
    const f = r_.default(n);
    f.params && (f.params[u] = h), kf("Performing another request %o", f);
    const b = await n_.default(e.sendAsync).call(e, f);
    i.result = b.result, i.error = b.error;
  });
}
Ha.createBlockRefMiddleware = a_;
var za = {};
Object.defineProperty(za, "__esModule", { value: !0 });
za.createBlockTrackerInspectorMiddleware = void 0;
const f_ = pr, dh = ai, ph = dh.createModuleLogger(dh.projectLogger, "block-tracker-inspector"), o_ = [
  "eth_getTransactionByHash",
  "eth_getTransactionReceipt"
];
function s_({ blockTracker: e }) {
  return f_.createAsyncMiddleware(async (t, n, i) => {
    var s;
    if (!o_.includes(t.method))
      return i();
    if (await i(), !!(!((s = n.result) === null || s === void 0) && s.blockNumber) && (ph("res.result.blockNumber exists, proceeding. res = %o", n), typeof n.result.blockNumber == "string")) {
      const r = Number.parseInt(n.result.blockNumber, 16), o = Number.parseInt(e.getCurrentBlock(), 16);
      r > o && (ph("blockNumber from response is greater than current block number, refreshing current block number"), await e.checkForLatestBlock());
    }
  });
}
za.createBlockTrackerInspectorMiddleware = s_;
var Yn = {};
const u_ = {}, c_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: u_
}, Symbol.toStringTag, { value: "Module" })), Rv = /* @__PURE__ */ xp(c_);
Object.defineProperty(Yn, "__esModule", { value: !0 });
Yn.createFetchConfigFromReq = Yn.createFetchMiddleware = void 0;
const h_ = pr, Ai = Zt, l_ = Ze.fetch || Rv, d_ = Ze.btoa || Rv, p_ = [
  // ignore server overload errors
  "Gateway timeout",
  "ETIMEDOUT",
  // ignore server sent html error pages
  // or truncated json responses
  "failed to parse response body",
  // ignore errors where http req failed to establish
  "Failed to fetch"
];
function v_({ rpcUrl: e, originHttpHeaderKey: t }) {
  return h_.createAsyncMiddleware(async (n, i, s) => {
    const { fetchUrl: r, fetchParams: o } = Bv({
      req: n,
      rpcUrl: e,
      originHttpHeaderKey: t
    }), u = 5, c = 1e3;
    for (let h = 0; h < u; h++) {
      try {
        const f = await l_(r, o);
        b_(f);
        const b = await f.text();
        let v;
        try {
          v = JSON.parse(b);
        } catch {
          throw new Error(`FetchMiddleware - failed to parse response body: "${b}"`);
        }
        const m = y_(f, v);
        i.result = m;
        return;
      } catch (f) {
        const b = f.toString();
        if (!p_.some((m) => b.includes(m)))
          throw f;
      }
      await w_(c);
    }
  });
}
Yn.createFetchMiddleware = v_;
function b_(e) {
  switch (e.status) {
    case 405:
      throw Ai.ethErrors.rpc.methodNotFound();
    case 418:
      throw m_();
    case 503:
    case 504:
      throw __();
  }
}
function y_(e, t) {
  if (e.status !== 200)
    throw Ai.ethErrors.rpc.internal({
      message: `Non-200 status code: '${e.status}'`,
      data: t
    });
  if (t.error)
    throw Ai.ethErrors.rpc.internal({
      data: t.error
    });
  return t.result;
}
function Bv({ req: e, rpcUrl: t, originHttpHeaderKey: n }) {
  const i = new URL(t), s = g_(i), r = {
    id: e.id,
    jsonrpc: e.jsonrpc,
    method: e.method,
    params: e.params
  }, o = e.origin, u = JSON.stringify(r), c = {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    body: u
  };
  if (i.username && i.password) {
    const h = `${i.username}:${i.password}`, f = d_(h);
    c.headers.Authorization = `Basic ${f}`;
  }
  return n && o && (c.headers[n] = o), { fetchUrl: s, fetchParams: c };
}
Yn.createFetchConfigFromReq = Bv;
function g_(e) {
  let t = "";
  return t += e.protocol, t += `//${e.hostname}`, e.port && (t += `:${e.port}`), t += `${e.pathname}`, t += `${e.search}`, t;
}
function m_() {
  return Ai.ethErrors.rpc.internal({ message: "Request is being rate limited." });
}
function __() {
  let e = "Gateway timeout. The request took too long to process. ";
  return e += "This can happen when querying logs over too wide a block range.", Ai.ethErrors.rpc.internal({ message: e });
}
function w_(e) {
  return new Promise((t) => setTimeout(t, e));
}
var Va = {}, x_ = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Va, "__esModule", { value: !0 });
Va.createInflightCacheMiddleware = void 0;
const vh = x_(Hc), E_ = pr, bh = ai, S_ = Xt, Xi = bh.createModuleLogger(bh.projectLogger, "inflight-cache");
function A_() {
  const e = {};
  return E_.createAsyncMiddleware(async (i, s, r) => {
    if (i.skipCache)
      return r();
    const o = S_.cacheIdentifierForPayload(i);
    if (!o)
      return Xi("Request is not cacheable, proceeding. req = %o", i), r();
    let u = e[o];
    if (u) {
      Xi("Running %i handler(s) for request %o", u.length, i), await t(s, u);
      return;
    }
    u = [], e[o] = u, Xi("Carrying original request forward %o", i), await r(), delete e[o], Xi("Running %i collected handler(s) for request %o", u.length, i), n(s, u);
  });
  function t(i, s) {
    const { resolve: r, promise: o } = M_();
    return s.push((u) => {
      i.result = vh.default(u.result), i.error = vh.default(u.error), r();
    }), o;
  }
  function n(i, s) {
    setTimeout(() => {
      s.forEach((r) => {
        try {
          r(i);
        } catch (o) {
          console.error(o);
        }
      });
    });
  }
}
Va.createInflightCacheMiddleware = A_;
function M_() {
  let e;
  const t = new Promise((n) => {
    e = n;
  });
  return { resolve: e, promise: t };
}
var Qn = {};
Object.defineProperty(Qn, "__esModule", { value: !0 });
Qn.ethersProviderAsMiddleware = Qn.providerAsMiddleware = void 0;
function R_(e) {
  return (t, n, i, s) => {
    e.sendAsync(t, (r, o) => r instanceof Error ? s(r) : (Object.assign(n, o), s()));
  };
}
Qn.providerAsMiddleware = R_;
function B_(e) {
  return (t, n, i, s) => {
    e.send(t, (r, o) => r ? s(r) : (Object.assign(n, o), s()));
  };
}
Qn.ethersProviderAsMiddleware = B_;
var ji = {}, I_ = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ji, "__esModule", { value: !0 });
ji.providerFromEngine = void 0;
const T_ = I_(Ia);
function O_(e) {
  const t = new T_.default();
  return t.sendAsync = (n, i) => {
    e.handle(n, i);
  }, t.send = (n, i) => {
    if (typeof i != "function")
      throw new Error('Must provide callback to "send" method.');
    e.handle(n, i);
  }, e.on && e.on("notification", (n) => {
    t.emit("data", null, n);
  }), t;
}
ji.providerFromEngine = O_;
var Ka = {};
Object.defineProperty(Ka, "__esModule", { value: !0 });
Ka.providerFromMiddleware = void 0;
const P_ = pr, C_ = ji;
function N_(e) {
  const t = new P_.JsonRpcEngine();
  return t.push(e), C_.providerFromEngine(t);
}
Ka.providerFromMiddleware = N_;
var Za = {}, Iv = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Za, "__esModule", { value: !0 });
Za.createRetryOnEmptyMiddleware = void 0;
const L_ = Iv(Hc), k_ = pr, j_ = Iv(Av), yh = ai, q_ = Xt, En = yh.createModuleLogger(yh.projectLogger, "retry-on-empty"), D_ = [
  void 0,
  null,
  "<nil>"
];
function $_({ provider: e, blockTracker: t } = {}) {
  if (!e)
    throw Error('RetryOnEmptyMiddleware - mandatory "provider" option is missing.');
  if (!t)
    throw Error('RetryOnEmptyMiddleware - mandatory "blockTracker" option is missing.');
  return k_.createAsyncMiddleware(async (n, i, s) => {
    var r;
    const o = q_.blockTagParamIndex(n);
    if (o === void 0)
      return s();
    let u = (r = n.params) === null || r === void 0 ? void 0 : r[o];
    if (u === void 0 && (u = "latest"), ["latest", "pending"].includes(u))
      return s();
    const c = Number.parseInt(u.slice(2), 16);
    if (Number.isNaN(c))
      return s();
    const h = await t.getLatestBlock(), f = Number.parseInt(h.slice(2), 16);
    if (c > f)
      return En("Requested block number %o is higher than latest block number %o, falling through to original request", c, f), s();
    En("Requested block number %o is not higher than latest block number %o, trying request until non-empty response is received", c, f);
    const b = L_.default(n), v = await U_(10, async () => {
      En("Performing request %o", b);
      const m = await j_.default(e.sendAsync).call(e, b);
      if (En("Response is %o", m), D_.includes(m.result))
        throw new Error(`RetryOnEmptyMiddleware - empty response "${JSON.stringify(m)}" for request "${JSON.stringify(b)}"`);
      return m;
    });
    En("Copying result %o and error %o", v.result, v.error), i.result = v.result, i.error = v.error;
  });
}
Za.createRetryOnEmptyMiddleware = $_;
async function U_(e, t) {
  for (let n = 0; n < e; n++)
    try {
      return await t();
    } catch {
      En("(call %i) Request failed, waiting 1s to retry again...", n + 1), await F_(1e3);
    }
  throw En("Retries exhausted"), new Error("RetryOnEmptyMiddleware - retries exhausted");
}
function F_(e) {
  return new Promise((t) => setTimeout(t, e));
}
var Ga = {}, Tv = {}, ln = {}, qi = {}, Wa = {}, dr = {}, Ja = {};
Ja.byteLength = V_;
Ja.toByteArray = Z_;
Ja.fromByteArray = J_;
var zr = [], xr = [], H_ = typeof Uint8Array < "u" ? Uint8Array : Array, jf = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var jn = 0, z_ = jf.length; jn < z_; ++jn)
  zr[jn] = jf[jn], xr[jf.charCodeAt(jn)] = jn;
xr["-".charCodeAt(0)] = 62;
xr["_".charCodeAt(0)] = 63;
function Ov(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = e.indexOf("=");
  n === -1 && (n = t);
  var i = n === t ? 0 : 4 - n % 4;
  return [n, i];
}
function V_(e) {
  var t = Ov(e), n = t[0], i = t[1];
  return (n + i) * 3 / 4 - i;
}
function K_(e, t, n) {
  return (t + n) * 3 / 4 - n;
}
function Z_(e) {
  var t, n = Ov(e), i = n[0], s = n[1], r = new H_(K_(e, i, s)), o = 0, u = s > 0 ? i - 4 : i, c;
  for (c = 0; c < u; c += 4)
    t = xr[e.charCodeAt(c)] << 18 | xr[e.charCodeAt(c + 1)] << 12 | xr[e.charCodeAt(c + 2)] << 6 | xr[e.charCodeAt(c + 3)], r[o++] = t >> 16 & 255, r[o++] = t >> 8 & 255, r[o++] = t & 255;
  return s === 2 && (t = xr[e.charCodeAt(c)] << 2 | xr[e.charCodeAt(c + 1)] >> 4, r[o++] = t & 255), s === 1 && (t = xr[e.charCodeAt(c)] << 10 | xr[e.charCodeAt(c + 1)] << 4 | xr[e.charCodeAt(c + 2)] >> 2, r[o++] = t >> 8 & 255, r[o++] = t & 255), r;
}
function G_(e) {
  return zr[e >> 18 & 63] + zr[e >> 12 & 63] + zr[e >> 6 & 63] + zr[e & 63];
}
function W_(e, t, n) {
  for (var i, s = [], r = t; r < n; r += 3)
    i = (e[r] << 16 & 16711680) + (e[r + 1] << 8 & 65280) + (e[r + 2] & 255), s.push(G_(i));
  return s.join("");
}
function J_(e) {
  for (var t, n = e.length, i = n % 3, s = [], r = 16383, o = 0, u = n - i; o < u; o += r)
    s.push(W_(e, o, o + r > u ? u : o + r));
  return i === 1 ? (t = e[n - 1], s.push(
    zr[t >> 2] + zr[t << 4 & 63] + "=="
  )) : i === 2 && (t = (e[n - 2] << 8) + e[n - 1], s.push(
    zr[t >> 10] + zr[t >> 4 & 63] + zr[t << 2 & 63] + "="
  )), s.join("");
}
var zc = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
zc.read = function(e, t, n, i, s) {
  var r, o, u = s * 8 - i - 1, c = (1 << u) - 1, h = c >> 1, f = -7, b = n ? s - 1 : 0, v = n ? -1 : 1, m = e[t + b];
  for (b += v, r = m & (1 << -f) - 1, m >>= -f, f += u; f > 0; r = r * 256 + e[t + b], b += v, f -= 8)
    ;
  for (o = r & (1 << -f) - 1, r >>= -f, f += i; f > 0; o = o * 256 + e[t + b], b += v, f -= 8)
    ;
  if (r === 0)
    r = 1 - h;
  else {
    if (r === c)
      return o ? NaN : (m ? -1 : 1) * (1 / 0);
    o = o + Math.pow(2, i), r = r - h;
  }
  return (m ? -1 : 1) * o * Math.pow(2, r - i);
};
zc.write = function(e, t, n, i, s, r) {
  var o, u, c, h = r * 8 - s - 1, f = (1 << h) - 1, b = f >> 1, v = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, m = i ? 0 : r - 1, E = i ? 1 : -1, M = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (u = isNaN(t) ? 1 : 0, o = f) : (o = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -o)) < 1 && (o--, c *= 2), o + b >= 1 ? t += v / c : t += v * Math.pow(2, 1 - b), t * c >= 2 && (o++, c /= 2), o + b >= f ? (u = 0, o = f) : o + b >= 1 ? (u = (t * c - 1) * Math.pow(2, s), o = o + b) : (u = t * Math.pow(2, b - 1) * Math.pow(2, s), o = 0)); s >= 8; e[n + m] = u & 255, m += E, u /= 256, s -= 8)
    ;
  for (o = o << s | u, h += s; h > 0; e[n + m] = o & 255, m += E, o /= 256, h -= 8)
    ;
  e[n + m - E] |= M * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  var t = Ja, n = zc, i = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = u, e.SlowBuffer = T, e.INSPECT_MAX_BYTES = 50;
  var s = 2147483647;
  e.kMaxLength = s, u.TYPED_ARRAY_SUPPORT = r(), !u.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function r() {
    try {
      var Q = new Uint8Array(1), C = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(C, Uint8Array.prototype), Object.setPrototypeOf(Q, C), Q.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(u.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(u.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.byteOffset;
    }
  });
  function o(Q) {
    if (Q > s)
      throw new RangeError('The value "' + Q + '" is invalid for option "size"');
    var C = new Uint8Array(Q);
    return Object.setPrototypeOf(C, u.prototype), C;
  }
  function u(Q, C, L) {
    if (typeof Q == "number") {
      if (typeof C == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return b(Q);
    }
    return c(Q, C, L);
  }
  u.poolSize = 8192;
  function c(Q, C, L) {
    if (typeof Q == "string")
      return v(Q, C);
    if (ArrayBuffer.isView(Q))
      return E(Q);
    if (Q == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Q
      );
    if (ce(Q, ArrayBuffer) || Q && ce(Q.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ce(Q, SharedArrayBuffer) || Q && ce(Q.buffer, SharedArrayBuffer)))
      return M(Q, C, L);
    if (typeof Q == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var W = Q.valueOf && Q.valueOf();
    if (W != null && W !== Q)
      return u.from(W, C, L);
    var de = B(Q);
    if (de)
      return de;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Q[Symbol.toPrimitive] == "function")
      return u.from(
        Q[Symbol.toPrimitive]("string"),
        C,
        L
      );
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Q
    );
  }
  u.from = function(Q, C, L) {
    return c(Q, C, L);
  }, Object.setPrototypeOf(u.prototype, Uint8Array.prototype), Object.setPrototypeOf(u, Uint8Array);
  function h(Q) {
    if (typeof Q != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Q < 0)
      throw new RangeError('The value "' + Q + '" is invalid for option "size"');
  }
  function f(Q, C, L) {
    return h(Q), Q <= 0 ? o(Q) : C !== void 0 ? typeof L == "string" ? o(Q).fill(C, L) : o(Q).fill(C) : o(Q);
  }
  u.alloc = function(Q, C, L) {
    return f(Q, C, L);
  };
  function b(Q) {
    return h(Q), o(Q < 0 ? 0 : I(Q) | 0);
  }
  u.allocUnsafe = function(Q) {
    return b(Q);
  }, u.allocUnsafeSlow = function(Q) {
    return b(Q);
  };
  function v(Q, C) {
    if ((typeof C != "string" || C === "") && (C = "utf8"), !u.isEncoding(C))
      throw new TypeError("Unknown encoding: " + C);
    var L = k(Q, C) | 0, W = o(L), de = W.write(Q, C);
    return de !== L && (W = W.slice(0, de)), W;
  }
  function m(Q) {
    for (var C = Q.length < 0 ? 0 : I(Q.length) | 0, L = o(C), W = 0; W < C; W += 1)
      L[W] = Q[W] & 255;
    return L;
  }
  function E(Q) {
    if (ce(Q, Uint8Array)) {
      var C = new Uint8Array(Q);
      return M(C.buffer, C.byteOffset, C.byteLength);
    }
    return m(Q);
  }
  function M(Q, C, L) {
    if (C < 0 || Q.byteLength < C)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Q.byteLength < C + (L || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var W;
    return C === void 0 && L === void 0 ? W = new Uint8Array(Q) : L === void 0 ? W = new Uint8Array(Q, C) : W = new Uint8Array(Q, C, L), Object.setPrototypeOf(W, u.prototype), W;
  }
  function B(Q) {
    if (u.isBuffer(Q)) {
      var C = I(Q.length) | 0, L = o(C);
      return L.length === 0 || Q.copy(L, 0, 0, C), L;
    }
    if (Q.length !== void 0)
      return typeof Q.length != "number" || ve(Q.length) ? o(0) : m(Q);
    if (Q.type === "Buffer" && Array.isArray(Q.data))
      return m(Q.data);
  }
  function I(Q) {
    if (Q >= s)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
    return Q | 0;
  }
  function T(Q) {
    return +Q != Q && (Q = 0), u.alloc(+Q);
  }
  u.isBuffer = function(C) {
    return C != null && C._isBuffer === !0 && C !== u.prototype;
  }, u.compare = function(C, L) {
    if (ce(C, Uint8Array) && (C = u.from(C, C.offset, C.byteLength)), ce(L, Uint8Array) && (L = u.from(L, L.offset, L.byteLength)), !u.isBuffer(C) || !u.isBuffer(L))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (C === L)
      return 0;
    for (var W = C.length, de = L.length, me = 0, Te = Math.min(W, de); me < Te; ++me)
      if (C[me] !== L[me]) {
        W = C[me], de = L[me];
        break;
      }
    return W < de ? -1 : de < W ? 1 : 0;
  }, u.isEncoding = function(C) {
    switch (String(C).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, u.concat = function(C, L) {
    if (!Array.isArray(C))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (C.length === 0)
      return u.alloc(0);
    var W;
    if (L === void 0)
      for (L = 0, W = 0; W < C.length; ++W)
        L += C[W].length;
    var de = u.allocUnsafe(L), me = 0;
    for (W = 0; W < C.length; ++W) {
      var Te = C[W];
      if (ce(Te, Uint8Array))
        me + Te.length > de.length ? u.from(Te).copy(de, me) : Uint8Array.prototype.set.call(
          de,
          Te,
          me
        );
      else if (u.isBuffer(Te))
        Te.copy(de, me);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      me += Te.length;
    }
    return de;
  };
  function k(Q, C) {
    if (u.isBuffer(Q))
      return Q.length;
    if (ArrayBuffer.isView(Q) || ce(Q, ArrayBuffer))
      return Q.byteLength;
    if (typeof Q != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Q
      );
    var L = Q.length, W = arguments.length > 2 && arguments[2] === !0;
    if (!W && L === 0)
      return 0;
    for (var de = !1; ; )
      switch (C) {
        case "ascii":
        case "latin1":
        case "binary":
          return L;
        case "utf8":
        case "utf-8":
          return F(Q).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return L * 2;
        case "hex":
          return L >>> 1;
        case "base64":
          return Z(Q).length;
        default:
          if (de)
            return W ? -1 : F(Q).length;
          C = ("" + C).toLowerCase(), de = !0;
      }
  }
  u.byteLength = k;
  function j(Q, C, L) {
    var W = !1;
    if ((C === void 0 || C < 0) && (C = 0), C > this.length || ((L === void 0 || L > this.length) && (L = this.length), L <= 0) || (L >>>= 0, C >>>= 0, L <= C))
      return "";
    for (Q || (Q = "utf8"); ; )
      switch (Q) {
        case "hex":
          return S(this, C, L);
        case "utf8":
        case "utf-8":
          return a(this, C, L);
        case "ascii":
          return x(this, C, L);
        case "latin1":
        case "binary":
          return A(this, C, L);
        case "base64":
          return p(this, C, L);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return g(this, C, L);
        default:
          if (W)
            throw new TypeError("Unknown encoding: " + Q);
          Q = (Q + "").toLowerCase(), W = !0;
      }
  }
  u.prototype._isBuffer = !0;
  function N(Q, C, L) {
    var W = Q[C];
    Q[C] = Q[L], Q[L] = W;
  }
  u.prototype.swap16 = function() {
    var C = this.length;
    if (C % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var L = 0; L < C; L += 2)
      N(this, L, L + 1);
    return this;
  }, u.prototype.swap32 = function() {
    var C = this.length;
    if (C % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var L = 0; L < C; L += 4)
      N(this, L, L + 3), N(this, L + 1, L + 2);
    return this;
  }, u.prototype.swap64 = function() {
    var C = this.length;
    if (C % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var L = 0; L < C; L += 8)
      N(this, L, L + 7), N(this, L + 1, L + 6), N(this, L + 2, L + 5), N(this, L + 3, L + 4);
    return this;
  }, u.prototype.toString = function() {
    var C = this.length;
    return C === 0 ? "" : arguments.length === 0 ? a(this, 0, C) : j.apply(this, arguments);
  }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(C) {
    if (!u.isBuffer(C))
      throw new TypeError("Argument must be a Buffer");
    return this === C ? !0 : u.compare(this, C) === 0;
  }, u.prototype.inspect = function() {
    var C = "", L = e.INSPECT_MAX_BYTES;
    return C = this.toString("hex", 0, L).replace(/(.{2})/g, "$1 ").trim(), this.length > L && (C += " ... "), "<Buffer " + C + ">";
  }, i && (u.prototype[i] = u.prototype.inspect), u.prototype.compare = function(C, L, W, de, me) {
    if (ce(C, Uint8Array) && (C = u.from(C, C.offset, C.byteLength)), !u.isBuffer(C))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof C
      );
    if (L === void 0 && (L = 0), W === void 0 && (W = C ? C.length : 0), de === void 0 && (de = 0), me === void 0 && (me = this.length), L < 0 || W > C.length || de < 0 || me > this.length)
      throw new RangeError("out of range index");
    if (de >= me && L >= W)
      return 0;
    if (de >= me)
      return -1;
    if (L >= W)
      return 1;
    if (L >>>= 0, W >>>= 0, de >>>= 0, me >>>= 0, this === C)
      return 0;
    for (var Te = me - de, Fe = W - L, H = Math.min(Te, Fe), ue = this.slice(de, me), se = C.slice(L, W), we = 0; we < H; ++we)
      if (ue[we] !== se[we]) {
        Te = ue[we], Fe = se[we];
        break;
      }
    return Te < Fe ? -1 : Fe < Te ? 1 : 0;
  };
  function q(Q, C, L, W, de) {
    if (Q.length === 0)
      return -1;
    if (typeof L == "string" ? (W = L, L = 0) : L > 2147483647 ? L = 2147483647 : L < -2147483648 && (L = -2147483648), L = +L, ve(L) && (L = de ? 0 : Q.length - 1), L < 0 && (L = Q.length + L), L >= Q.length) {
      if (de)
        return -1;
      L = Q.length - 1;
    } else if (L < 0)
      if (de)
        L = 0;
      else
        return -1;
    if (typeof C == "string" && (C = u.from(C, W)), u.isBuffer(C))
      return C.length === 0 ? -1 : D(Q, C, L, W, de);
    if (typeof C == "number")
      return C = C & 255, typeof Uint8Array.prototype.indexOf == "function" ? de ? Uint8Array.prototype.indexOf.call(Q, C, L) : Uint8Array.prototype.lastIndexOf.call(Q, C, L) : D(Q, [C], L, W, de);
    throw new TypeError("val must be string, number or Buffer");
  }
  function D(Q, C, L, W, de) {
    var me = 1, Te = Q.length, Fe = C.length;
    if (W !== void 0 && (W = String(W).toLowerCase(), W === "ucs2" || W === "ucs-2" || W === "utf16le" || W === "utf-16le")) {
      if (Q.length < 2 || C.length < 2)
        return -1;
      me = 2, Te /= 2, Fe /= 2, L /= 2;
    }
    function H(ze, Le) {
      return me === 1 ? ze[Le] : ze.readUInt16BE(Le * me);
    }
    var ue;
    if (de) {
      var se = -1;
      for (ue = L; ue < Te; ue++)
        if (H(Q, ue) === H(C, se === -1 ? 0 : ue - se)) {
          if (se === -1 && (se = ue), ue - se + 1 === Fe)
            return se * me;
        } else
          se !== -1 && (ue -= ue - se), se = -1;
    } else
      for (L + Fe > Te && (L = Te - Fe), ue = L; ue >= 0; ue--) {
        for (var we = !0, Ce = 0; Ce < Fe; Ce++)
          if (H(Q, ue + Ce) !== H(C, Ce)) {
            we = !1;
            break;
          }
        if (we)
          return ue;
      }
    return -1;
  }
  u.prototype.includes = function(C, L, W) {
    return this.indexOf(C, L, W) !== -1;
  }, u.prototype.indexOf = function(C, L, W) {
    return q(this, C, L, W, !0);
  }, u.prototype.lastIndexOf = function(C, L, W) {
    return q(this, C, L, W, !1);
  };
  function re(Q, C, L, W) {
    L = Number(L) || 0;
    var de = Q.length - L;
    W ? (W = Number(W), W > de && (W = de)) : W = de;
    var me = C.length;
    W > me / 2 && (W = me / 2);
    for (var Te = 0; Te < W; ++Te) {
      var Fe = parseInt(C.substr(Te * 2, 2), 16);
      if (ve(Fe))
        return Te;
      Q[L + Te] = Fe;
    }
    return Te;
  }
  function te(Q, C, L, W) {
    return K(F(C, Q.length - L), Q, L, W);
  }
  function oe(Q, C, L, W) {
    return K(ee(C), Q, L, W);
  }
  function U(Q, C, L, W) {
    return K(Z(C), Q, L, W);
  }
  function y(Q, C, L, W) {
    return K(he(C, Q.length - L), Q, L, W);
  }
  u.prototype.write = function(C, L, W, de) {
    if (L === void 0)
      de = "utf8", W = this.length, L = 0;
    else if (W === void 0 && typeof L == "string")
      de = L, W = this.length, L = 0;
    else if (isFinite(L))
      L = L >>> 0, isFinite(W) ? (W = W >>> 0, de === void 0 && (de = "utf8")) : (de = W, W = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var me = this.length - L;
    if ((W === void 0 || W > me) && (W = me), C.length > 0 && (W < 0 || L < 0) || L > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    de || (de = "utf8");
    for (var Te = !1; ; )
      switch (de) {
        case "hex":
          return re(this, C, L, W);
        case "utf8":
        case "utf-8":
          return te(this, C, L, W);
        case "ascii":
        case "latin1":
        case "binary":
          return oe(this, C, L, W);
        case "base64":
          return U(this, C, L, W);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return y(this, C, L, W);
        default:
          if (Te)
            throw new TypeError("Unknown encoding: " + de);
          de = ("" + de).toLowerCase(), Te = !0;
      }
  }, u.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function p(Q, C, L) {
    return C === 0 && L === Q.length ? t.fromByteArray(Q) : t.fromByteArray(Q.slice(C, L));
  }
  function a(Q, C, L) {
    L = Math.min(Q.length, L);
    for (var W = [], de = C; de < L; ) {
      var me = Q[de], Te = null, Fe = me > 239 ? 4 : me > 223 ? 3 : me > 191 ? 2 : 1;
      if (de + Fe <= L) {
        var H, ue, se, we;
        switch (Fe) {
          case 1:
            me < 128 && (Te = me);
            break;
          case 2:
            H = Q[de + 1], (H & 192) === 128 && (we = (me & 31) << 6 | H & 63, we > 127 && (Te = we));
            break;
          case 3:
            H = Q[de + 1], ue = Q[de + 2], (H & 192) === 128 && (ue & 192) === 128 && (we = (me & 15) << 12 | (H & 63) << 6 | ue & 63, we > 2047 && (we < 55296 || we > 57343) && (Te = we));
            break;
          case 4:
            H = Q[de + 1], ue = Q[de + 2], se = Q[de + 3], (H & 192) === 128 && (ue & 192) === 128 && (se & 192) === 128 && (we = (me & 15) << 18 | (H & 63) << 12 | (ue & 63) << 6 | se & 63, we > 65535 && we < 1114112 && (Te = we));
        }
      }
      Te === null ? (Te = 65533, Fe = 1) : Te > 65535 && (Te -= 65536, W.push(Te >>> 10 & 1023 | 55296), Te = 56320 | Te & 1023), W.push(Te), de += Fe;
    }
    return _(W);
  }
  var l = 4096;
  function _(Q) {
    var C = Q.length;
    if (C <= l)
      return String.fromCharCode.apply(String, Q);
    for (var L = "", W = 0; W < C; )
      L += String.fromCharCode.apply(
        String,
        Q.slice(W, W += l)
      );
    return L;
  }
  function x(Q, C, L) {
    var W = "";
    L = Math.min(Q.length, L);
    for (var de = C; de < L; ++de)
      W += String.fromCharCode(Q[de] & 127);
    return W;
  }
  function A(Q, C, L) {
    var W = "";
    L = Math.min(Q.length, L);
    for (var de = C; de < L; ++de)
      W += String.fromCharCode(Q[de]);
    return W;
  }
  function S(Q, C, L) {
    var W = Q.length;
    (!C || C < 0) && (C = 0), (!L || L < 0 || L > W) && (L = W);
    for (var de = "", me = C; me < L; ++me)
      de += Be[Q[me]];
    return de;
  }
  function g(Q, C, L) {
    for (var W = Q.slice(C, L), de = "", me = 0; me < W.length - 1; me += 2)
      de += String.fromCharCode(W[me] + W[me + 1] * 256);
    return de;
  }
  u.prototype.slice = function(C, L) {
    var W = this.length;
    C = ~~C, L = L === void 0 ? W : ~~L, C < 0 ? (C += W, C < 0 && (C = 0)) : C > W && (C = W), L < 0 ? (L += W, L < 0 && (L = 0)) : L > W && (L = W), L < C && (L = C);
    var de = this.subarray(C, L);
    return Object.setPrototypeOf(de, u.prototype), de;
  };
  function w(Q, C, L) {
    if (Q % 1 !== 0 || Q < 0)
      throw new RangeError("offset is not uint");
    if (Q + C > L)
      throw new RangeError("Trying to access beyond buffer length");
  }
  u.prototype.readUintLE = u.prototype.readUIntLE = function(C, L, W) {
    C = C >>> 0, L = L >>> 0, W || w(C, L, this.length);
    for (var de = this[C], me = 1, Te = 0; ++Te < L && (me *= 256); )
      de += this[C + Te] * me;
    return de;
  }, u.prototype.readUintBE = u.prototype.readUIntBE = function(C, L, W) {
    C = C >>> 0, L = L >>> 0, W || w(C, L, this.length);
    for (var de = this[C + --L], me = 1; L > 0 && (me *= 256); )
      de += this[C + --L] * me;
    return de;
  }, u.prototype.readUint8 = u.prototype.readUInt8 = function(C, L) {
    return C = C >>> 0, L || w(C, 1, this.length), this[C];
  }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(C, L) {
    return C = C >>> 0, L || w(C, 2, this.length), this[C] | this[C + 1] << 8;
  }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(C, L) {
    return C = C >>> 0, L || w(C, 2, this.length), this[C] << 8 | this[C + 1];
  }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(C, L) {
    return C = C >>> 0, L || w(C, 4, this.length), (this[C] | this[C + 1] << 8 | this[C + 2] << 16) + this[C + 3] * 16777216;
  }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(C, L) {
    return C = C >>> 0, L || w(C, 4, this.length), this[C] * 16777216 + (this[C + 1] << 16 | this[C + 2] << 8 | this[C + 3]);
  }, u.prototype.readIntLE = function(C, L, W) {
    C = C >>> 0, L = L >>> 0, W || w(C, L, this.length);
    for (var de = this[C], me = 1, Te = 0; ++Te < L && (me *= 256); )
      de += this[C + Te] * me;
    return me *= 128, de >= me && (de -= Math.pow(2, 8 * L)), de;
  }, u.prototype.readIntBE = function(C, L, W) {
    C = C >>> 0, L = L >>> 0, W || w(C, L, this.length);
    for (var de = L, me = 1, Te = this[C + --de]; de > 0 && (me *= 256); )
      Te += this[C + --de] * me;
    return me *= 128, Te >= me && (Te -= Math.pow(2, 8 * L)), Te;
  }, u.prototype.readInt8 = function(C, L) {
    return C = C >>> 0, L || w(C, 1, this.length), this[C] & 128 ? (255 - this[C] + 1) * -1 : this[C];
  }, u.prototype.readInt16LE = function(C, L) {
    C = C >>> 0, L || w(C, 2, this.length);
    var W = this[C] | this[C + 1] << 8;
    return W & 32768 ? W | 4294901760 : W;
  }, u.prototype.readInt16BE = function(C, L) {
    C = C >>> 0, L || w(C, 2, this.length);
    var W = this[C + 1] | this[C] << 8;
    return W & 32768 ? W | 4294901760 : W;
  }, u.prototype.readInt32LE = function(C, L) {
    return C = C >>> 0, L || w(C, 4, this.length), this[C] | this[C + 1] << 8 | this[C + 2] << 16 | this[C + 3] << 24;
  }, u.prototype.readInt32BE = function(C, L) {
    return C = C >>> 0, L || w(C, 4, this.length), this[C] << 24 | this[C + 1] << 16 | this[C + 2] << 8 | this[C + 3];
  }, u.prototype.readFloatLE = function(C, L) {
    return C = C >>> 0, L || w(C, 4, this.length), n.read(this, C, !0, 23, 4);
  }, u.prototype.readFloatBE = function(C, L) {
    return C = C >>> 0, L || w(C, 4, this.length), n.read(this, C, !1, 23, 4);
  }, u.prototype.readDoubleLE = function(C, L) {
    return C = C >>> 0, L || w(C, 8, this.length), n.read(this, C, !0, 52, 8);
  }, u.prototype.readDoubleBE = function(C, L) {
    return C = C >>> 0, L || w(C, 8, this.length), n.read(this, C, !1, 52, 8);
  };
  function d(Q, C, L, W, de, me) {
    if (!u.isBuffer(Q))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (C > de || C < me)
      throw new RangeError('"value" argument is out of bounds');
    if (L + W > Q.length)
      throw new RangeError("Index out of range");
  }
  u.prototype.writeUintLE = u.prototype.writeUIntLE = function(C, L, W, de) {
    if (C = +C, L = L >>> 0, W = W >>> 0, !de) {
      var me = Math.pow(2, 8 * W) - 1;
      d(this, C, L, W, me, 0);
    }
    var Te = 1, Fe = 0;
    for (this[L] = C & 255; ++Fe < W && (Te *= 256); )
      this[L + Fe] = C / Te & 255;
    return L + W;
  }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(C, L, W, de) {
    if (C = +C, L = L >>> 0, W = W >>> 0, !de) {
      var me = Math.pow(2, 8 * W) - 1;
      d(this, C, L, W, me, 0);
    }
    var Te = W - 1, Fe = 1;
    for (this[L + Te] = C & 255; --Te >= 0 && (Fe *= 256); )
      this[L + Te] = C / Fe & 255;
    return L + W;
  }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(C, L, W) {
    return C = +C, L = L >>> 0, W || d(this, C, L, 1, 255, 0), this[L] = C & 255, L + 1;
  }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(C, L, W) {
    return C = +C, L = L >>> 0, W || d(this, C, L, 2, 65535, 0), this[L] = C & 255, this[L + 1] = C >>> 8, L + 2;
  }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(C, L, W) {
    return C = +C, L = L >>> 0, W || d(this, C, L, 2, 65535, 0), this[L] = C >>> 8, this[L + 1] = C & 255, L + 2;
  }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(C, L, W) {
    return C = +C, L = L >>> 0, W || d(this, C, L, 4, 4294967295, 0), this[L + 3] = C >>> 24, this[L + 2] = C >>> 16, this[L + 1] = C >>> 8, this[L] = C & 255, L + 4;
  }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(C, L, W) {
    return C = +C, L = L >>> 0, W || d(this, C, L, 4, 4294967295, 0), this[L] = C >>> 24, this[L + 1] = C >>> 16, this[L + 2] = C >>> 8, this[L + 3] = C & 255, L + 4;
  }, u.prototype.writeIntLE = function(C, L, W, de) {
    if (C = +C, L = L >>> 0, !de) {
      var me = Math.pow(2, 8 * W - 1);
      d(this, C, L, W, me - 1, -me);
    }
    var Te = 0, Fe = 1, H = 0;
    for (this[L] = C & 255; ++Te < W && (Fe *= 256); )
      C < 0 && H === 0 && this[L + Te - 1] !== 0 && (H = 1), this[L + Te] = (C / Fe >> 0) - H & 255;
    return L + W;
  }, u.prototype.writeIntBE = function(C, L, W, de) {
    if (C = +C, L = L >>> 0, !de) {
      var me = Math.pow(2, 8 * W - 1);
      d(this, C, L, W, me - 1, -me);
    }
    var Te = W - 1, Fe = 1, H = 0;
    for (this[L + Te] = C & 255; --Te >= 0 && (Fe *= 256); )
      C < 0 && H === 0 && this[L + Te + 1] !== 0 && (H = 1), this[L + Te] = (C / Fe >> 0) - H & 255;
    return L + W;
  }, u.prototype.writeInt8 = function(C, L, W) {
    return C = +C, L = L >>> 0, W || d(this, C, L, 1, 127, -128), C < 0 && (C = 255 + C + 1), this[L] = C & 255, L + 1;
  }, u.prototype.writeInt16LE = function(C, L, W) {
    return C = +C, L = L >>> 0, W || d(this, C, L, 2, 32767, -32768), this[L] = C & 255, this[L + 1] = C >>> 8, L + 2;
  }, u.prototype.writeInt16BE = function(C, L, W) {
    return C = +C, L = L >>> 0, W || d(this, C, L, 2, 32767, -32768), this[L] = C >>> 8, this[L + 1] = C & 255, L + 2;
  }, u.prototype.writeInt32LE = function(C, L, W) {
    return C = +C, L = L >>> 0, W || d(this, C, L, 4, 2147483647, -2147483648), this[L] = C & 255, this[L + 1] = C >>> 8, this[L + 2] = C >>> 16, this[L + 3] = C >>> 24, L + 4;
  }, u.prototype.writeInt32BE = function(C, L, W) {
    return C = +C, L = L >>> 0, W || d(this, C, L, 4, 2147483647, -2147483648), C < 0 && (C = 4294967295 + C + 1), this[L] = C >>> 24, this[L + 1] = C >>> 16, this[L + 2] = C >>> 8, this[L + 3] = C & 255, L + 4;
  };
  function R(Q, C, L, W, de, me) {
    if (L + W > Q.length)
      throw new RangeError("Index out of range");
    if (L < 0)
      throw new RangeError("Index out of range");
  }
  function G(Q, C, L, W, de) {
    return C = +C, L = L >>> 0, de || R(Q, C, L, 4), n.write(Q, C, L, W, 23, 4), L + 4;
  }
  u.prototype.writeFloatLE = function(C, L, W) {
    return G(this, C, L, !0, W);
  }, u.prototype.writeFloatBE = function(C, L, W) {
    return G(this, C, L, !1, W);
  };
  function fe(Q, C, L, W, de) {
    return C = +C, L = L >>> 0, de || R(Q, C, L, 8), n.write(Q, C, L, W, 52, 8), L + 8;
  }
  u.prototype.writeDoubleLE = function(C, L, W) {
    return fe(this, C, L, !0, W);
  }, u.prototype.writeDoubleBE = function(C, L, W) {
    return fe(this, C, L, !1, W);
  }, u.prototype.copy = function(C, L, W, de) {
    if (!u.isBuffer(C))
      throw new TypeError("argument should be a Buffer");
    if (W || (W = 0), !de && de !== 0 && (de = this.length), L >= C.length && (L = C.length), L || (L = 0), de > 0 && de < W && (de = W), de === W || C.length === 0 || this.length === 0)
      return 0;
    if (L < 0)
      throw new RangeError("targetStart out of bounds");
    if (W < 0 || W >= this.length)
      throw new RangeError("Index out of range");
    if (de < 0)
      throw new RangeError("sourceEnd out of bounds");
    de > this.length && (de = this.length), C.length - L < de - W && (de = C.length - L + W);
    var me = de - W;
    return this === C && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(L, W, de) : Uint8Array.prototype.set.call(
      C,
      this.subarray(W, de),
      L
    ), me;
  }, u.prototype.fill = function(C, L, W, de) {
    if (typeof C == "string") {
      if (typeof L == "string" ? (de = L, L = 0, W = this.length) : typeof W == "string" && (de = W, W = this.length), de !== void 0 && typeof de != "string")
        throw new TypeError("encoding must be a string");
      if (typeof de == "string" && !u.isEncoding(de))
        throw new TypeError("Unknown encoding: " + de);
      if (C.length === 1) {
        var me = C.charCodeAt(0);
        (de === "utf8" && me < 128 || de === "latin1") && (C = me);
      }
    } else
      typeof C == "number" ? C = C & 255 : typeof C == "boolean" && (C = Number(C));
    if (L < 0 || this.length < L || this.length < W)
      throw new RangeError("Out of range index");
    if (W <= L)
      return this;
    L = L >>> 0, W = W === void 0 ? this.length : W >>> 0, C || (C = 0);
    var Te;
    if (typeof C == "number")
      for (Te = L; Te < W; ++Te)
        this[Te] = C;
    else {
      var Fe = u.isBuffer(C) ? C : u.from(C, de), H = Fe.length;
      if (H === 0)
        throw new TypeError('The value "' + C + '" is invalid for argument "value"');
      for (Te = 0; Te < W - L; ++Te)
        this[Te + L] = Fe[Te % H];
    }
    return this;
  };
  var z = /[^+/0-9A-Za-z-_]/g;
  function V(Q) {
    if (Q = Q.split("=")[0], Q = Q.trim().replace(z, ""), Q.length < 2)
      return "";
    for (; Q.length % 4 !== 0; )
      Q = Q + "=";
    return Q;
  }
  function F(Q, C) {
    C = C || 1 / 0;
    for (var L, W = Q.length, de = null, me = [], Te = 0; Te < W; ++Te) {
      if (L = Q.charCodeAt(Te), L > 55295 && L < 57344) {
        if (!de) {
          if (L > 56319) {
            (C -= 3) > -1 && me.push(239, 191, 189);
            continue;
          } else if (Te + 1 === W) {
            (C -= 3) > -1 && me.push(239, 191, 189);
            continue;
          }
          de = L;
          continue;
        }
        if (L < 56320) {
          (C -= 3) > -1 && me.push(239, 191, 189), de = L;
          continue;
        }
        L = (de - 55296 << 10 | L - 56320) + 65536;
      } else
        de && (C -= 3) > -1 && me.push(239, 191, 189);
      if (de = null, L < 128) {
        if ((C -= 1) < 0)
          break;
        me.push(L);
      } else if (L < 2048) {
        if ((C -= 2) < 0)
          break;
        me.push(
          L >> 6 | 192,
          L & 63 | 128
        );
      } else if (L < 65536) {
        if ((C -= 3) < 0)
          break;
        me.push(
          L >> 12 | 224,
          L >> 6 & 63 | 128,
          L & 63 | 128
        );
      } else if (L < 1114112) {
        if ((C -= 4) < 0)
          break;
        me.push(
          L >> 18 | 240,
          L >> 12 & 63 | 128,
          L >> 6 & 63 | 128,
          L & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return me;
  }
  function ee(Q) {
    for (var C = [], L = 0; L < Q.length; ++L)
      C.push(Q.charCodeAt(L) & 255);
    return C;
  }
  function he(Q, C) {
    for (var L, W, de, me = [], Te = 0; Te < Q.length && !((C -= 2) < 0); ++Te)
      L = Q.charCodeAt(Te), W = L >> 8, de = L % 256, me.push(de), me.push(W);
    return me;
  }
  function Z(Q) {
    return t.toByteArray(V(Q));
  }
  function K(Q, C, L, W) {
    for (var de = 0; de < W && !(de + L >= C.length || de >= Q.length); ++de)
      C[de + L] = Q[de];
    return de;
  }
  function ce(Q, C) {
    return Q instanceof C || Q != null && Q.constructor != null && Q.constructor.name != null && Q.constructor.name === C.name;
  }
  function ve(Q) {
    return Q !== Q;
  }
  var Be = function() {
    for (var Q = "0123456789abcdef", C = new Array(256), L = 0; L < 16; ++L)
      for (var W = L * 16, de = 0; de < 16; ++de)
        C[W + de] = Q[L] + Q[de];
    return C;
  }();
})(dr);
var Xa = {}, Pv = {}, ei = {}, Ya = {}, Yt = {};
Object.defineProperty(Yt, "__esModule", { value: !0 });
Yt.output = Yt.exists = Yt.hash = Yt.bytes = Yt.bool = Yt.number = void 0;
function _a(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
Yt.number = _a;
function Cv(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
Yt.bool = Cv;
function Vc(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
Yt.bytes = Vc;
function Nv(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  _a(e.outputLen), _a(e.blockLen);
}
Yt.hash = Nv;
function Lv(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
Yt.exists = Lv;
function kv(e, t) {
  Vc(e);
  const n = t.outputLen;
  if (e.length < n)
    throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
Yt.output = kv;
const X_ = {
  number: _a,
  bool: Cv,
  bytes: Vc,
  hash: Nv,
  exists: Lv,
  output: kv
};
Yt.default = X_;
var rn = {}, Qa = {};
Object.defineProperty(Qa, "__esModule", { value: !0 });
Qa.crypto = void 0;
Qa.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(e) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(e, "__esModule", { value: !0 }), e.randomBytes = e.wrapXOFConstructorWithOpts = e.wrapConstructorWithOpts = e.wrapConstructor = e.checkOpts = e.Hash = e.concatBytes = e.toBytes = e.utf8ToBytes = e.asyncLoop = e.nextTick = e.hexToBytes = e.bytesToHex = e.isLE = e.rotr = e.createView = e.u32 = e.u8 = void 0;
  const t = Qa, n = (q) => q instanceof Uint8Array, i = (q) => new Uint8Array(q.buffer, q.byteOffset, q.byteLength);
  e.u8 = i;
  const s = (q) => new Uint32Array(q.buffer, q.byteOffset, Math.floor(q.byteLength / 4));
  e.u32 = s;
  const r = (q) => new DataView(q.buffer, q.byteOffset, q.byteLength);
  e.createView = r;
  const o = (q, D) => q << 32 - D | q >>> D;
  if (e.rotr = o, e.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !e.isLE)
    throw new Error("Non little-endian hardware is not supported");
  const u = Array.from({ length: 256 }, (q, D) => D.toString(16).padStart(2, "0"));
  function c(q) {
    if (!n(q))
      throw new Error("Uint8Array expected");
    let D = "";
    for (let re = 0; re < q.length; re++)
      D += u[q[re]];
    return D;
  }
  e.bytesToHex = c;
  function h(q) {
    if (typeof q != "string")
      throw new Error("hex string expected, got " + typeof q);
    const D = q.length;
    if (D % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + D);
    const re = new Uint8Array(D / 2);
    for (let te = 0; te < re.length; te++) {
      const oe = te * 2, U = q.slice(oe, oe + 2), y = Number.parseInt(U, 16);
      if (Number.isNaN(y) || y < 0)
        throw new Error("Invalid byte sequence");
      re[te] = y;
    }
    return re;
  }
  e.hexToBytes = h;
  const f = async () => {
  };
  e.nextTick = f;
  async function b(q, D, re) {
    let te = Date.now();
    for (let oe = 0; oe < q; oe++) {
      re(oe);
      const U = Date.now() - te;
      U >= 0 && U < D || (await (0, e.nextTick)(), te += U);
    }
  }
  e.asyncLoop = b;
  function v(q) {
    if (typeof q != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof q}`);
    return new Uint8Array(new TextEncoder().encode(q));
  }
  e.utf8ToBytes = v;
  function m(q) {
    if (typeof q == "string" && (q = v(q)), !n(q))
      throw new Error(`expected Uint8Array, got ${typeof q}`);
    return q;
  }
  e.toBytes = m;
  function E(...q) {
    const D = new Uint8Array(q.reduce((te, oe) => te + oe.length, 0));
    let re = 0;
    return q.forEach((te) => {
      if (!n(te))
        throw new Error("Uint8Array expected");
      D.set(te, re), re += te.length;
    }), D;
  }
  e.concatBytes = E;
  class M {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  e.Hash = M;
  const B = (q) => Object.prototype.toString.call(q) === "[object Object]" && q.constructor === Object;
  function I(q, D) {
    if (D !== void 0 && (typeof D != "object" || !B(D)))
      throw new Error("Options should be object or undefined");
    return Object.assign(q, D);
  }
  e.checkOpts = I;
  function T(q) {
    const D = (te) => q().update(m(te)).digest(), re = q();
    return D.outputLen = re.outputLen, D.blockLen = re.blockLen, D.create = () => q(), D;
  }
  e.wrapConstructor = T;
  function k(q) {
    const D = (te, oe) => q(oe).update(m(te)).digest(), re = q({});
    return D.outputLen = re.outputLen, D.blockLen = re.blockLen, D.create = (te) => q(te), D;
  }
  e.wrapConstructorWithOpts = k;
  function j(q) {
    const D = (te, oe) => q(oe).update(m(te)).digest(), re = q({});
    return D.outputLen = re.outputLen, D.blockLen = re.blockLen, D.create = (te) => q(te), D;
  }
  e.wrapXOFConstructorWithOpts = j;
  function N(q = 32) {
    if (t.crypto && typeof t.crypto.getRandomValues == "function")
      return t.crypto.getRandomValues(new Uint8Array(q));
    throw new Error("crypto.getRandomValues must be defined");
  }
  e.randomBytes = N;
})(rn);
Object.defineProperty(Ya, "__esModule", { value: !0 });
Ya.SHA2 = void 0;
const qf = Yt, vi = rn;
function Y_(e, t, n, i) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, n, i);
  const s = BigInt(32), r = BigInt(4294967295), o = Number(n >> s & r), u = Number(n & r), c = i ? 4 : 0, h = i ? 0 : 4;
  e.setUint32(t + c, o, i), e.setUint32(t + h, u, i);
}
class Q_ extends vi.Hash {
  constructor(t, n, i, s) {
    super(), this.blockLen = t, this.outputLen = n, this.padOffset = i, this.isLE = s, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = (0, vi.createView)(this.buffer);
  }
  update(t) {
    qf.default.exists(this);
    const { view: n, buffer: i, blockLen: s } = this;
    t = (0, vi.toBytes)(t);
    const r = t.length;
    for (let o = 0; o < r; ) {
      const u = Math.min(s - this.pos, r - o);
      if (u === s) {
        const c = (0, vi.createView)(t);
        for (; s <= r - o; o += s)
          this.process(c, o);
        continue;
      }
      i.set(t.subarray(o, o + u), this.pos), this.pos += u, o += u, this.pos === s && (this.process(n, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    qf.default.exists(this), qf.default.output(t, this), this.finished = !0;
    const { buffer: n, view: i, blockLen: s, isLE: r } = this;
    let { pos: o } = this;
    n[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > s - o && (this.process(i, 0), o = 0);
    for (let b = o; b < s; b++)
      n[b] = 0;
    Y_(i, s - 8, BigInt(this.length * 8), r), this.process(i, 0);
    const u = (0, vi.createView)(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const h = c / 4, f = this.get();
    if (h > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let b = 0; b < h; b++)
      u.setUint32(4 * b, f[b], r);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const i = t.slice(0, n);
    return this.destroy(), i;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: i, length: s, finished: r, destroyed: o, pos: u } = this;
    return t.length = s, t.pos = u, t.finished = r, t.destroyed = o, s % n && t.buffer.set(i), t;
  }
}
Ya.SHA2 = Q_;
Object.defineProperty(ei, "__esModule", { value: !0 });
ei.sha224 = ei.sha256 = void 0;
const ew = Ya, wr = rn, tw = (e, t, n) => e & t ^ ~e & n, rw = (e, t, n) => e & t ^ e & n ^ t & n, nw = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), an = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), fn = new Uint32Array(64);
class jv extends ew.SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = an[0] | 0, this.B = an[1] | 0, this.C = an[2] | 0, this.D = an[3] | 0, this.E = an[4] | 0, this.F = an[5] | 0, this.G = an[6] | 0, this.H = an[7] | 0;
  }
  get() {
    const { A: t, B: n, C: i, D: s, E: r, F: o, G: u, H: c } = this;
    return [t, n, i, s, r, o, u, c];
  }
  // prettier-ignore
  set(t, n, i, s, r, o, u, c) {
    this.A = t | 0, this.B = n | 0, this.C = i | 0, this.D = s | 0, this.E = r | 0, this.F = o | 0, this.G = u | 0, this.H = c | 0;
  }
  process(t, n) {
    for (let b = 0; b < 16; b++, n += 4)
      fn[b] = t.getUint32(n, !1);
    for (let b = 16; b < 64; b++) {
      const v = fn[b - 15], m = fn[b - 2], E = (0, wr.rotr)(v, 7) ^ (0, wr.rotr)(v, 18) ^ v >>> 3, M = (0, wr.rotr)(m, 17) ^ (0, wr.rotr)(m, 19) ^ m >>> 10;
      fn[b] = M + fn[b - 7] + E + fn[b - 16] | 0;
    }
    let { A: i, B: s, C: r, D: o, E: u, F: c, G: h, H: f } = this;
    for (let b = 0; b < 64; b++) {
      const v = (0, wr.rotr)(u, 6) ^ (0, wr.rotr)(u, 11) ^ (0, wr.rotr)(u, 25), m = f + v + tw(u, c, h) + nw[b] + fn[b] | 0, M = ((0, wr.rotr)(i, 2) ^ (0, wr.rotr)(i, 13) ^ (0, wr.rotr)(i, 22)) + rw(i, s, r) | 0;
      f = h, h = c, c = u, u = o + m | 0, o = r, r = s, s = i, i = m + M | 0;
    }
    i = i + this.A | 0, s = s + this.B | 0, r = r + this.C | 0, o = o + this.D | 0, u = u + this.E | 0, c = c + this.F | 0, h = h + this.G | 0, f = f + this.H | 0, this.set(i, s, r, o, u, c, h, f);
  }
  roundClean() {
    fn.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class iw extends jv {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
ei.sha256 = (0, wr.wrapConstructor)(() => new jv());
ei.sha224 = (0, wr.wrapConstructor)(() => new iw());
var St = {}, bt = {};
Object.defineProperty(bt, "__esModule", { value: !0 });
bt.validateObject = bt.createHmacDrbg = bt.bitMask = bt.bitSet = bt.bitGet = bt.bitLen = bt.utf8ToBytes = bt.equalBytes = bt.concatBytes = bt.ensureBytes = bt.numberToVarBytesBE = bt.numberToBytesLE = bt.numberToBytesBE = bt.bytesToNumberLE = bt.bytesToNumberBE = bt.hexToBytes = bt.hexToNumber = bt.numberToHexUnpadded = bt.bytesToHex = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const qv = BigInt(0), ef = BigInt(1), aw = BigInt(2), tf = (e) => e instanceof Uint8Array, fw = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Kc(e) {
  if (!tf(e))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let n = 0; n < e.length; n++)
    t += fw[e[n]];
  return t;
}
bt.bytesToHex = Kc;
function Dv(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
bt.numberToHexUnpadded = Dv;
function Zc(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
bt.hexToNumber = Zc;
function rf(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const t = e.length;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const n = new Uint8Array(t / 2);
  for (let i = 0; i < n.length; i++) {
    const s = i * 2, r = e.slice(s, s + 2), o = Number.parseInt(r, 16);
    if (Number.isNaN(o) || o < 0)
      throw new Error("Invalid byte sequence");
    n[i] = o;
  }
  return n;
}
bt.hexToBytes = rf;
function ow(e) {
  return Zc(Kc(e));
}
bt.bytesToNumberBE = ow;
function sw(e) {
  if (!tf(e))
    throw new Error("Uint8Array expected");
  return Zc(Kc(Uint8Array.from(e).reverse()));
}
bt.bytesToNumberLE = sw;
function $v(e, t) {
  return rf(e.toString(16).padStart(t * 2, "0"));
}
bt.numberToBytesBE = $v;
function uw(e, t) {
  return $v(e, t).reverse();
}
bt.numberToBytesLE = uw;
function cw(e) {
  return rf(Dv(e));
}
bt.numberToVarBytesBE = cw;
function hw(e, t, n) {
  let i;
  if (typeof t == "string")
    try {
      i = rf(t);
    } catch (r) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${r}`);
    }
  else if (tf(t))
    i = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const s = i.length;
  if (typeof n == "number" && s !== n)
    throw new Error(`${e} expected ${n} bytes, got ${s}`);
  return i;
}
bt.ensureBytes = hw;
function Uv(...e) {
  const t = new Uint8Array(e.reduce((i, s) => i + s.length, 0));
  let n = 0;
  return e.forEach((i) => {
    if (!tf(i))
      throw new Error("Uint8Array expected");
    t.set(i, n), n += i.length;
  }), t;
}
bt.concatBytes = Uv;
function lw(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
bt.equalBytes = lw;
function dw(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
bt.utf8ToBytes = dw;
function pw(e) {
  let t;
  for (t = 0; e > qv; e >>= ef, t += 1)
    ;
  return t;
}
bt.bitLen = pw;
function vw(e, t) {
  return e >> BigInt(t) & ef;
}
bt.bitGet = vw;
const bw = (e, t, n) => e | (n ? ef : qv) << BigInt(t);
bt.bitSet = bw;
const yw = (e) => (aw << BigInt(e - 1)) - ef;
bt.bitMask = yw;
const Df = (e) => new Uint8Array(e), gh = (e) => Uint8Array.from(e);
function gw(e, t, n) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof n != "function")
    throw new Error("hmacFn must be a function");
  let i = Df(e), s = Df(e), r = 0;
  const o = () => {
    i.fill(1), s.fill(0), r = 0;
  }, u = (...b) => n(s, i, ...b), c = (b = Df()) => {
    s = u(gh([0]), b), i = u(), b.length !== 0 && (s = u(gh([1]), b), i = u());
  }, h = () => {
    if (r++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let b = 0;
    const v = [];
    for (; b < t; ) {
      i = u();
      const m = i.slice();
      v.push(m), b += i.length;
    }
    return Uv(...v);
  };
  return (b, v) => {
    o(), c(b);
    let m;
    for (; !(m = v(h())); )
      c();
    return o(), m;
  };
}
bt.createHmacDrbg = gw;
const mw = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function _w(e, t, n = {}) {
  const i = (s, r, o) => {
    const u = mw[r];
    if (typeof u != "function")
      throw new Error(`Invalid validator "${r}", expected function`);
    const c = e[s];
    if (!(o && c === void 0) && !u(c, e))
      throw new Error(`Invalid param ${String(s)}=${c} (${typeof c}), expected ${r}`);
  };
  for (const [s, r] of Object.entries(t))
    i(s, r, !1);
  for (const [s, r] of Object.entries(n))
    i(s, r, !0);
  return e;
}
bt.validateObject = _w;
Object.defineProperty(St, "__esModule", { value: !0 });
St.hashToPrivateScalar = St.FpSqrtEven = St.FpSqrtOdd = St.Field = St.nLength = St.FpIsSquare = St.FpDiv = St.FpInvertBatch = St.FpPow = St.validateField = St.isNegativeLE = St.FpSqrt = St.tonelliShanks = St.invert = St.pow2 = St.pow = St.mod = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const tn = bt, Qt = BigInt(0), jt = BigInt(1), sn = BigInt(2), ww = BigInt(3), uc = BigInt(4), mh = BigInt(5), _h = BigInt(8);
BigInt(9);
BigInt(16);
function Er(e, t) {
  const n = e % t;
  return n >= Qt ? n : t + n;
}
St.mod = Er;
function Fv(e, t, n) {
  if (n <= Qt || t < Qt)
    throw new Error("Expected power/modulo > 0");
  if (n === jt)
    return Qt;
  let i = jt;
  for (; t > Qt; )
    t & jt && (i = i * e % n), e = e * e % n, t >>= jt;
  return i;
}
St.pow = Fv;
function xw(e, t, n) {
  let i = e;
  for (; t-- > Qt; )
    i *= i, i %= n;
  return i;
}
St.pow2 = xw;
function wa(e, t) {
  if (e === Qt || t <= Qt)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let n = Er(e, t), i = t, s = Qt, r = jt;
  for (; n !== Qt; ) {
    const u = i / n, c = i % n, h = s - r * u;
    i = n, n = c, s = r, r = h;
  }
  if (i !== jt)
    throw new Error("invert: does not exist");
  return Er(s, t);
}
St.invert = wa;
function Hv(e) {
  const t = (e - jt) / sn;
  let n, i, s;
  for (n = e - jt, i = 0; n % sn === Qt; n /= sn, i++)
    ;
  for (s = sn; s < e && Fv(s, t, e) !== e - jt; s++)
    ;
  if (i === 1) {
    const o = (e + jt) / uc;
    return function(c, h) {
      const f = c.pow(h, o);
      if (!c.eql(c.sqr(f), h))
        throw new Error("Cannot find square root");
      return f;
    };
  }
  const r = (n + jt) / sn;
  return function(u, c) {
    if (u.pow(c, t) === u.neg(u.ONE))
      throw new Error("Cannot find square root");
    let h = i, f = u.pow(u.mul(u.ONE, s), n), b = u.pow(c, r), v = u.pow(c, n);
    for (; !u.eql(v, u.ONE); ) {
      if (u.eql(v, u.ZERO))
        return u.ZERO;
      let m = 1;
      for (let M = u.sqr(v); m < h && !u.eql(M, u.ONE); m++)
        M = u.sqr(M);
      const E = u.pow(f, jt << BigInt(h - m - 1));
      f = u.sqr(E), b = u.mul(b, E), v = u.mul(v, f), h = m;
    }
    return b;
  };
}
St.tonelliShanks = Hv;
function zv(e) {
  if (e % uc === ww) {
    const t = (e + jt) / uc;
    return function(i, s) {
      const r = i.pow(s, t);
      if (!i.eql(i.sqr(r), s))
        throw new Error("Cannot find square root");
      return r;
    };
  }
  if (e % _h === mh) {
    const t = (e - mh) / _h;
    return function(i, s) {
      const r = i.mul(s, sn), o = i.pow(r, t), u = i.mul(s, o), c = i.mul(i.mul(u, sn), o), h = i.mul(u, i.sub(c, i.ONE));
      if (!i.eql(i.sqr(h), s))
        throw new Error("Cannot find square root");
      return h;
    };
  }
  return Hv(e);
}
St.FpSqrt = zv;
const Ew = (e, t) => (Er(e, t) & jt) === jt;
St.isNegativeLE = Ew;
const Sw = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Aw(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, n = Sw.reduce((i, s) => (i[s] = "function", i), t);
  return (0, tn.validateObject)(e, n);
}
St.validateField = Aw;
function Vv(e, t, n) {
  if (n < Qt)
    throw new Error("Expected power > 0");
  if (n === Qt)
    return e.ONE;
  if (n === jt)
    return t;
  let i = e.ONE, s = t;
  for (; n > Qt; )
    n & jt && (i = e.mul(i, s)), s = e.sqr(s), n >>= jt;
  return i;
}
St.FpPow = Vv;
function Kv(e, t) {
  const n = new Array(t.length), i = t.reduce((r, o, u) => e.is0(o) ? r : (n[u] = r, e.mul(r, o)), e.ONE), s = e.inv(i);
  return t.reduceRight((r, o, u) => e.is0(o) ? r : (n[u] = e.mul(r, n[u]), e.mul(r, o)), s), n;
}
St.FpInvertBatch = Kv;
function Mw(e, t, n) {
  return e.mul(t, typeof n == "bigint" ? wa(n, e.ORDER) : e.inv(n));
}
St.FpDiv = Mw;
function Rw(e) {
  const t = (e.ORDER - jt) / sn;
  return (n) => {
    const i = e.pow(n, t);
    return e.eql(i, e.ZERO) || e.eql(i, e.ONE);
  };
}
St.FpIsSquare = Rw;
function Gc(e, t) {
  const n = t !== void 0 ? t : e.toString(2).length, i = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: i };
}
St.nLength = Gc;
function Bw(e, t, n = !1, i = {}) {
  if (e <= Qt)
    throw new Error(`Expected Fp ORDER > 0, got ${e}`);
  const { nBitLength: s, nByteLength: r } = Gc(e, t);
  if (r > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const o = zv(e), u = Object.freeze({
    ORDER: e,
    BITS: s,
    BYTES: r,
    MASK: (0, tn.bitMask)(s),
    ZERO: Qt,
    ONE: jt,
    create: (c) => Er(c, e),
    isValid: (c) => {
      if (typeof c != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
      return Qt <= c && c < e;
    },
    is0: (c) => c === Qt,
    isOdd: (c) => (c & jt) === jt,
    neg: (c) => Er(-c, e),
    eql: (c, h) => c === h,
    sqr: (c) => Er(c * c, e),
    add: (c, h) => Er(c + h, e),
    sub: (c, h) => Er(c - h, e),
    mul: (c, h) => Er(c * h, e),
    pow: (c, h) => Vv(u, c, h),
    div: (c, h) => Er(c * wa(h, e), e),
    // Same as above, but doesn't normalize
    sqrN: (c) => c * c,
    addN: (c, h) => c + h,
    subN: (c, h) => c - h,
    mulN: (c, h) => c * h,
    inv: (c) => wa(c, e),
    sqrt: i.sqrt || ((c) => o(u, c)),
    invertBatch: (c) => Kv(u, c),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (c, h, f) => f ? h : c,
    toBytes: (c) => n ? (0, tn.numberToBytesLE)(c, r) : (0, tn.numberToBytesBE)(c, r),
    fromBytes: (c) => {
      if (c.length !== r)
        throw new Error(`Fp.fromBytes: expected ${r}, got ${c.length}`);
      return n ? (0, tn.bytesToNumberLE)(c) : (0, tn.bytesToNumberBE)(c);
    }
  });
  return Object.freeze(u);
}
St.Field = Bw;
function Iw(e, t) {
  if (!e.isOdd)
    throw new Error("Field doesn't have isOdd");
  const n = e.sqrt(t);
  return e.isOdd(n) ? n : e.neg(n);
}
St.FpSqrtOdd = Iw;
function Tw(e, t) {
  if (!e.isOdd)
    throw new Error("Field doesn't have isOdd");
  const n = e.sqrt(t);
  return e.isOdd(n) ? e.neg(n) : n;
}
St.FpSqrtEven = Tw;
function Ow(e, t, n = !1) {
  e = (0, tn.ensureBytes)("privateHash", e);
  const i = e.length, s = Gc(t).nByteLength + 8;
  if (s < 24 || i < s || i > 1024)
    throw new Error(`hashToPrivateScalar: expected ${s}-1024 bytes of input, got ${i}`);
  const r = n ? (0, tn.bytesToNumberLE)(e) : (0, tn.bytesToNumberBE)(e);
  return Er(r, t - jt) + jt;
}
St.hashToPrivateScalar = Ow;
var Wc = {}, ti = {};
Object.defineProperty(ti, "__esModule", { value: !0 });
ti.validateBasic = ti.wNAF = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const wh = St, Pw = bt, Cw = BigInt(0), $f = BigInt(1);
function Nw(e, t) {
  const n = (s, r) => {
    const o = r.negate();
    return s ? o : r;
  }, i = (s) => {
    const r = Math.ceil(t / s) + 1, o = 2 ** (s - 1);
    return { windows: r, windowSize: o };
  };
  return {
    constTimeNegate: n,
    // non-const time multiplication ladder
    unsafeLadder(s, r) {
      let o = e.ZERO, u = s;
      for (; r > Cw; )
        r & $f && (o = o.add(u)), u = u.double(), r >>= $f;
      return o;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(s, r) {
      const { windows: o, windowSize: u } = i(r), c = [];
      let h = s, f = h;
      for (let b = 0; b < o; b++) {
        f = h, c.push(f);
        for (let v = 1; v < u; v++)
          f = f.add(h), c.push(f);
        h = f.double();
      }
      return c;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(s, r, o) {
      const { windows: u, windowSize: c } = i(s);
      let h = e.ZERO, f = e.BASE;
      const b = BigInt(2 ** s - 1), v = 2 ** s, m = BigInt(s);
      for (let E = 0; E < u; E++) {
        const M = E * c;
        let B = Number(o & b);
        o >>= m, B > c && (B -= v, o += $f);
        const I = M, T = M + Math.abs(B) - 1, k = E % 2 !== 0, j = B < 0;
        B === 0 ? f = f.add(n(k, r[I])) : h = h.add(n(j, r[T]));
      }
      return { p: h, f };
    },
    wNAFCached(s, r, o, u) {
      const c = s._WINDOW_SIZE || 1;
      let h = r.get(s);
      return h || (h = this.precomputeWindow(s, c), c !== 1 && r.set(s, u(h))), this.wNAF(c, h, o);
    }
  };
}
ti.wNAF = Nw;
function Lw(e) {
  return (0, wh.validateField)(e.Fp), (0, Pw.validateObject)(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...(0, wh.nLength)(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
ti.validateBasic = Lw;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.mapToCurveSimpleSWU = e.SWUFpSqrtRatio = e.weierstrass = e.weierstrassPoints = e.DER = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const t = St, n = bt, i = bt, s = ti;
  function r(T) {
    const k = (0, s.validateBasic)(T);
    n.validateObject(k, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo: j, Fp: N, a: q } = k;
    if (j) {
      if (!N.eql(q, N.ZERO))
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      if (typeof j != "object" || typeof j.beta != "bigint" || typeof j.splitScalar != "function")
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
    return Object.freeze({ ...k });
  }
  const { bytesToNumberBE: o, hexToBytes: u } = n;
  e.DER = {
    // asn.1 DER encoding utils
    Err: class extends Error {
      constructor(k = "") {
        super(k);
      }
    },
    _parseInt(T) {
      const { Err: k } = e.DER;
      if (T.length < 2 || T[0] !== 2)
        throw new k("Invalid signature integer tag");
      const j = T[1], N = T.subarray(2, j + 2);
      if (!j || N.length !== j)
        throw new k("Invalid signature integer: wrong length");
      if (N[0] & 128)
        throw new k("Invalid signature integer: negative");
      if (N[0] === 0 && !(N[1] & 128))
        throw new k("Invalid signature integer: unnecessary leading zero");
      return { d: o(N), l: T.subarray(j + 2) };
    },
    toSig(T) {
      const { Err: k } = e.DER, j = typeof T == "string" ? u(T) : T;
      if (!(j instanceof Uint8Array))
        throw new Error("ui8a expected");
      let N = j.length;
      if (N < 2 || j[0] != 48)
        throw new k("Invalid signature tag");
      if (j[1] !== N - 2)
        throw new k("Invalid signature: incorrect length");
      const { d: q, l: D } = e.DER._parseInt(j.subarray(2)), { d: re, l: te } = e.DER._parseInt(D);
      if (te.length)
        throw new k("Invalid signature: left bytes after parsing");
      return { r: q, s: re };
    },
    hexFromSig(T) {
      const k = (U) => Number.parseInt(U[0], 16) & 8 ? "00" + U : U, j = (U) => {
        const y = U.toString(16);
        return y.length & 1 ? `0${y}` : y;
      }, N = k(j(T.s)), q = k(j(T.r)), D = N.length / 2, re = q.length / 2, te = j(D), oe = j(re);
      return `30${j(re + D + 4)}02${oe}${q}02${te}${N}`;
    }
  };
  const c = BigInt(0), h = BigInt(1), f = BigInt(2), b = BigInt(3), v = BigInt(4);
  function m(T) {
    const k = r(T), { Fp: j } = k, N = k.toBytes || ((_, x, A) => {
      const S = x.toAffine();
      return n.concatBytes(Uint8Array.from([4]), j.toBytes(S.x), j.toBytes(S.y));
    }), q = k.fromBytes || ((_) => {
      const x = _.subarray(1), A = j.fromBytes(x.subarray(0, j.BYTES)), S = j.fromBytes(x.subarray(j.BYTES, 2 * j.BYTES));
      return { x: A, y: S };
    });
    function D(_) {
      const { a: x, b: A } = k, S = j.sqr(_), g = j.mul(S, _);
      return j.add(j.add(g, j.mul(_, x)), A);
    }
    if (!j.eql(j.sqr(k.Gy), D(k.Gx)))
      throw new Error("bad generator point: equation left != right");
    function re(_) {
      return typeof _ == "bigint" && c < _ && _ < k.n;
    }
    function te(_) {
      if (!re(_))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function oe(_) {
      const { allowedPrivateKeyLengths: x, nByteLength: A, wrapPrivateKey: S, n: g } = k;
      if (x && typeof _ != "bigint") {
        if (_ instanceof Uint8Array && (_ = n.bytesToHex(_)), typeof _ != "string" || !x.includes(_.length))
          throw new Error("Invalid key");
        _ = _.padStart(A * 2, "0");
      }
      let w;
      try {
        w = typeof _ == "bigint" ? _ : n.bytesToNumberBE((0, i.ensureBytes)("private key", _, A));
      } catch {
        throw new Error(`private key must be ${A} bytes, hex or bigint, not ${typeof _}`);
      }
      return S && (w = t.mod(w, g)), te(w), w;
    }
    const U = /* @__PURE__ */ new Map();
    function y(_) {
      if (!(_ instanceof p))
        throw new Error("ProjectivePoint expected");
    }
    class p {
      constructor(x, A, S) {
        if (this.px = x, this.py = A, this.pz = S, x == null || !j.isValid(x))
          throw new Error("x required");
        if (A == null || !j.isValid(A))
          throw new Error("y required");
        if (S == null || !j.isValid(S))
          throw new Error("z required");
      }
      // Does not validate if the point is on-curve.
      // Use fromHex instead, or call assertValidity() later.
      static fromAffine(x) {
        const { x: A, y: S } = x || {};
        if (!x || !j.isValid(A) || !j.isValid(S))
          throw new Error("invalid affine point");
        if (x instanceof p)
          throw new Error("projective point not allowed");
        const g = (w) => j.eql(w, j.ZERO);
        return g(A) && g(S) ? p.ZERO : new p(A, S, j.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       * Takes a bunch of Projective Points but executes only one
       * inversion on all of them. Inversion is very slow operation,
       * so this improves performance massively.
       * Optimization: converts a list of projective points to a list of identical points with Z=1.
       */
      static normalizeZ(x) {
        const A = j.invertBatch(x.map((S) => S.pz));
        return x.map((S, g) => S.toAffine(A[g])).map(p.fromAffine);
      }
      /**
       * Converts hash string or Uint8Array to Point.
       * @param hex short/long ECDSA hex
       */
      static fromHex(x) {
        const A = p.fromAffine(q((0, i.ensureBytes)("pointHex", x)));
        return A.assertValidity(), A;
      }
      // Multiplies generator point by privateKey.
      static fromPrivateKey(x) {
        return p.BASE.multiply(oe(x));
      }
      // "Private method", don't use it directly
      _setWindowSize(x) {
        this._WINDOW_SIZE = x, U.delete(this);
      }
      // A point on curve is valid if it conforms to equation.
      assertValidity() {
        if (this.is0()) {
          if (k.allowInfinityPoint)
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y: A } = this.toAffine();
        if (!j.isValid(x) || !j.isValid(A))
          throw new Error("bad point: x or y not FE");
        const S = j.sqr(A), g = D(x);
        if (!j.eql(S, g))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y: x } = this.toAffine();
        if (j.isOdd)
          return !j.isOdd(x);
        throw new Error("Field doesn't support isOdd");
      }
      /**
       * Compare one point to another.
       */
      equals(x) {
        y(x);
        const { px: A, py: S, pz: g } = this, { px: w, py: d, pz: R } = x, G = j.eql(j.mul(A, R), j.mul(w, g)), fe = j.eql(j.mul(S, R), j.mul(d, g));
        return G && fe;
      }
      /**
       * Flips point to one corresponding to (x, -y) in Affine coordinates.
       */
      negate() {
        return new p(this.px, j.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a: x, b: A } = k, S = j.mul(A, b), { px: g, py: w, pz: d } = this;
        let R = j.ZERO, G = j.ZERO, fe = j.ZERO, z = j.mul(g, g), V = j.mul(w, w), F = j.mul(d, d), ee = j.mul(g, w);
        return ee = j.add(ee, ee), fe = j.mul(g, d), fe = j.add(fe, fe), R = j.mul(x, fe), G = j.mul(S, F), G = j.add(R, G), R = j.sub(V, G), G = j.add(V, G), G = j.mul(R, G), R = j.mul(ee, R), fe = j.mul(S, fe), F = j.mul(x, F), ee = j.sub(z, F), ee = j.mul(x, ee), ee = j.add(ee, fe), fe = j.add(z, z), z = j.add(fe, z), z = j.add(z, F), z = j.mul(z, ee), G = j.add(G, z), F = j.mul(w, d), F = j.add(F, F), z = j.mul(F, ee), R = j.sub(R, z), fe = j.mul(F, V), fe = j.add(fe, fe), fe = j.add(fe, fe), new p(R, G, fe);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(x) {
        y(x);
        const { px: A, py: S, pz: g } = this, { px: w, py: d, pz: R } = x;
        let G = j.ZERO, fe = j.ZERO, z = j.ZERO;
        const V = k.a, F = j.mul(k.b, b);
        let ee = j.mul(A, w), he = j.mul(S, d), Z = j.mul(g, R), K = j.add(A, S), ce = j.add(w, d);
        K = j.mul(K, ce), ce = j.add(ee, he), K = j.sub(K, ce), ce = j.add(A, g);
        let ve = j.add(w, R);
        return ce = j.mul(ce, ve), ve = j.add(ee, Z), ce = j.sub(ce, ve), ve = j.add(S, g), G = j.add(d, R), ve = j.mul(ve, G), G = j.add(he, Z), ve = j.sub(ve, G), z = j.mul(V, ce), G = j.mul(F, Z), z = j.add(G, z), G = j.sub(he, z), z = j.add(he, z), fe = j.mul(G, z), he = j.add(ee, ee), he = j.add(he, ee), Z = j.mul(V, Z), ce = j.mul(F, ce), he = j.add(he, Z), Z = j.sub(ee, Z), Z = j.mul(V, Z), ce = j.add(ce, Z), ee = j.mul(he, ce), fe = j.add(fe, ee), ee = j.mul(ve, ce), G = j.mul(K, G), G = j.sub(G, ee), ee = j.mul(K, he), z = j.mul(ve, z), z = j.add(z, ee), new p(G, fe, z);
      }
      subtract(x) {
        return this.add(x.negate());
      }
      is0() {
        return this.equals(p.ZERO);
      }
      wNAF(x) {
        return l.wNAFCached(this, U, x, (A) => {
          const S = j.invertBatch(A.map((g) => g.pz));
          return A.map((g, w) => g.toAffine(S[w])).map(p.fromAffine);
        });
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(x) {
        const A = p.ZERO;
        if (x === c)
          return A;
        if (te(x), x === h)
          return this;
        const { endo: S } = k;
        if (!S)
          return l.unsafeLadder(this, x);
        let { k1neg: g, k1: w, k2neg: d, k2: R } = S.splitScalar(x), G = A, fe = A, z = this;
        for (; w > c || R > c; )
          w & h && (G = G.add(z)), R & h && (fe = fe.add(z)), z = z.double(), w >>= h, R >>= h;
        return g && (G = G.negate()), d && (fe = fe.negate()), fe = new p(j.mul(fe.px, S.beta), fe.py, fe.pz), G.add(fe);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(x) {
        te(x);
        let A = x, S, g;
        const { endo: w } = k;
        if (w) {
          const { k1neg: d, k1: R, k2neg: G, k2: fe } = w.splitScalar(A);
          let { p: z, f: V } = this.wNAF(R), { p: F, f: ee } = this.wNAF(fe);
          z = l.constTimeNegate(d, z), F = l.constTimeNegate(G, F), F = new p(j.mul(F.px, w.beta), F.py, F.pz), S = z.add(F), g = V.add(ee);
        } else {
          const { p: d, f: R } = this.wNAF(A);
          S = d, g = R;
        }
        return p.normalizeZ([S, g])[0];
      }
      /**
       * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
       * Not using Strauss-Shamir trick: precomputation tables are faster.
       * The trick could be useful if both P and Q are not G (not in our case).
       * @returns non-zero affine point
       */
      multiplyAndAddUnsafe(x, A, S) {
        const g = p.BASE, w = (R, G) => G === c || G === h || !R.equals(g) ? R.multiplyUnsafe(G) : R.multiply(G), d = w(this, A).add(w(x, S));
        return d.is0() ? void 0 : d;
      }
      // Converts Projective point to affine (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      // (x, y, z)  (x=x/z, y=y/z)
      toAffine(x) {
        const { px: A, py: S, pz: g } = this, w = this.is0();
        x == null && (x = w ? j.ONE : j.inv(g));
        const d = j.mul(A, x), R = j.mul(S, x), G = j.mul(g, x);
        if (w)
          return { x: j.ZERO, y: j.ZERO };
        if (!j.eql(G, j.ONE))
          throw new Error("invZ was invalid");
        return { x: d, y: R };
      }
      isTorsionFree() {
        const { h: x, isTorsionFree: A } = k;
        if (x === h)
          return !0;
        if (A)
          return A(p, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: x, clearCofactor: A } = k;
        return x === h ? this : A ? A(p, this) : this.multiplyUnsafe(k.h);
      }
      toRawBytes(x = !0) {
        return this.assertValidity(), N(p, this, x);
      }
      toHex(x = !0) {
        return n.bytesToHex(this.toRawBytes(x));
      }
    }
    p.BASE = new p(k.Gx, k.Gy, j.ONE), p.ZERO = new p(j.ZERO, j.ONE, j.ZERO);
    const a = k.nBitLength, l = (0, s.wNAF)(p, k.endo ? Math.ceil(a / 2) : a);
    return {
      CURVE: k,
      ProjectivePoint: p,
      normPrivateKeyToScalar: oe,
      weierstrassEquation: D,
      isWithinCurveOrder: re
    };
  }
  e.weierstrassPoints = m;
  function E(T) {
    const k = (0, s.validateBasic)(T);
    return n.validateObject(k, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    }), Object.freeze({ lowS: !0, ...k });
  }
  function M(T) {
    const k = E(T), { Fp: j, n: N } = k, q = j.BYTES + 1, D = 2 * j.BYTES + 1;
    function re(ce) {
      return c < ce && ce < j.ORDER;
    }
    function te(ce) {
      return t.mod(ce, N);
    }
    function oe(ce) {
      return t.invert(ce, N);
    }
    const { ProjectivePoint: U, normPrivateKeyToScalar: y, weierstrassEquation: p, isWithinCurveOrder: a } = m({
      ...k,
      toBytes(ce, ve, Be) {
        const Q = ve.toAffine(), C = j.toBytes(Q.x), L = n.concatBytes;
        return Be ? L(Uint8Array.from([ve.hasEvenY() ? 2 : 3]), C) : L(Uint8Array.from([4]), C, j.toBytes(Q.y));
      },
      fromBytes(ce) {
        const ve = ce.length, Be = ce[0], Q = ce.subarray(1);
        if (ve === q && (Be === 2 || Be === 3)) {
          const C = n.bytesToNumberBE(Q);
          if (!re(C))
            throw new Error("Point is not on curve");
          const L = p(C);
          let W = j.sqrt(L);
          const de = (W & h) === h;
          return (Be & 1) === 1 !== de && (W = j.neg(W)), { x: C, y: W };
        } else if (ve === D && Be === 4) {
          const C = j.fromBytes(Q.subarray(0, j.BYTES)), L = j.fromBytes(Q.subarray(j.BYTES, 2 * j.BYTES));
          return { x: C, y: L };
        } else
          throw new Error(`Point of length ${ve} was invalid. Expected ${q} compressed bytes or ${D} uncompressed bytes`);
      }
    }), l = (ce) => n.bytesToHex(n.numberToBytesBE(ce, k.nByteLength));
    function _(ce) {
      const ve = N >> h;
      return ce > ve;
    }
    function x(ce) {
      return _(ce) ? te(-ce) : ce;
    }
    const A = (ce, ve, Be) => n.bytesToNumberBE(ce.slice(ve, Be));
    class S {
      constructor(ve, Be, Q) {
        this.r = ve, this.s = Be, this.recovery = Q, this.assertValidity();
      }
      // pair (bytes of r, bytes of s)
      static fromCompact(ve) {
        const Be = k.nByteLength;
        return ve = (0, i.ensureBytes)("compactSignature", ve, Be * 2), new S(A(ve, 0, Be), A(ve, Be, 2 * Be));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
      static fromDER(ve) {
        const { r: Be, s: Q } = e.DER.toSig((0, i.ensureBytes)("DER", ve));
        return new S(Be, Q);
      }
      assertValidity() {
        if (!a(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!a(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(ve) {
        return new S(this.r, this.s, ve);
      }
      recoverPublicKey(ve) {
        const { r: Be, s: Q, recovery: C } = this, L = fe((0, i.ensureBytes)("msgHash", ve));
        if (C == null || ![0, 1, 2, 3].includes(C))
          throw new Error("recovery id invalid");
        const W = C === 2 || C === 3 ? Be + k.n : Be;
        if (W >= j.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const de = C & 1 ? "03" : "02", me = U.fromHex(de + l(W)), Te = oe(W), Fe = te(-L * Te), H = te(Q * Te), ue = U.BASE.multiplyAndAddUnsafe(me, Fe, H);
        if (!ue)
          throw new Error("point at infinify");
        return ue.assertValidity(), ue;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return _(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new S(this.r, te(-this.s), this.recovery) : this;
      }
      // DER-encoded
      toDERRawBytes() {
        return n.hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return e.DER.hexFromSig({ r: this.r, s: this.s });
      }
      // padded bytes of r, then padded bytes of s
      toCompactRawBytes() {
        return n.hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return l(this.r) + l(this.s);
      }
    }
    const g = {
      isValidPrivateKey(ce) {
        try {
          return y(ce), !0;
        } catch {
          return !1;
        }
      },
      normPrivateKeyToScalar: y,
      /**
       * Produces cryptographically secure private key from random of size (nBitLength+64)
       * as per FIPS 186 B.4.1 with modulo bias being neglible.
       */
      randomPrivateKey: () => {
        const ce = k.randomBytes(j.BYTES + 8), ve = t.hashToPrivateScalar(ce, N);
        return n.numberToBytesBE(ve, k.nByteLength);
      },
      /**
       * Creates precompute table for an arbitrary EC point. Makes point "cached".
       * Allows to massively speed-up `point.multiply(scalar)`.
       * @returns cached point
       * @example
       * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
       * fast.multiply(privKey); // much faster ECDH now
       */
      precompute(ce = 8, ve = U.BASE) {
        return ve._setWindowSize(ce), ve.multiply(BigInt(3)), ve;
      }
    };
    function w(ce, ve = !0) {
      return U.fromPrivateKey(ce).toRawBytes(ve);
    }
    function d(ce) {
      const ve = ce instanceof Uint8Array, Be = typeof ce == "string", Q = (ve || Be) && ce.length;
      return ve ? Q === q || Q === D : Be ? Q === 2 * q || Q === 2 * D : ce instanceof U;
    }
    function R(ce, ve, Be = !0) {
      if (d(ce))
        throw new Error("first arg must be private key");
      if (!d(ve))
        throw new Error("second arg must be public key");
      return U.fromHex(ve).multiply(y(ce)).toRawBytes(Be);
    }
    const G = k.bits2int || function(ce) {
      const ve = n.bytesToNumberBE(ce), Be = ce.length * 8 - k.nBitLength;
      return Be > 0 ? ve >> BigInt(Be) : ve;
    }, fe = k.bits2int_modN || function(ce) {
      return te(G(ce));
    }, z = n.bitMask(k.nBitLength);
    function V(ce) {
      if (typeof ce != "bigint")
        throw new Error("bigint expected");
      if (!(c <= ce && ce < z))
        throw new Error(`bigint expected < 2^${k.nBitLength}`);
      return n.numberToBytesBE(ce, k.nByteLength);
    }
    function F(ce, ve, Be = ee) {
      if (["recovered", "canonical"].some((we) => we in Be))
        throw new Error("sign() legacy options not supported");
      const { hash: Q, randomBytes: C } = k;
      let { lowS: L, prehash: W, extraEntropy: de } = Be;
      L == null && (L = !0), ce = (0, i.ensureBytes)("msgHash", ce), W && (ce = (0, i.ensureBytes)("prehashed msgHash", Q(ce)));
      const me = fe(ce), Te = y(ve), Fe = [V(Te), V(me)];
      if (de != null) {
        const we = de === !0 ? C(j.BYTES) : de;
        Fe.push((0, i.ensureBytes)("extraEntropy", we, j.BYTES));
      }
      const H = n.concatBytes(...Fe), ue = me;
      function se(we) {
        const Ce = G(we);
        if (!a(Ce))
          return;
        const ze = oe(Ce), Le = U.BASE.multiply(Ce).toAffine(), Y = te(Le.x);
        if (Y === c)
          return;
        const Se = te(ze * te(ue + Y * Te));
        if (Se === c)
          return;
        let Ae = (Le.x === Y ? 0 : 2) | Number(Le.y & h), je = Se;
        return L && _(Se) && (je = x(Se), Ae ^= 1), new S(Y, je, Ae);
      }
      return { seed: H, k2sig: se };
    }
    const ee = { lowS: k.lowS, prehash: !1 }, he = { lowS: k.lowS, prehash: !1 };
    function Z(ce, ve, Be = ee) {
      const { seed: Q, k2sig: C } = F(ce, ve, Be), L = k;
      return n.createHmacDrbg(L.hash.outputLen, L.nByteLength, L.hmac)(Q, C);
    }
    U.BASE._setWindowSize(8);
    function K(ce, ve, Be, Q = he) {
      var Le;
      const C = ce;
      if (ve = (0, i.ensureBytes)("msgHash", ve), Be = (0, i.ensureBytes)("publicKey", Be), "strict" in Q)
        throw new Error("options.strict was renamed to lowS");
      const { lowS: L, prehash: W } = Q;
      let de, me;
      try {
        if (typeof C == "string" || C instanceof Uint8Array)
          try {
            de = S.fromDER(C);
          } catch (Y) {
            if (!(Y instanceof e.DER.Err))
              throw Y;
            de = S.fromCompact(C);
          }
        else if (typeof C == "object" && typeof C.r == "bigint" && typeof C.s == "bigint") {
          const { r: Y, s: Se } = C;
          de = new S(Y, Se);
        } else
          throw new Error("PARSE");
        me = U.fromHex(Be);
      } catch (Y) {
        if (Y.message === "PARSE")
          throw new Error("signature must be Signature instance, Uint8Array or hex string");
        return !1;
      }
      if (L && de.hasHighS())
        return !1;
      W && (ve = k.hash(ve));
      const { r: Te, s: Fe } = de, H = fe(ve), ue = oe(Fe), se = te(H * ue), we = te(Te * ue), Ce = (Le = U.BASE.multiplyAndAddUnsafe(me, se, we)) == null ? void 0 : Le.toAffine();
      return Ce ? te(Ce.x) === Te : !1;
    }
    return {
      CURVE: k,
      getPublicKey: w,
      getSharedSecret: R,
      sign: Z,
      verify: K,
      ProjectivePoint: U,
      Signature: S,
      utils: g
    };
  }
  e.weierstrass = M;
  function B(T, k) {
    const j = T.ORDER;
    let N = c;
    for (let _ = j - h; _ % f === c; _ /= f)
      N += h;
    const q = N, D = f << q - h - h, re = D * f, te = (j - h) / re, oe = (te - h) / f, U = re - h, y = D, p = T.pow(k, te), a = T.pow(k, (te + h) / f);
    let l = (_, x) => {
      let A = p, S = T.pow(x, U), g = T.sqr(S);
      g = T.mul(g, x);
      let w = T.mul(_, g);
      w = T.pow(w, oe), w = T.mul(w, S), S = T.mul(w, x), g = T.mul(w, _);
      let d = T.mul(g, S);
      w = T.pow(d, y);
      let R = T.eql(w, T.ONE);
      S = T.mul(g, a), w = T.mul(d, A), g = T.cmov(S, g, R), d = T.cmov(w, d, R);
      for (let G = q; G > h; G--) {
        let fe = G - f;
        fe = f << fe - h;
        let z = T.pow(d, fe);
        const V = T.eql(z, T.ONE);
        S = T.mul(g, A), A = T.mul(A, A), z = T.mul(d, A), g = T.cmov(S, g, V), d = T.cmov(z, d, V);
      }
      return { isValid: R, value: g };
    };
    if (T.ORDER % v === b) {
      const _ = (T.ORDER - b) / v, x = T.sqrt(T.neg(k));
      l = (A, S) => {
        let g = T.sqr(S);
        const w = T.mul(A, S);
        g = T.mul(g, w);
        let d = T.pow(g, _);
        d = T.mul(d, w);
        const R = T.mul(d, x), G = T.mul(T.sqr(d), S), fe = T.eql(G, A);
        let z = T.cmov(R, d, fe);
        return { isValid: fe, value: z };
      };
    }
    return l;
  }
  e.SWUFpSqrtRatio = B;
  function I(T, k) {
    if (t.validateField(T), !T.isValid(k.A) || !T.isValid(k.B) || !T.isValid(k.Z))
      throw new Error("mapToCurveSimpleSWU: invalid opts");
    const j = B(T, k.Z);
    if (!T.isOdd)
      throw new Error("Fp.isOdd is not implemented!");
    return (N) => {
      let q, D, re, te, oe, U, y, p;
      q = T.sqr(N), q = T.mul(q, k.Z), D = T.sqr(q), D = T.add(D, q), re = T.add(D, T.ONE), re = T.mul(re, k.B), te = T.cmov(k.Z, T.neg(D), !T.eql(D, T.ZERO)), te = T.mul(te, k.A), D = T.sqr(re), U = T.sqr(te), oe = T.mul(U, k.A), D = T.add(D, oe), D = T.mul(D, re), U = T.mul(U, te), oe = T.mul(U, k.B), D = T.add(D, oe), y = T.mul(q, re);
      const { isValid: a, value: l } = j(D, U);
      p = T.mul(q, N), p = T.mul(p, l), y = T.cmov(y, re, a), p = T.cmov(p, l, a);
      const _ = T.isOdd(N) === T.isOdd(p);
      return p = T.cmov(T.neg(p), p, _), y = T.div(y, te), { x: y, y: p };
    };
  }
  e.mapToCurveSimpleSWU = I;
})(Wc);
var Ar = {};
Object.defineProperty(Ar, "__esModule", { value: !0 });
Ar.createHasher = Ar.isogenyMap = Ar.hash_to_field = Ar.expand_message_xof = Ar.expand_message_xmd = void 0;
const kw = St, kr = bt;
function jw(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return (0, kr.utf8ToBytes)(e);
  throw new Error("DST must be Uint8Array or string");
}
const qw = kr.bytesToNumberBE;
function on(e, t) {
  if (e < 0 || e >= 1 << 8 * t)
    throw new Error(`bad I2OSP call: value=${e} length=${t}`);
  const n = Array.from({ length: t }).fill(0);
  for (let i = t - 1; i >= 0; i--)
    n[i] = e & 255, e >>>= 8;
  return new Uint8Array(n);
}
function Dw(e, t) {
  const n = new Uint8Array(e.length);
  for (let i = 0; i < e.length; i++)
    n[i] = e[i] ^ t[i];
  return n;
}
function Mi(e) {
  if (!(e instanceof Uint8Array))
    throw new Error("Uint8Array expected");
}
function Jc(e) {
  if (!Number.isSafeInteger(e))
    throw new Error("number expected");
}
function Zv(e, t, n, i) {
  Mi(e), Mi(t), Jc(n), t.length > 255 && (t = i((0, kr.concatBytes)((0, kr.utf8ToBytes)("H2C-OVERSIZE-DST-"), t)));
  const { outputLen: s, blockLen: r } = i, o = Math.ceil(n / s);
  if (o > 255)
    throw new Error("Invalid xmd length");
  const u = (0, kr.concatBytes)(t, on(t.length, 1)), c = on(0, r), h = on(n, 2), f = new Array(o), b = i((0, kr.concatBytes)(c, e, h, on(0, 1), u));
  f[0] = i((0, kr.concatBytes)(b, on(1, 1), u));
  for (let m = 1; m <= o; m++) {
    const E = [Dw(b, f[m - 1]), on(m + 1, 1), u];
    f[m] = i((0, kr.concatBytes)(...E));
  }
  return (0, kr.concatBytes)(...f).slice(0, n);
}
Ar.expand_message_xmd = Zv;
function Gv(e, t, n, i, s) {
  if (Mi(e), Mi(t), Jc(n), t.length > 255) {
    const r = Math.ceil(2 * i / 8);
    t = s.create({ dkLen: r }).update((0, kr.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t).digest();
  }
  if (n > 65535 || t.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return s.create({ dkLen: n }).update(e).update(on(n, 2)).update(t).update(on(t.length, 1)).digest();
}
Ar.expand_message_xof = Gv;
function cc(e, t, n) {
  (0, kr.validateObject)(n, {
    DST: "string",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: i, k: s, m: r, hash: o, expand: u, DST: c } = n;
  Mi(e), Jc(t);
  const h = jw(c), f = i.toString(2).length, b = Math.ceil((f + s) / 8), v = t * r * b;
  let m;
  if (u === "xmd")
    m = Zv(e, h, v, o);
  else if (u === "xof")
    m = Gv(e, h, v, s, o);
  else if (u === "_internal_pass")
    m = e;
  else
    throw new Error('expand must be "xmd" or "xof"');
  const E = new Array(t);
  for (let M = 0; M < t; M++) {
    const B = new Array(r);
    for (let I = 0; I < r; I++) {
      const T = b * (I + M * r), k = m.subarray(T, T + b);
      B[I] = (0, kw.mod)(qw(k), i);
    }
    E[M] = B;
  }
  return E;
}
Ar.hash_to_field = cc;
function $w(e, t) {
  const n = t.map((i) => Array.from(i).reverse());
  return (i, s) => {
    const [r, o, u, c] = n.map((h) => h.reduce((f, b) => e.add(e.mul(f, i), b)));
    return i = e.div(r, o), s = e.mul(s, e.div(u, c)), { x: i, y: s };
  };
}
Ar.isogenyMap = $w;
function Uw(e, t, n) {
  if (typeof t != "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve
    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
    hashToCurve(i, s) {
      const r = cc(i, 2, { ...n, DST: n.DST, ...s }), o = e.fromAffine(t(r[0])), u = e.fromAffine(t(r[1])), c = o.add(u).clearCofactor();
      return c.assertValidity(), c;
    },
    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
    encodeToCurve(i, s) {
      const r = cc(i, 1, { ...n, DST: n.encodeDST, ...s }), o = e.fromAffine(t(r[0])).clearCofactor();
      return o.assertValidity(), o;
    }
  };
}
Ar.createHasher = Uw;
var ri = {}, Wv = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.hmac = e.HMAC = void 0;
  const t = Yt, n = rn;
  class i extends n.Hash {
    constructor(o, u) {
      super(), this.finished = !1, this.destroyed = !1, t.default.hash(o);
      const c = (0, n.toBytes)(u);
      if (this.iHash = o.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const h = this.blockLen, f = new Uint8Array(h);
      f.set(c.length > h ? o.create().update(c).digest() : c);
      for (let b = 0; b < f.length; b++)
        f[b] ^= 54;
      this.iHash.update(f), this.oHash = o.create();
      for (let b = 0; b < f.length; b++)
        f[b] ^= 106;
      this.oHash.update(f), f.fill(0);
    }
    update(o) {
      return t.default.exists(this), this.iHash.update(o), this;
    }
    digestInto(o) {
      t.default.exists(this), t.default.bytes(o, this.outputLen), this.finished = !0, this.iHash.digestInto(o), this.oHash.update(o), this.oHash.digestInto(o), this.destroy();
    }
    digest() {
      const o = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(o), o;
    }
    _cloneInto(o) {
      o || (o = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: u, iHash: c, finished: h, destroyed: f, blockLen: b, outputLen: v } = this;
      return o = o, o.finished = h, o.destroyed = f, o.blockLen = b, o.outputLen = v, o.oHash = u._cloneInto(o.oHash), o.iHash = c._cloneInto(o.iHash), o;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  e.HMAC = i;
  const s = (r, o, u) => new i(r, o).update(u).digest();
  e.hmac = s, e.hmac.create = (r, o) => new i(r, o);
})(Wv);
Object.defineProperty(ri, "__esModule", { value: !0 });
ri.createCurve = ri.getHash = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Fw = Wv, xh = rn, Hw = Wc;
function Jv(e) {
  return {
    hash: e,
    hmac: (t, ...n) => (0, Fw.hmac)(e, t, (0, xh.concatBytes)(...n)),
    randomBytes: xh.randomBytes
  };
}
ri.getHash = Jv;
function zw(e, t) {
  const n = (i) => (0, Hw.weierstrass)({ ...e, ...Jv(i) });
  return Object.freeze({ ...n(t), create: n });
}
ri.createCurve = zw;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.encodeToCurve = e.hashToCurve = e.schnorr = e.secp256k1 = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const t = ei, n = rn, i = St, s = Wc, r = bt, o = Ar, u = ri, c = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), h = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), f = BigInt(1), b = BigInt(2), v = (S, g) => (S + g / b) / g;
  function m(S) {
    const g = c, w = BigInt(3), d = BigInt(6), R = BigInt(11), G = BigInt(22), fe = BigInt(23), z = BigInt(44), V = BigInt(88), F = S * S * S % g, ee = F * F * S % g, he = (0, i.pow2)(ee, w, g) * ee % g, Z = (0, i.pow2)(he, w, g) * ee % g, K = (0, i.pow2)(Z, b, g) * F % g, ce = (0, i.pow2)(K, R, g) * K % g, ve = (0, i.pow2)(ce, G, g) * ce % g, Be = (0, i.pow2)(ve, z, g) * ve % g, Q = (0, i.pow2)(Be, V, g) * Be % g, C = (0, i.pow2)(Q, z, g) * ve % g, L = (0, i.pow2)(C, w, g) * ee % g, W = (0, i.pow2)(L, fe, g) * ce % g, de = (0, i.pow2)(W, d, g) * F % g, me = (0, i.pow2)(de, b, g);
    if (!E.eql(E.sqr(me), S))
      throw new Error("Cannot find square root");
    return me;
  }
  const E = (0, i.Field)(c, void 0, void 0, { sqrt: m });
  e.secp256k1 = (0, u.createCurve)({
    a: BigInt(0),
    b: BigInt(7),
    Fp: E,
    n: h,
    // Base point (x, y) aka generator point
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: !0,
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (S) => {
        const g = h, w = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), d = -f * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), R = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), G = w, fe = BigInt("0x100000000000000000000000000000000"), z = v(G * S, g), V = v(-d * S, g);
        let F = (0, i.mod)(S - z * w - V * R, g), ee = (0, i.mod)(-z * d - V * G, g);
        const he = F > fe, Z = ee > fe;
        if (he && (F = g - F), Z && (ee = g - ee), F > fe || ee > fe)
          throw new Error("splitScalar: Endomorphism failed, k=" + S);
        return { k1neg: he, k1: F, k2neg: Z, k2: ee };
      }
    }
  }, t.sha256);
  const M = BigInt(0), B = (S) => typeof S == "bigint" && M < S && S < c, I = (S) => typeof S == "bigint" && M < S && S < h, T = {};
  function k(S, ...g) {
    let w = T[S];
    if (w === void 0) {
      const d = (0, t.sha256)(Uint8Array.from(S, (R) => R.charCodeAt(0)));
      w = (0, r.concatBytes)(d, d), T[S] = w;
    }
    return (0, t.sha256)((0, r.concatBytes)(w, ...g));
  }
  const j = (S) => S.toRawBytes(!0).slice(1), N = (S) => (0, r.numberToBytesBE)(S, 32), q = (S) => (0, i.mod)(S, c), D = (S) => (0, i.mod)(S, h), re = e.secp256k1.ProjectivePoint, te = (S, g, w) => re.BASE.multiplyAndAddUnsafe(S, g, w);
  function oe(S) {
    let g = e.secp256k1.utils.normPrivateKeyToScalar(S), w = re.fromPrivateKey(g);
    return { scalar: w.hasEvenY() ? g : D(-g), bytes: j(w) };
  }
  function U(S) {
    if (!B(S))
      throw new Error("bad x: need 0 < x < p");
    const g = q(S * S), w = q(g * S + BigInt(7));
    let d = m(w);
    d % b !== M && (d = q(-d));
    const R = new re(S, d, f);
    return R.assertValidity(), R;
  }
  function y(...S) {
    return D((0, r.bytesToNumberBE)(k("BIP0340/challenge", ...S)));
  }
  function p(S) {
    return oe(S).bytes;
  }
  function a(S, g, w = (0, n.randomBytes)(32)) {
    const d = (0, r.ensureBytes)("message", S), { bytes: R, scalar: G } = oe(g), fe = (0, r.ensureBytes)("auxRand", w, 32), z = N(G ^ (0, r.bytesToNumberBE)(k("BIP0340/aux", fe))), V = k("BIP0340/nonce", z, R, d), F = D((0, r.bytesToNumberBE)(V));
    if (F === M)
      throw new Error("sign failed: k is zero");
    const { bytes: ee, scalar: he } = oe(F), Z = y(ee, R, d), K = new Uint8Array(64);
    if (K.set(ee, 0), K.set(N(D(he + Z * G)), 32), !l(K, d, R))
      throw new Error("sign: Invalid signature produced");
    return K;
  }
  function l(S, g, w) {
    const d = (0, r.ensureBytes)("signature", S, 64), R = (0, r.ensureBytes)("message", g), G = (0, r.ensureBytes)("publicKey", w, 32);
    try {
      const fe = U((0, r.bytesToNumberBE)(G)), z = (0, r.bytesToNumberBE)(d.subarray(0, 32));
      if (!B(z))
        return !1;
      const V = (0, r.bytesToNumberBE)(d.subarray(32, 64));
      if (!I(V))
        return !1;
      const F = y(N(z), j(fe), R), ee = te(fe, V, D(-F));
      return !(!ee || !ee.hasEvenY() || ee.toAffine().x !== z);
    } catch {
      return !1;
    }
  }
  e.schnorr = (() => ({
    getPublicKey: p,
    sign: a,
    verify: l,
    utils: {
      randomPrivateKey: e.secp256k1.utils.randomPrivateKey,
      lift_x: U,
      pointToBytes: j,
      numberToBytesBE: r.numberToBytesBE,
      bytesToNumberBE: r.bytesToNumberBE,
      taggedHash: k,
      mod: i.mod
    }
  }))();
  const _ = /* @__PURE__ */ (() => (0, o.isogenyMap)(E, [
    // xNum
    [
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
      "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
      "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    // xDen
    [
      "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
      "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
      // LAST 1
    ],
    // yNum
    [
      "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
      "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
      "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
      "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    // yDen
    [
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
      "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
      "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
      // LAST 1
    ]
  ].map((S) => S.map((g) => BigInt(g)))))(), x = /* @__PURE__ */ (() => (0, s.mapToCurveSimpleSWU)(E, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: E.create(BigInt("-11"))
  }))(), A = /* @__PURE__ */ (() => (0, o.createHasher)(e.secp256k1.ProjectivePoint, (S) => {
    const { x: g, y: w } = x(E.create(S[0]));
    return _(g, w);
  }, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: E.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: t.sha256
  }))();
  e.hashToCurve = (() => A.hashToCurve)(), e.encodeToCurve = (() => A.encodeToCurve)();
})(Pv);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.secp256k1 = void 0;
  var t = Pv;
  Object.defineProperty(e, "secp256k1", { enumerable: !0, get: function() {
    return t.secp256k1;
  } });
})(Xa);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MAX_WITHDRAWALS_PER_PAYLOAD = e.RLP_EMPTY_STRING = e.KECCAK256_RLP = e.KECCAK256_RLP_S = e.KECCAK256_RLP_ARRAY = e.KECCAK256_RLP_ARRAY_S = e.KECCAK256_NULL = e.KECCAK256_NULL_S = e.TWO_POW256 = e.SECP256K1_ORDER_DIV_2 = e.SECP256K1_ORDER = e.MAX_INTEGER_BIGINT = e.MAX_INTEGER = e.MAX_UINT64 = void 0;
  const t = dr, n = Xa;
  e.MAX_UINT64 = BigInt("0xffffffffffffffff"), e.MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), e.MAX_INTEGER_BIGINT = BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935"), e.SECP256K1_ORDER = n.secp256k1.CURVE.n, e.SECP256K1_ORDER_DIV_2 = n.secp256k1.CURVE.n / BigInt(2), e.TWO_POW256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"), e.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470", e.KECCAK256_NULL = t.Buffer.from(e.KECCAK256_NULL_S, "hex"), e.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347", e.KECCAK256_RLP_ARRAY = t.Buffer.from(e.KECCAK256_RLP_ARRAY_S, "hex"), e.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", e.KECCAK256_RLP = t.Buffer.from(e.KECCAK256_RLP_S, "hex"), e.RLP_EMPTY_STRING = t.Buffer.from([128]), e.MAX_WITHDRAWALS_PER_PAYLOAD = 16;
})(Wa);
var nf = {};
Object.defineProperty(nf, "__esModule", { value: !0 });
nf.GWEI_TO_WEI = void 0;
nf.GWEI_TO_WEI = BigInt(1e9);
var Xc = {}, Zr = {};
Object.defineProperty(Zr, "__esModule", { value: !0 });
Zr.RLP = Zr.utils = Zr.decode = Zr.encode = void 0;
function Yc(e) {
  if (Array.isArray(e)) {
    const n = [];
    let i = 0;
    for (let s = 0; s < e.length; s++) {
      const r = Yc(e[s]);
      n.push(r), i += r.length;
    }
    return lc(Sh(i, 192), ...n);
  }
  const t = rb(e);
  return t.length === 1 && t[0] < 128 ? t : lc(Sh(t.length, 128), t);
}
Zr.encode = Yc;
function qn(e, t, n) {
  if (n > e.length)
    throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
  return e.slice(t, n);
}
function Eh(e) {
  if (e[0] === 0)
    throw new Error("invalid RLP: extra zeros");
  return Qv(Yv(e));
}
function Sh(e, t) {
  if (e < 56)
    return Uint8Array.from([e + t]);
  const n = dc(e), i = n.length / 2, s = dc(t + 55 + i);
  return Uint8Array.from(xa(s + n));
}
function Xv(e, t = !1) {
  if (typeof e > "u" || e === null || e.length === 0)
    return Uint8Array.from([]);
  const n = rb(e), i = hc(n);
  if (t)
    return i;
  if (i.remainder.length !== 0)
    throw new Error("invalid RLP: remainder must be zero");
  return i.data;
}
Zr.decode = Xv;
function hc(e) {
  let t, n, i, s, r;
  const o = [], u = e[0];
  if (u <= 127)
    return {
      data: e.slice(0, 1),
      remainder: e.slice(1)
    };
  if (u <= 183) {
    if (t = u - 127, u === 128 ? i = Uint8Array.from([]) : i = qn(e, 1, t), t === 2 && i[0] < 128)
      throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
    return {
      data: i,
      remainder: e.slice(t)
    };
  } else if (u <= 191) {
    if (n = u - 182, e.length - 1 < n)
      throw new Error("invalid RLP: not enough bytes for string length");
    if (t = Eh(qn(e, 1, n)), t <= 55)
      throw new Error("invalid RLP: expected string length to be greater than 55");
    return i = qn(e, n, t + n), {
      data: i,
      remainder: e.slice(t + n)
    };
  } else if (u <= 247) {
    for (t = u - 191, s = qn(e, 1, t); s.length; )
      r = hc(s), o.push(r.data), s = r.remainder;
    return {
      data: o,
      remainder: e.slice(t)
    };
  } else {
    if (n = u - 246, t = Eh(qn(e, 1, n)), t < 56)
      throw new Error("invalid RLP: encoded list too short");
    const c = n + t;
    if (c > e.length)
      throw new Error("invalid RLP: total length is larger than the data");
    for (s = qn(e, n, c); s.length; )
      r = hc(s), o.push(r.data), s = r.remainder;
    return {
      data: o,
      remainder: e.slice(c)
    };
  }
}
const Vw = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Yv(e) {
  let t = "";
  for (let n = 0; n < e.length; n++)
    t += Vw[e[n]];
  return t;
}
function Qv(e) {
  const t = Number.parseInt(e, 16);
  if (Number.isNaN(t))
    throw new Error("Invalid byte sequence");
  return t;
}
function xa(e) {
  if (typeof e != "string")
    throw new TypeError("hexToBytes: expected string, got " + typeof e);
  if (e.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const t = new Uint8Array(e.length / 2);
  for (let n = 0; n < t.length; n++) {
    const i = n * 2;
    t[n] = Qv(e.slice(i, i + 2));
  }
  return t;
}
function lc(...e) {
  if (e.length === 1)
    return e[0];
  const t = e.reduce((i, s) => i + s.length, 0), n = new Uint8Array(t);
  for (let i = 0, s = 0; i < e.length; i++) {
    const r = e[i];
    n.set(r, s), s += r.length;
  }
  return n;
}
function eb(e) {
  return new TextEncoder().encode(e);
}
function dc(e) {
  if (e < 0)
    throw new Error("Invalid integer as argument, must be unsigned!");
  const t = e.toString(16);
  return t.length % 2 ? `0${t}` : t;
}
function Kw(e) {
  return e.length % 2 ? `0${e}` : e;
}
function tb(e) {
  return e.length >= 2 && e[0] === "0" && e[1] === "x";
}
function Zw(e) {
  return typeof e != "string" ? e : tb(e) ? e.slice(2) : e;
}
function rb(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return tb(e) ? xa(Kw(Zw(e))) : eb(e);
  if (typeof e == "number" || typeof e == "bigint")
    return e ? xa(dc(e)) : Uint8Array.from([]);
  if (e == null)
    return Uint8Array.from([]);
  throw new Error("toBytes: received unsupported type " + typeof e);
}
Zr.utils = {
  bytesToHex: Yv,
  concatBytes: lc,
  hexToBytes: xa,
  utf8ToBytes: eb
};
Zr.RLP = { encode: Yc, decode: Xv };
var Rr = {}, Lt = {}, nb = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.add = e.toBig = e.split = e.fromBig = void 0;
  const t = BigInt(2 ** 32 - 1), n = BigInt(32);
  function i(oe, U = !1) {
    return U ? { h: Number(oe & t), l: Number(oe >> n & t) } : { h: Number(oe >> n & t) | 0, l: Number(oe & t) | 0 };
  }
  e.fromBig = i;
  function s(oe, U = !1) {
    let y = new Uint32Array(oe.length), p = new Uint32Array(oe.length);
    for (let a = 0; a < oe.length; a++) {
      const { h: l, l: _ } = i(oe[a], U);
      [y[a], p[a]] = [l, _];
    }
    return [y, p];
  }
  e.split = s;
  const r = (oe, U) => BigInt(oe >>> 0) << n | BigInt(U >>> 0);
  e.toBig = r;
  const o = (oe, U, y) => oe >>> y, u = (oe, U, y) => oe << 32 - y | U >>> y, c = (oe, U, y) => oe >>> y | U << 32 - y, h = (oe, U, y) => oe << 32 - y | U >>> y, f = (oe, U, y) => oe << 64 - y | U >>> y - 32, b = (oe, U, y) => oe >>> y - 32 | U << 64 - y, v = (oe, U) => U, m = (oe, U) => oe, E = (oe, U, y) => oe << y | U >>> 32 - y, M = (oe, U, y) => U << y | oe >>> 32 - y, B = (oe, U, y) => U << y - 32 | oe >>> 64 - y, I = (oe, U, y) => oe << y - 32 | U >>> 64 - y;
  function T(oe, U, y, p) {
    const a = (U >>> 0) + (p >>> 0);
    return { h: oe + y + (a / 2 ** 32 | 0) | 0, l: a | 0 };
  }
  e.add = T;
  const k = (oe, U, y) => (oe >>> 0) + (U >>> 0) + (y >>> 0), j = (oe, U, y, p) => U + y + p + (oe / 2 ** 32 | 0) | 0, N = (oe, U, y, p) => (oe >>> 0) + (U >>> 0) + (y >>> 0) + (p >>> 0), q = (oe, U, y, p, a) => U + y + p + a + (oe / 2 ** 32 | 0) | 0, D = (oe, U, y, p, a) => (oe >>> 0) + (U >>> 0) + (y >>> 0) + (p >>> 0) + (a >>> 0), re = (oe, U, y, p, a, l) => U + y + p + a + l + (oe / 2 ** 32 | 0) | 0, te = {
    fromBig: i,
    split: s,
    toBig: e.toBig,
    shrSH: o,
    shrSL: u,
    rotrSH: c,
    rotrSL: h,
    rotrBH: f,
    rotrBL: b,
    rotr32H: v,
    rotr32L: m,
    rotlSH: E,
    rotlSL: M,
    rotlBH: B,
    rotlBL: I,
    add: T,
    add3L: k,
    add3H: j,
    add4L: N,
    add4H: q,
    add5H: re,
    add5L: D
  };
  e.default = te;
})(nb);
Object.defineProperty(Lt, "__esModule", { value: !0 });
Lt.shake256 = Lt.shake128 = Lt.keccak_512 = Lt.keccak_384 = Lt.keccak_256 = Lt.keccak_224 = Lt.sha3_512 = Lt.sha3_384 = Lt.sha3_256 = Lt.sha3_224 = Lt.Keccak = Lt.keccakP = void 0;
const Dn = Yt, Ri = nb, wi = rn, [ib, ab, fb] = [[], [], []], Gw = BigInt(0), bi = BigInt(1), Ww = BigInt(2), Jw = BigInt(7), Xw = BigInt(256), Yw = BigInt(113);
for (let e = 0, t = bi, n = 1, i = 0; e < 24; e++) {
  [n, i] = [i, (2 * n + 3 * i) % 5], ib.push(2 * (5 * i + n)), ab.push((e + 1) * (e + 2) / 2 % 64);
  let s = Gw;
  for (let r = 0; r < 7; r++)
    t = (t << bi ^ (t >> Jw) * Yw) % Xw, t & Ww && (s ^= bi << (bi << BigInt(r)) - bi);
  fb.push(s);
}
const [Qw, e4] = Ri.default.split(fb, !0), Ah = (e, t, n) => n > 32 ? Ri.default.rotlBH(e, t, n) : Ri.default.rotlSH(e, t, n), Mh = (e, t, n) => n > 32 ? Ri.default.rotlBL(e, t, n) : Ri.default.rotlSL(e, t, n);
function ob(e, t = 24) {
  const n = new Uint32Array(10);
  for (let i = 24 - t; i < 24; i++) {
    for (let o = 0; o < 10; o++)
      n[o] = e[o] ^ e[o + 10] ^ e[o + 20] ^ e[o + 30] ^ e[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const u = (o + 8) % 10, c = (o + 2) % 10, h = n[c], f = n[c + 1], b = Ah(h, f, 1) ^ n[u], v = Mh(h, f, 1) ^ n[u + 1];
      for (let m = 0; m < 50; m += 10)
        e[o + m] ^= b, e[o + m + 1] ^= v;
    }
    let s = e[2], r = e[3];
    for (let o = 0; o < 24; o++) {
      const u = ab[o], c = Ah(s, r, u), h = Mh(s, r, u), f = ib[o];
      s = e[f], r = e[f + 1], e[f] = c, e[f + 1] = h;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let u = 0; u < 10; u++)
        n[u] = e[o + u];
      for (let u = 0; u < 10; u++)
        e[o + u] ^= ~n[(u + 2) % 10] & n[(u + 4) % 10];
    }
    e[0] ^= Qw[i], e[1] ^= e4[i];
  }
  n.fill(0);
}
Lt.keccakP = ob;
class Di extends wi.Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, n, i, s = !1, r = 24) {
    if (super(), this.blockLen = t, this.suffix = n, this.outputLen = i, this.enableXOF = s, this.rounds = r, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, Dn.default.number(i), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = (0, wi.u32)(this.state);
  }
  keccak() {
    ob(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    Dn.default.exists(this);
    const { blockLen: n, state: i } = this;
    t = (0, wi.toBytes)(t);
    const s = t.length;
    for (let r = 0; r < s; ) {
      const o = Math.min(n - this.pos, s - r);
      for (let u = 0; u < o; u++)
        i[this.pos++] ^= t[r++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: n, pos: i, blockLen: s } = this;
    t[i] ^= n, n & 128 && i === s - 1 && this.keccak(), t[s - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    Dn.default.exists(this, !1), Dn.default.bytes(t), this.finish();
    const n = this.state, { blockLen: i } = this;
    for (let s = 0, r = t.length; s < r; ) {
      this.posOut >= i && this.keccak();
      const o = Math.min(i - this.posOut, r - s);
      t.set(n.subarray(this.posOut, this.posOut + o), s), this.posOut += o, s += o;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return Dn.default.number(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (Dn.default.output(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: n, suffix: i, outputLen: s, rounds: r, enableXOF: o } = this;
    return t || (t = new Di(n, i, s, o, r)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = r, t.suffix = i, t.outputLen = s, t.enableXOF = o, t.destroyed = this.destroyed, t;
  }
}
Lt.Keccak = Di;
const bn = (e, t, n) => (0, wi.wrapConstructor)(() => new Di(t, e, n));
Lt.sha3_224 = bn(6, 144, 224 / 8);
Lt.sha3_256 = bn(6, 136, 256 / 8);
Lt.sha3_384 = bn(6, 104, 384 / 8);
Lt.sha3_512 = bn(6, 72, 512 / 8);
Lt.keccak_224 = bn(1, 144, 224 / 8);
Lt.keccak_256 = bn(1, 136, 256 / 8);
Lt.keccak_384 = bn(1, 104, 384 / 8);
Lt.keccak_512 = bn(1, 72, 512 / 8);
const sb = (e, t, n) => (0, wi.wrapXOFConstructorWithOpts)((i = {}) => new Di(t, e, i.dkLen === void 0 ? n : i.dkLen, !0));
Lt.shake128 = sb(31, 168, 128 / 8);
Lt.shake256 = sb(31, 136, 256 / 8);
function pc(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Ea = { exports: {} };
Ea.exports;
(function(e, t) {
  var n = Ze && Ze.__importDefault || function(v) {
    return v && v.__esModule ? v : { default: v };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.crypto = t.wrapHash = t.equalsBytes = t.hexToBytes = t.bytesToUtf8 = t.utf8ToBytes = t.createView = t.concatBytes = t.toHex = t.bytesToHex = t.assertBytes = t.assertBool = void 0;
  const i = n(Yt), s = rn, r = i.default.bool;
  t.assertBool = r;
  const o = i.default.bytes;
  t.assertBytes = o;
  var u = rn;
  Object.defineProperty(t, "bytesToHex", { enumerable: !0, get: function() {
    return u.bytesToHex;
  } }), Object.defineProperty(t, "toHex", { enumerable: !0, get: function() {
    return u.bytesToHex;
  } }), Object.defineProperty(t, "concatBytes", { enumerable: !0, get: function() {
    return u.concatBytes;
  } }), Object.defineProperty(t, "createView", { enumerable: !0, get: function() {
    return u.createView;
  } }), Object.defineProperty(t, "utf8ToBytes", { enumerable: !0, get: function() {
    return u.utf8ToBytes;
  } });
  function c(v) {
    if (!(v instanceof Uint8Array))
      throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof v}`);
    return new TextDecoder().decode(v);
  }
  t.bytesToUtf8 = c;
  function h(v) {
    const m = v.startsWith("0x") ? v.substring(2) : v;
    return (0, s.hexToBytes)(m);
  }
  t.hexToBytes = h;
  function f(v, m) {
    if (v.length !== m.length)
      return !1;
    for (let E = 0; E < v.length; E++)
      if (v[E] !== m[E])
        return !1;
    return !0;
  }
  t.equalsBytes = f;
  function b(v) {
    return (m) => (i.default.bytes(m), v(m));
  }
  t.wrapHash = b, t.crypto = (() => {
    const v = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0, m = typeof pc == "function" && pc.bind(e);
    return {
      node: m && !v ? m("crypto") : void 0,
      web: v
    };
  })();
})(Ea, Ea.exports);
var ub = Ea.exports;
Object.defineProperty(Rr, "__esModule", { value: !0 });
Rr.keccak512 = Rr.keccak384 = Rr.keccak256 = Rr.keccak224 = void 0;
const Bi = Lt, af = ub;
Rr.keccak224 = (0, af.wrapHash)(Bi.keccak_224);
Rr.keccak256 = (() => {
  const e = (0, af.wrapHash)(Bi.keccak_256);
  return e.create = Bi.keccak_256.create, e;
})();
Rr.keccak384 = (0, af.wrapHash)(Bi.keccak_384);
Rr.keccak512 = (0, af.wrapHash)(Bi.keccak_512);
var Cn = {}, Br = {}, kt = {};
Object.defineProperty(kt, "__esModule", { value: !0 });
kt.isHexString = kt.getKeys = kt.fromAscii = kt.fromUtf8 = kt.toAscii = kt.arrayContainsArray = kt.getBinarySize = kt.padToEven = kt.stripHexPrefix = kt.isHexPrefixed = void 0;
function cb(e) {
  if (typeof e != "string")
    throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof e}`);
  return e[0] === "0" && e[1] === "x";
}
kt.isHexPrefixed = cb;
const t4 = (e) => {
  if (typeof e != "string")
    throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof e}`);
  return cb(e) ? e.slice(2) : e;
};
kt.stripHexPrefix = t4;
function hb(e) {
  let t = e;
  if (typeof t != "string")
    throw new Error(`[padToEven] value must be type 'string', received ${typeof t}`);
  return t.length % 2 && (t = `0${t}`), t;
}
kt.padToEven = hb;
function r4(e) {
  if (typeof e != "string")
    throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof e}`);
  return Buffer.byteLength(e, "utf8");
}
kt.getBinarySize = r4;
function n4(e, t, n) {
  if (Array.isArray(e) !== !0)
    throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof e}'`);
  if (Array.isArray(t) !== !0)
    throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof t}'`);
  return t[n === !0 ? "some" : "every"]((i) => e.indexOf(i) >= 0);
}
kt.arrayContainsArray = n4;
function i4(e) {
  let t = "", n = 0;
  const i = e.length;
  for (e.substring(0, 2) === "0x" && (n = 2); n < i; n += 2) {
    const s = parseInt(e.substr(n, 2), 16);
    t += String.fromCharCode(s);
  }
  return t;
}
kt.toAscii = i4;
function a4(e) {
  const t = Buffer.from(e, "utf8");
  return `0x${hb(t.toString("hex")).replace(/^0+|0+$/g, "")}`;
}
kt.fromUtf8 = a4;
function f4(e) {
  let t = "";
  for (let n = 0; n < e.length; n++) {
    const s = e.charCodeAt(n).toString(16);
    t += s.length < 2 ? `0${s}` : s;
  }
  return `0x${t}`;
}
kt.fromAscii = f4;
function o4(e, t, n) {
  if (!Array.isArray(e))
    throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof e}`);
  if (typeof t != "string")
    throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof e}`);
  const i = [];
  for (let s = 0; s < e.length; s++) {
    let r = e[s][t];
    if (n === !0 && !r)
      r = "";
    else if (typeof r != "string")
      throw new Error(`invalid abi - expected type 'string', received ${typeof r}`);
    i.push(r);
  }
  return i;
}
kt.getKeys = o4;
function s4(e, t) {
  return !(typeof e != "string" || !e.match(/^0x[0-9A-Fa-f]*$/) || typeof t < "u" && t > 0 && e.length !== 2 + 2 * t);
}
kt.isHexString = s4;
Object.defineProperty(Br, "__esModule", { value: !0 });
Br.assertIsString = Br.assertIsArray = Br.assertIsBuffer = Br.assertIsHexString = void 0;
const u4 = kt, c4 = function(e) {
  if (!(0, u4.isHexString)(e)) {
    const t = `This method only supports 0x-prefixed hex strings but input was: ${e}`;
    throw new Error(t);
  }
};
Br.assertIsHexString = c4;
const h4 = function(e) {
  if (!Buffer.isBuffer(e)) {
    const t = `This method only supports Buffer but input was: ${e}`;
    throw new Error(t);
  }
};
Br.assertIsBuffer = h4;
const l4 = function(e) {
  if (!Array.isArray(e)) {
    const t = `This method only supports number arrays but input was: ${e}`;
    throw new Error(t);
  }
};
Br.assertIsArray = l4;
const d4 = function(e) {
  if (typeof e != "string") {
    const t = `This method only supports strings but input was: ${e}`;
    throw new Error(t);
  }
};
Br.assertIsString = d4;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.intToUnpaddedBuffer = e.bigIntToUnpaddedBuffer = e.bigIntToHex = e.bufArrToArr = e.arrToBufArr = e.validateNoLeadingZeroes = e.baToJSON = e.toUtf8 = e.short = e.addHexPrefix = e.toUnsigned = e.fromSigned = e.bufferToInt = e.bigIntToBuffer = e.bufferToBigInt = e.bufferToHex = e.toBuffer = e.unpadHexString = e.unpadArray = e.unpadBuffer = e.setLengthRight = e.setLengthLeft = e.zeros = e.intToBuffer = e.intToHex = void 0;
  const t = Br, n = kt, i = function(a) {
    if (!Number.isSafeInteger(a) || a < 0)
      throw new Error(`Received an invalid integer type: ${a}`);
    return `0x${a.toString(16)}`;
  };
  e.intToHex = i;
  const s = function(a) {
    const l = (0, e.intToHex)(a);
    return Buffer.from((0, n.padToEven)(l.slice(2)), "hex");
  };
  e.intToBuffer = s;
  const r = function(a) {
    return Buffer.allocUnsafe(a).fill(0);
  };
  e.zeros = r;
  const o = function(a, l, _) {
    const x = (0, e.zeros)(l);
    return _ ? a.length < l ? (a.copy(x), x) : a.slice(0, l) : a.length < l ? (a.copy(x, l - a.length), x) : a.slice(-l);
  }, u = function(a, l) {
    return (0, t.assertIsBuffer)(a), o(a, l, !1);
  };
  e.setLengthLeft = u;
  const c = function(a, l) {
    return (0, t.assertIsBuffer)(a), o(a, l, !0);
  };
  e.setLengthRight = c;
  const h = function(a) {
    let l = a[0];
    for (; a.length > 0 && l.toString() === "0"; )
      a = a.slice(1), l = a[0];
    return a;
  }, f = function(a) {
    return (0, t.assertIsBuffer)(a), h(a);
  };
  e.unpadBuffer = f;
  const b = function(a) {
    return (0, t.assertIsArray)(a), h(a);
  };
  e.unpadArray = b;
  const v = function(a) {
    return (0, t.assertIsHexString)(a), a = (0, n.stripHexPrefix)(a), "0x" + h(a);
  };
  e.unpadHexString = v;
  const m = function(a) {
    if (a == null)
      return Buffer.allocUnsafe(0);
    if (Buffer.isBuffer(a) || Array.isArray(a) || a instanceof Uint8Array)
      return Buffer.from(a);
    if (typeof a == "string") {
      if (!(0, n.isHexString)(a))
        throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${a}`);
      return Buffer.from((0, n.padToEven)((0, n.stripHexPrefix)(a)), "hex");
    }
    if (typeof a == "number")
      return (0, e.intToBuffer)(a);
    if (typeof a == "bigint") {
      if (a < BigInt(0))
        throw new Error(`Cannot convert negative bigint to buffer. Given: ${a}`);
      let l = a.toString(16);
      return l.length % 2 && (l = "0" + l), Buffer.from(l, "hex");
    }
    if (a.toArray)
      return Buffer.from(a.toArray());
    if (a.toBuffer)
      return Buffer.from(a.toBuffer());
    throw new Error("invalid type");
  };
  e.toBuffer = m;
  const E = function(a) {
    return a = (0, e.toBuffer)(a), "0x" + a.toString("hex");
  };
  e.bufferToHex = E;
  function M(a) {
    const l = (0, e.bufferToHex)(a);
    return BigInt(l === "0x" ? 0 : l);
  }
  e.bufferToBigInt = M;
  function B(a) {
    return (0, e.toBuffer)("0x" + a.toString(16));
  }
  e.bigIntToBuffer = B;
  const I = function(a) {
    const l = Number(M(a));
    if (!Number.isSafeInteger(l))
      throw new Error("Number exceeds 53 bits");
    return l;
  };
  e.bufferToInt = I;
  const T = function(a) {
    return BigInt.asIntN(256, M(a));
  };
  e.fromSigned = T;
  const k = function(a) {
    return B(BigInt.asUintN(256, a));
  };
  e.toUnsigned = k;
  const j = function(a) {
    return typeof a != "string" || (0, n.isHexPrefixed)(a) ? a : "0x" + a;
  };
  e.addHexPrefix = j;
  function N(a, l = 50) {
    const _ = Buffer.isBuffer(a) ? a.toString("hex") : a;
    return _.length <= l ? _ : _.slice(0, l) + "";
  }
  e.short = N;
  const q = function(a) {
    const l = /^(00)+|(00)+$/g;
    if (a = (0, n.stripHexPrefix)(a), a.length % 2 !== 0)
      throw new Error("Invalid non-even hex string input for toUtf8() provided");
    return Buffer.from(a.replace(l, ""), "hex").toString("utf8");
  };
  e.toUtf8 = q;
  const D = function(a) {
    if (Buffer.isBuffer(a))
      return `0x${a.toString("hex")}`;
    if (a instanceof Array) {
      const l = [];
      for (let _ = 0; _ < a.length; _++)
        l.push((0, e.baToJSON)(a[_]));
      return l;
    }
  };
  e.baToJSON = D;
  const re = function(a) {
    for (const [l, _] of Object.entries(a))
      if (_ !== void 0 && _.length > 0 && _[0] === 0)
        throw new Error(`${l} cannot have leading zeroes, received: ${_.toString("hex")}`);
  };
  e.validateNoLeadingZeroes = re;
  function te(a) {
    return Array.isArray(a) ? a.map((l) => te(l)) : Buffer.from(a);
  }
  e.arrToBufArr = te;
  function oe(a) {
    return Array.isArray(a) ? a.map((l) => oe(l)) : Uint8Array.from(a ?? []);
  }
  e.bufArrToArr = oe;
  const U = (a) => "0x" + a.toString(16);
  e.bigIntToHex = U;
  function y(a) {
    return (0, e.unpadBuffer)(B(a));
  }
  e.bigIntToUnpaddedBuffer = y;
  function p(a) {
    return (0, e.unpadBuffer)((0, e.intToBuffer)(a));
  }
  e.intToUnpaddedBuffer = p;
})(Cn);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.accountBodyToRLP = e.accountBodyToSlim = e.accountBodyFromSlim = e.isZeroAddress = e.zeroAddress = e.importPublic = e.privateToAddress = e.privateToPublic = e.publicToAddress = e.pubToAddress = e.isValidPublic = e.isValidPrivate = e.generateAddress2 = e.generateAddress = e.isValidChecksumAddress = e.toChecksumAddress = e.isValidAddress = e.Account = void 0;
  const t = Zr, n = Rr, i = Xa, s = ub, r = Cn, o = Wa, u = Br, c = kt, h = BigInt(0);
  class f {
    /**
     * This constructor assigns and validates the values.
     * Use the static factory methods to assist in creating an Account from varying data types.
     */
    constructor(p = h, a = h, l = o.KECCAK256_RLP, _ = o.KECCAK256_NULL) {
      this.nonce = p, this.balance = a, this.storageRoot = l, this.codeHash = _, this._validate();
    }
    static fromAccountData(p) {
      const { nonce: a, balance: l, storageRoot: _, codeHash: x } = p;
      return new f(a !== void 0 ? (0, r.bufferToBigInt)((0, r.toBuffer)(a)) : void 0, l !== void 0 ? (0, r.bufferToBigInt)((0, r.toBuffer)(l)) : void 0, _ !== void 0 ? (0, r.toBuffer)(_) : void 0, x !== void 0 ? (0, r.toBuffer)(x) : void 0);
    }
    static fromRlpSerializedAccount(p) {
      const a = (0, r.arrToBufArr)(t.RLP.decode(Uint8Array.from(p)));
      if (!Array.isArray(a))
        throw new Error("Invalid serialized account input. Must be array");
      return this.fromValuesArray(a);
    }
    static fromValuesArray(p) {
      const [a, l, _, x] = p;
      return new f((0, r.bufferToBigInt)(a), (0, r.bufferToBigInt)(l), _, x);
    }
    _validate() {
      if (this.nonce < h)
        throw new Error("nonce must be greater than zero");
      if (this.balance < h)
        throw new Error("balance must be greater than zero");
      if (this.storageRoot.length !== 32)
        throw new Error("storageRoot must have a length of 32");
      if (this.codeHash.length !== 32)
        throw new Error("codeHash must have a length of 32");
    }
    /**
     * Returns a Buffer Array of the raw Buffers for the account, in order.
     */
    raw() {
      return [
        (0, r.bigIntToUnpaddedBuffer)(this.nonce),
        (0, r.bigIntToUnpaddedBuffer)(this.balance),
        this.storageRoot,
        this.codeHash
      ];
    }
    /**
     * Returns the RLP serialization of the account as a `Buffer`.
     */
    serialize() {
      return Buffer.from(t.RLP.encode((0, r.bufArrToArr)(this.raw())));
    }
    /**
     * Returns a `Boolean` determining if the account is a contract.
     */
    isContract() {
      return !this.codeHash.equals(o.KECCAK256_NULL);
    }
    /**
     * Returns a `Boolean` determining if the account is empty complying to the definition of
     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):
     * "An account is considered empty when it has no code and zero nonce and zero balance."
     */
    isEmpty() {
      return this.balance === h && this.nonce === h && this.codeHash.equals(o.KECCAK256_NULL);
    }
  }
  e.Account = f;
  const b = function(y) {
    try {
      (0, u.assertIsString)(y);
    } catch {
      return !1;
    }
    return /^0x[0-9a-fA-F]{40}$/.test(y);
  };
  e.isValidAddress = b;
  const v = function(y, p) {
    (0, u.assertIsHexString)(y);
    const a = (0, c.stripHexPrefix)(y).toLowerCase();
    let l = "";
    p !== void 0 && (l = (0, r.bufferToBigInt)((0, r.toBuffer)(p)).toString() + "0x");
    const _ = Buffer.from(l + a, "utf8"), x = (0, s.bytesToHex)((0, n.keccak256)(_));
    let A = "0x";
    for (let S = 0; S < a.length; S++)
      parseInt(x[S], 16) >= 8 ? A += a[S].toUpperCase() : A += a[S];
    return A;
  };
  e.toChecksumAddress = v;
  const m = function(y, p) {
    return (0, e.isValidAddress)(y) && (0, e.toChecksumAddress)(y, p) === y;
  };
  e.isValidChecksumAddress = m;
  const E = function(y, p) {
    return (0, u.assertIsBuffer)(y), (0, u.assertIsBuffer)(p), (0, r.bufferToBigInt)(p) === BigInt(0) ? Buffer.from((0, n.keccak256)(t.RLP.encode((0, r.bufArrToArr)([y, null])))).slice(-20) : Buffer.from((0, n.keccak256)(t.RLP.encode((0, r.bufArrToArr)([y, p])))).slice(-20);
  };
  e.generateAddress = E;
  const M = function(y, p, a) {
    if ((0, u.assertIsBuffer)(y), (0, u.assertIsBuffer)(p), (0, u.assertIsBuffer)(a), y.length !== 20)
      throw new Error("Expected from to be of length 20");
    if (p.length !== 32)
      throw new Error("Expected salt to be of length 32");
    const l = (0, n.keccak256)(Buffer.concat([Buffer.from("ff", "hex"), y, p, (0, n.keccak256)(a)]));
    return (0, r.toBuffer)(l).slice(-20);
  };
  e.generateAddress2 = M;
  const B = function(y) {
    return i.secp256k1.utils.isValidPrivateKey(y);
  };
  e.isValidPrivate = B;
  const I = function(y, p = !1) {
    if ((0, u.assertIsBuffer)(y), y.length === 64)
      try {
        return i.secp256k1.ProjectivePoint.fromHex(Buffer.concat([Buffer.from([4]), y])), !0;
      } catch {
        return !1;
      }
    if (!p)
      return !1;
    try {
      return i.secp256k1.ProjectivePoint.fromHex(y), !0;
    } catch {
      return !1;
    }
  };
  e.isValidPublic = I;
  const T = function(y, p = !1) {
    if ((0, u.assertIsBuffer)(y), p && y.length !== 64 && (y = Buffer.from(i.secp256k1.ProjectivePoint.fromHex(y).toRawBytes(!1).slice(1))), y.length !== 64)
      throw new Error("Expected pubKey to be of length 64");
    return Buffer.from((0, n.keccak256)(y)).slice(-20);
  };
  e.pubToAddress = T, e.publicToAddress = e.pubToAddress;
  const k = function(y) {
    return (0, u.assertIsBuffer)(y), Buffer.from(i.secp256k1.ProjectivePoint.fromPrivateKey(y).toRawBytes(!1).slice(1));
  };
  e.privateToPublic = k;
  const j = function(y) {
    return (0, e.publicToAddress)((0, e.privateToPublic)(y));
  };
  e.privateToAddress = j;
  const N = function(y) {
    return (0, u.assertIsBuffer)(y), y.length !== 64 && (y = Buffer.from(i.secp256k1.ProjectivePoint.fromHex(y).toRawBytes(!1).slice(1))), y;
  };
  e.importPublic = N;
  const q = function() {
    const p = (0, r.zeros)(20);
    return (0, r.bufferToHex)(p);
  };
  e.zeroAddress = q;
  const D = function(y) {
    try {
      (0, u.assertIsString)(y);
    } catch {
      return !1;
    }
    return (0, e.zeroAddress)() === y;
  };
  e.isZeroAddress = D;
  function re(y) {
    const [p, a, l, _] = y;
    return [
      p,
      a,
      (0, r.arrToBufArr)(l).length === 0 ? o.KECCAK256_RLP : l,
      (0, r.arrToBufArr)(_).length === 0 ? o.KECCAK256_NULL : _
    ];
  }
  e.accountBodyFromSlim = re;
  const te = new Uint8Array(0);
  function oe(y) {
    const [p, a, l, _] = y;
    return [
      p,
      a,
      (0, r.arrToBufArr)(l).equals(o.KECCAK256_RLP) ? te : l,
      (0, r.arrToBufArr)(_).equals(o.KECCAK256_NULL) ? te : _
    ];
  }
  e.accountBodyToSlim = oe;
  function U(y, p = !0) {
    const a = p ? re(y) : y;
    return (0, r.arrToBufArr)(t.RLP.encode(a));
  }
  e.accountBodyToRLP = U;
})(Xc);
var $i = {};
Object.defineProperty($i, "__esModule", { value: !0 });
$i.Address = void 0;
const yi = Xc, Yi = Cn;
class Qr {
  constructor(t) {
    if (t.length !== 20)
      throw new Error("Invalid address length");
    this.buf = t;
  }
  /**
   * Returns the zero address.
   */
  static zero() {
    return new Qr((0, Yi.zeros)(20));
  }
  /**
   * Returns an Address object from a hex-encoded string.
   * @param str - Hex-encoded address
   */
  static fromString(t) {
    if (!(0, yi.isValidAddress)(t))
      throw new Error("Invalid address");
    return new Qr((0, Yi.toBuffer)(t));
  }
  /**
   * Returns an address for a given public key.
   * @param pubKey The two points of an uncompressed key
   */
  static fromPublicKey(t) {
    if (!Buffer.isBuffer(t))
      throw new Error("Public key should be Buffer");
    const n = (0, yi.pubToAddress)(t);
    return new Qr(n);
  }
  /**
   * Returns an address for a given private key.
   * @param privateKey A private key must be 256 bits wide
   */
  static fromPrivateKey(t) {
    if (!Buffer.isBuffer(t))
      throw new Error("Private key should be Buffer");
    const n = (0, yi.privateToAddress)(t);
    return new Qr(n);
  }
  /**
   * Generates an address for a newly created contract.
   * @param from The address which is creating this new address
   * @param nonce The nonce of the from account
   */
  static generate(t, n) {
    if (typeof n != "bigint")
      throw new Error("Expected nonce to be a bigint");
    return new Qr((0, yi.generateAddress)(t.buf, (0, Yi.bigIntToBuffer)(n)));
  }
  /**
   * Generates an address for a contract created using CREATE2.
   * @param from The address which is creating this new address
   * @param salt A salt
   * @param initCode The init code of the contract being created
   */
  static generate2(t, n, i) {
    if (!Buffer.isBuffer(n))
      throw new Error("Expected salt to be a Buffer");
    if (!Buffer.isBuffer(i))
      throw new Error("Expected initCode to be a Buffer");
    return new Qr((0, yi.generateAddress2)(t.buf, n, i));
  }
  /**
   * Is address equal to another.
   */
  equals(t) {
    return this.buf.equals(t.buf);
  }
  /**
   * Is address zero.
   */
  isZero() {
    return this.equals(Qr.zero());
  }
  /**
   * True if address is in the address range defined
   * by EIP-1352
   */
  isPrecompileOrSystemAddress() {
    const t = (0, Yi.bufferToBigInt)(this.buf), n = BigInt(0), i = BigInt("0xffff");
    return t >= n && t <= i;
  }
  /**
   * Returns hex encoding of address.
   */
  toString() {
    return "0x" + this.buf.toString("hex");
  }
  /**
   * Returns Buffer representation of address.
   */
  toBuffer() {
    return Buffer.from(this.buf);
  }
}
$i.Address = Qr;
var ff = {}, Qc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.toType = e.TypeOutput = void 0;
  const t = Cn, n = kt;
  var i;
  (function(r) {
    r[r.Number = 0] = "Number", r[r.BigInt = 1] = "BigInt", r[r.Buffer = 2] = "Buffer", r[r.PrefixedHexString = 3] = "PrefixedHexString";
  })(i = e.TypeOutput || (e.TypeOutput = {}));
  function s(r, o) {
    if (r === null)
      return null;
    if (r === void 0)
      return;
    if (typeof r == "string" && !(0, n.isHexString)(r))
      throw new Error(`A string must be provided with a 0x-prefix, given: ${r}`);
    if (typeof r == "number" && !Number.isSafeInteger(r))
      throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
    const u = (0, t.toBuffer)(r);
    switch (o) {
      case i.Buffer:
        return u;
      case i.BigInt:
        return (0, t.bufferToBigInt)(u);
      case i.Number: {
        const c = (0, t.bufferToBigInt)(u);
        if (c > BigInt(Number.MAX_SAFE_INTEGER))
          throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
        return Number(c);
      }
      case i.PrefixedHexString:
        return (0, t.bufferToHex)(u);
      default:
        throw new Error("unknown outputType");
    }
  }
  e.toType = s;
})(Qc);
Object.defineProperty(ff, "__esModule", { value: !0 });
ff.Withdrawal = void 0;
const Rh = $i, Uf = Cn, Ft = Qc;
class xi {
  /**
   * This constructor assigns and validates the values.
   * Use the static factory methods to assist in creating a Withdrawal object from varying data types.
   * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot
   */
  constructor(t, n, i, s) {
    this.index = t, this.validatorIndex = n, this.address = i, this.amount = s;
  }
  static fromWithdrawalData(t) {
    const { index: n, validatorIndex: i, address: s, amount: r } = t, o = (0, Ft.toType)(n, Ft.TypeOutput.BigInt), u = (0, Ft.toType)(i, Ft.TypeOutput.BigInt), c = new Rh.Address((0, Ft.toType)(s, Ft.TypeOutput.Buffer)), h = (0, Ft.toType)(r, Ft.TypeOutput.BigInt);
    return new xi(o, u, c, h);
  }
  static fromValuesArray(t) {
    if (t.length !== 4)
      throw Error(`Invalid withdrawalArray length expected=4 actual=${t.length}`);
    const [n, i, s, r] = t;
    return xi.fromWithdrawalData({ index: n, validatorIndex: i, address: s, amount: r });
  }
  /**
   * Convert a withdrawal to a buffer array
   * @param withdrawal the withdrawal to convert
   * @returns buffer array of the withdrawal
   */
  static toBufferArray(t) {
    const { index: n, validatorIndex: i, address: s, amount: r } = t, o = (0, Ft.toType)(n, Ft.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, Ft.toType)(n, Ft.TypeOutput.Buffer), u = (0, Ft.toType)(i, Ft.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, Ft.toType)(i, Ft.TypeOutput.Buffer);
    let c;
    s instanceof Rh.Address ? c = s.buf : c = (0, Ft.toType)(s, Ft.TypeOutput.Buffer);
    const h = (0, Ft.toType)(r, Ft.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, Ft.toType)(r, Ft.TypeOutput.Buffer);
    return [o, u, c, h];
  }
  raw() {
    return xi.toBufferArray(this);
  }
  toValue() {
    return {
      index: this.index,
      validatorIndex: this.validatorIndex,
      address: this.address.buf,
      amount: this.amount
    };
  }
  toJSON() {
    return {
      index: (0, Uf.bigIntToHex)(this.index),
      validatorIndex: (0, Uf.bigIntToHex)(this.validatorIndex),
      address: "0x" + this.address.buf.toString("hex"),
      amount: (0, Uf.bigIntToHex)(this.amount)
    };
  }
}
ff.Withdrawal = xi;
var ar = {};
Object.defineProperty(ar, "__esModule", { value: !0 });
ar.hashPersonalMessage = ar.isValidSignature = ar.fromRpcSig = ar.toCompactSig = ar.toRpcSig = ar.ecrecover = ar.ecsign = void 0;
const p4 = Rr, lb = Xa, sr = Cn, Ff = Wa, v4 = Br;
function b4(e, t, n) {
  const i = lb.secp256k1.sign(e, t), s = i.toCompactRawBytes(), r = Buffer.from(s.slice(0, 32)), o = Buffer.from(s.slice(32, 64)), u = n === void 0 ? BigInt(i.recovery + 27) : BigInt(i.recovery + 35) + BigInt(n) * BigInt(2);
  return { r, s: o, v: u };
}
ar.ecsign = b4;
function of(e, t) {
  return e === BigInt(0) || e === BigInt(1) ? e : t === void 0 ? e - BigInt(27) : e - (t * BigInt(2) + BigInt(35));
}
function sf(e) {
  return e === BigInt(0) || e === BigInt(1);
}
const y4 = function(e, t, n, i, s) {
  const r = Buffer.concat([(0, sr.setLengthLeft)(n, 32), (0, sr.setLengthLeft)(i, 32)], 64), o = of(t, s);
  if (!sf(o))
    throw new Error("Invalid signature v value");
  const c = lb.secp256k1.Signature.fromCompact(r).addRecoveryBit(Number(o)).recoverPublicKey(e);
  return Buffer.from(c.toRawBytes(!1).slice(1));
};
ar.ecrecover = y4;
const g4 = function(e, t, n, i) {
  const s = of(e, i);
  if (!sf(s))
    throw new Error("Invalid signature v value");
  return (0, sr.bufferToHex)(Buffer.concat([(0, sr.setLengthLeft)(t, 32), (0, sr.setLengthLeft)(n, 32), (0, sr.toBuffer)(e)]));
};
ar.toRpcSig = g4;
const m4 = function(e, t, n, i) {
  const s = of(e, i);
  if (!sf(s))
    throw new Error("Invalid signature v value");
  let r = n;
  return (e > BigInt(28) && e % BigInt(2) === BigInt(1) || e === BigInt(1) || e === BigInt(28)) && (r = Buffer.from(n), r[0] |= 128), (0, sr.bufferToHex)(Buffer.concat([(0, sr.setLengthLeft)(t, 32), (0, sr.setLengthLeft)(r, 32)]));
};
ar.toCompactSig = m4;
const _4 = function(e) {
  const t = (0, sr.toBuffer)(e);
  let n, i, s;
  if (t.length >= 65)
    n = t.slice(0, 32), i = t.slice(32, 64), s = (0, sr.bufferToBigInt)(t.slice(64));
  else if (t.length === 64)
    n = t.slice(0, 32), i = t.slice(32, 64), s = BigInt((0, sr.bufferToInt)(t.slice(32, 33)) >> 7), i[0] &= 127;
  else
    throw new Error("Invalid signature length");
  return s < 27 && (s = s + BigInt(27)), {
    v: s,
    r: n,
    s: i
  };
};
ar.fromRpcSig = _4;
const w4 = function(e, t, n, i = !0, s) {
  if (t.length !== 32 || n.length !== 32 || !sf(of(e, s)))
    return !1;
  const r = (0, sr.bufferToBigInt)(t), o = (0, sr.bufferToBigInt)(n);
  return !(r === BigInt(0) || r >= Ff.SECP256K1_ORDER || o === BigInt(0) || o >= Ff.SECP256K1_ORDER || i && o >= Ff.SECP256K1_ORDER_DIV_2);
};
ar.isValidSignature = w4;
const x4 = function(e) {
  (0, v4.assertIsBuffer)(e);
  const t = Buffer.from(`Ethereum Signed Message:
${e.length}`, "utf-8");
  return Buffer.from((0, p4.keccak256)(Buffer.concat([t, e])));
};
ar.hashPersonalMessage = x4;
var db = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.compactBytesToNibbles = e.bytesToNibbles = e.nibblesToCompactBytes = e.nibblesToBytes = e.hasTerminator = void 0;
  const t = (o) => o.length > 0 && o[o.length - 1] === 16;
  e.hasTerminator = t;
  const n = (o, u) => {
    for (let c = 0, h = 0; h < o.length; c += 1, h += 2)
      u[c] = o[h] << 4 | o[h + 1];
  };
  e.nibblesToBytes = n;
  const i = (o) => {
    let u = 0;
    (0, e.hasTerminator)(o) && (u = 1, o = o.subarray(0, o.length - 1));
    const c = new Uint8Array(o.length / 2 + 1);
    return c[0] = u << 5, (o.length & 1) === 1 && (c[0] |= 16, c[0] |= o[0], o = o.subarray(1)), (0, e.nibblesToBytes)(o, c.subarray(1)), c;
  };
  e.nibblesToCompactBytes = i;
  const s = (o) => {
    const u = o.length * 2 + 1, c = new Uint8Array(u);
    for (let h = 0; h < o.length; h++) {
      const f = o[h];
      c[h * 2] = f / 16, c[h * 2 + 1] = f % 16;
    }
    return c[u - 1] = 16, c;
  };
  e.bytesToNibbles = s;
  const r = (o) => {
    if (o.length === 0)
      return o;
    let u = (0, e.bytesToNibbles)(o);
    u[0] < 2 && (u = u.subarray(0, u.length - 1));
    const c = 2 - (u[0] & 1);
    return u.subarray(c);
  };
  e.compactBytesToNibbles = r;
})(db);
var uf = {};
Object.defineProperty(uf, "__esModule", { value: !0 });
uf.AsyncEventEmitter = void 0;
const E4 = ii;
async function S4(e, t, n) {
  let i;
  for await (const s of t)
    try {
      s.length < 2 ? s.call(e, n) : await new Promise((r, o) => {
        s.call(e, n, (u) => {
          u ? o(u) : r();
        });
      });
    } catch (r) {
      i = r;
    }
  if (i)
    throw i;
}
class A4 extends E4.EventEmitter {
  emit(t, ...n) {
    let [i, s] = n;
    const r = this;
    let o = r._events[t] ?? [];
    return s === void 0 && typeof i == "function" && (s = i, i = void 0), (t === "newListener" || t === "removeListener") && (i = {
      event: i,
      fn: s
    }, s = void 0), o = Array.isArray(o) ? o : [o], S4(r, o.slice(), i).then(s).catch(s), r.listenerCount(t) > 0;
  }
  once(t, n) {
    const i = this;
    let s;
    if (typeof n != "function")
      throw new TypeError("listener must be a function");
    return n.length >= 2 ? s = function(r, o) {
      i.removeListener(t, s), n(r, o);
    } : s = function(r) {
      i.removeListener(t, s), n(r, s);
    }, i.on(t, s), i;
  }
  first(t, n) {
    let i = this._events[t] ?? [];
    if (typeof n != "function")
      throw new TypeError("listener must be a function");
    return Array.isArray(i) || (this._events[t] = i = [i]), i.unshift(n), this;
  }
  before(t, n, i) {
    return this.beforeOrAfter(t, n, i);
  }
  after(t, n, i) {
    return this.beforeOrAfter(t, n, i, "after");
  }
  beforeOrAfter(t, n, i, s) {
    let r = this._events[t] ?? [], o, u;
    const c = s === "after" ? 1 : 0;
    if (typeof i != "function")
      throw new TypeError("listener must be a function");
    if (typeof n != "function")
      throw new TypeError("target must be a function");
    for (Array.isArray(r) || (this._events[t] = r = [r]), u = r.length, o = r.length; o--; )
      if (r[o] === n) {
        u = o + c;
        break;
      }
    return r.splice(u, 0, i), this;
  }
  on(t, n) {
    return super.on(t, n);
  }
  addListener(t, n) {
    return super.addListener(t, n);
  }
  prependListener(t, n) {
    return super.prependListener(t, n);
  }
  prependOnceListener(t, n) {
    return super.prependOnceListener(t, n);
  }
  removeAllListeners(t) {
    return super.removeAllListeners(t);
  }
  removeListener(t, n) {
    return super.removeListener(t, n);
  }
  eventNames() {
    return super.eventNames();
  }
  listeners(t) {
    return super.listeners(t);
  }
  listenerCount(t) {
    return super.listenerCount(t);
  }
  getMaxListeners() {
    return super.getMaxListeners();
  }
  setMaxListeners(t) {
    return super.setMaxListeners(t);
  }
}
uf.AsyncEventEmitter = A4;
var cf = {};
Object.defineProperty(cf, "__esModule", { value: !0 });
cf.Lock = void 0;
class M4 {
  constructor() {
    this.permits = 1, this.promiseResolverQueue = [];
  }
  /**
   * Returns a promise used to wait for a permit to become available. This method should be awaited on.
   * @returns  A promise that gets resolved when execution is allowed to proceed.
   */
  async acquire() {
    return this.permits > 0 ? (this.permits -= 1, Promise.resolve(!0)) : new Promise((t) => this.promiseResolverQueue.push(t));
  }
  /**
   * Increases the number of permits by one. If there are other functions waiting, one of them will
   * continue to execute in a future iteration of the event loop.
   */
  release() {
    if (this.permits += 1, this.permits > 1 && this.promiseResolverQueue.length > 0)
      console.warn("Lock.permits should never be > 0 when there is someone waiting.");
    else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {
      this.permits -= 1;
      const t = this.promiseResolverQueue.shift();
      t && t(!0);
    }
  }
}
cf.Lock = M4;
var ni = {}, In = {}, Hf = {}, zf = { exports: {} }, Vf = {}, Bh;
function pb() {
  return Bh || (Bh = 1, function(e) {
    e.fetch = s(Ze.fetch) && s(Ze.ReadableStream), e.writableStream = s(Ze.WritableStream), e.abortController = s(Ze.AbortController);
    var t;
    function n() {
      if (t !== void 0)
        return t;
      if (Ze.XMLHttpRequest) {
        t = new Ze.XMLHttpRequest();
        try {
          t.open("GET", Ze.XDomainRequest ? "/" : "https://example.com");
        } catch {
          t = null;
        }
      } else
        t = null;
      return t;
    }
    function i(r) {
      var o = n();
      if (!o)
        return !1;
      try {
        return o.responseType = r, o.responseType === r;
      } catch {
      }
      return !1;
    }
    e.arraybuffer = e.fetch || i("arraybuffer"), e.msstream = !e.fetch && i("ms-stream"), e.mozchunkedarraybuffer = !e.fetch && i("moz-chunked-arraybuffer"), e.overrideMimeType = e.fetch || (n() ? s(n().overrideMimeType) : !1);
    function s(r) {
      return typeof r == "function";
    }
    t = null;
  }(Vf)), Vf;
}
var Qi = { exports: {} }, Ih;
function mt() {
  return Ih || (Ih = 1, typeof Object.create == "function" ? Qi.exports = function(t, n) {
    n && (t.super_ = n, t.prototype = Object.create(n.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : Qi.exports = function(t, n) {
    if (n) {
      t.super_ = n;
      var i = function() {
      };
      i.prototype = n.prototype, t.prototype = new i(), t.prototype.constructor = t;
    }
  }), Qi.exports;
}
var ea = {}, ta = { exports: {} }, Kf, Th;
function vb() {
  return Th || (Th = 1, Kf = ii.EventEmitter), Kf;
}
var Zf = {}, Gf = {}, Wf, Oh;
function e0() {
  return Oh || (Oh = 1, Wf = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var t = {}, n = Symbol("test"), i = Object(n);
    if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]")
      return !1;
    var s = 42;
    t[n] = s;
    for (n in t)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
      return !1;
    var r = Object.getOwnPropertySymbols(t);
    if (r.length !== 1 || r[0] !== n || !Object.prototype.propertyIsEnumerable.call(t, n))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var o = Object.getOwnPropertyDescriptor(t, n);
      if (o.value !== s || o.enumerable !== !0)
        return !1;
    }
    return !0;
  }), Wf;
}
var Jf, Ph;
function t0() {
  if (Ph)
    return Jf;
  Ph = 1;
  var e = e0();
  return Jf = function() {
    return e() && !!Symbol.toStringTag;
  }, Jf;
}
var Xf, Ch;
function R4() {
  if (Ch)
    return Xf;
  Ch = 1;
  var e = typeof Symbol < "u" && Symbol, t = e0();
  return Xf = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, Xf;
}
var Yf, Nh;
function B4() {
  if (Nh)
    return Yf;
  Nh = 1;
  var e = {
    foo: {}
  }, t = Object;
  return Yf = function() {
    return { __proto__: e }.foo === e.foo && !({ __proto__: null } instanceof t);
  }, Yf;
}
var Qf, Lh;
function I4() {
  if (Lh)
    return Qf;
  Lh = 1;
  var e = "Function.prototype.bind called on incompatible ", t = Array.prototype.slice, n = Object.prototype.toString, i = "[object Function]";
  return Qf = function(r) {
    var o = this;
    if (typeof o != "function" || n.call(o) !== i)
      throw new TypeError(e + o);
    for (var u = t.call(arguments, 1), c, h = function() {
      if (this instanceof c) {
        var E = o.apply(
          this,
          u.concat(t.call(arguments))
        );
        return Object(E) === E ? E : this;
      } else
        return o.apply(
          r,
          u.concat(t.call(arguments))
        );
    }, f = Math.max(0, o.length - u.length), b = [], v = 0; v < f; v++)
      b.push("$" + v);
    if (c = Function("binder", "return function (" + b.join(",") + "){ return binder.apply(this,arguments); }")(h), o.prototype) {
      var m = function() {
      };
      m.prototype = o.prototype, c.prototype = new m(), m.prototype = null;
    }
    return c;
  }, Qf;
}
var eo, kh;
function r0() {
  if (kh)
    return eo;
  kh = 1;
  var e = I4();
  return eo = Function.prototype.bind || e, eo;
}
var to, jh;
function T4() {
  if (jh)
    return to;
  jh = 1;
  var e = r0();
  return to = e.call(Function.call, Object.prototype.hasOwnProperty), to;
}
var ro, qh;
function Ui() {
  if (qh)
    return ro;
  qh = 1;
  var e, t = SyntaxError, n = Function, i = TypeError, s = function(y) {
    try {
      return n('"use strict"; return (' + y + ").constructor;")();
    } catch {
    }
  }, r = Object.getOwnPropertyDescriptor;
  if (r)
    try {
      r({}, "");
    } catch {
      r = null;
    }
  var o = function() {
    throw new i();
  }, u = r ? function() {
    try {
      return arguments.callee, o;
    } catch {
      try {
        return r(arguments, "callee").get;
      } catch {
        return o;
      }
    }
  }() : o, c = R4()(), h = B4()(), f = Object.getPrototypeOf || (h ? function(y) {
    return y.__proto__;
  } : null), b = {}, v = typeof Uint8Array > "u" || !f ? e : f(Uint8Array), m = {
    "%AggregateError%": typeof AggregateError > "u" ? e : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? e : ArrayBuffer,
    "%ArrayIteratorPrototype%": c && f ? f([][Symbol.iterator]()) : e,
    "%AsyncFromSyncIteratorPrototype%": e,
    "%AsyncFunction%": b,
    "%AsyncGenerator%": b,
    "%AsyncGeneratorFunction%": b,
    "%AsyncIteratorPrototype%": b,
    "%Atomics%": typeof Atomics > "u" ? e : Atomics,
    "%BigInt%": typeof BigInt > "u" ? e : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? e : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? e : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? e : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array > "u" ? e : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? e : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? e : FinalizationRegistry,
    "%Function%": n,
    "%GeneratorFunction%": b,
    "%Int8Array%": typeof Int8Array > "u" ? e : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? e : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? e : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": c && f ? f(f([][Symbol.iterator]())) : e,
    "%JSON%": typeof JSON == "object" ? JSON : e,
    "%Map%": typeof Map > "u" ? e : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !c || !f ? e : f((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? e : Promise,
    "%Proxy%": typeof Proxy > "u" ? e : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect > "u" ? e : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? e : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !c || !f ? e : f((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? e : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": c && f ? f(""[Symbol.iterator]()) : e,
    "%Symbol%": c ? Symbol : e,
    "%SyntaxError%": t,
    "%ThrowTypeError%": u,
    "%TypedArray%": v,
    "%TypeError%": i,
    "%Uint8Array%": typeof Uint8Array > "u" ? e : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? e : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? e : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? e : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap > "u" ? e : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? e : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? e : WeakSet
  };
  if (f)
    try {
      null.error;
    } catch (y) {
      var E = f(f(y));
      m["%Error.prototype%"] = E;
    }
  var M = function y(p) {
    var a;
    if (p === "%AsyncFunction%")
      a = s("async function () {}");
    else if (p === "%GeneratorFunction%")
      a = s("function* () {}");
    else if (p === "%AsyncGeneratorFunction%")
      a = s("async function* () {}");
    else if (p === "%AsyncGenerator%") {
      var l = y("%AsyncGeneratorFunction%");
      l && (a = l.prototype);
    } else if (p === "%AsyncIteratorPrototype%") {
      var _ = y("%AsyncGenerator%");
      _ && f && (a = f(_.prototype));
    }
    return m[p] = a, a;
  }, B = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, I = r0(), T = T4(), k = I.call(Function.call, Array.prototype.concat), j = I.call(Function.apply, Array.prototype.splice), N = I.call(Function.call, String.prototype.replace), q = I.call(Function.call, String.prototype.slice), D = I.call(Function.call, RegExp.prototype.exec), re = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, te = /\\(\\)?/g, oe = function(p) {
    var a = q(p, 0, 1), l = q(p, -1);
    if (a === "%" && l !== "%")
      throw new t("invalid intrinsic syntax, expected closing `%`");
    if (l === "%" && a !== "%")
      throw new t("invalid intrinsic syntax, expected opening `%`");
    var _ = [];
    return N(p, re, function(x, A, S, g) {
      _[_.length] = S ? N(g, te, "$1") : A || x;
    }), _;
  }, U = function(p, a) {
    var l = p, _;
    if (T(B, l) && (_ = B[l], l = "%" + _[0] + "%"), T(m, l)) {
      var x = m[l];
      if (x === b && (x = M(l)), typeof x > "u" && !a)
        throw new i("intrinsic " + p + " exists, but is not available. Please file an issue!");
      return {
        alias: _,
        name: l,
        value: x
      };
    }
    throw new t("intrinsic " + p + " does not exist!");
  };
  return ro = function(p, a) {
    if (typeof p != "string" || p.length === 0)
      throw new i("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof a != "boolean")
      throw new i('"allowMissing" argument must be a boolean');
    if (D(/^%?[^%]*%?$/, p) === null)
      throw new t("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var l = oe(p), _ = l.length > 0 ? l[0] : "", x = U("%" + _ + "%", a), A = x.name, S = x.value, g = !1, w = x.alias;
    w && (_ = w[0], j(l, k([0, 1], w)));
    for (var d = 1, R = !0; d < l.length; d += 1) {
      var G = l[d], fe = q(G, 0, 1), z = q(G, -1);
      if ((fe === '"' || fe === "'" || fe === "`" || z === '"' || z === "'" || z === "`") && fe !== z)
        throw new t("property names with quotes must have matching quotes");
      if ((G === "constructor" || !R) && (g = !0), _ += "." + G, A = "%" + _ + "%", T(m, A))
        S = m[A];
      else if (S != null) {
        if (!(G in S)) {
          if (!a)
            throw new i("base intrinsic for " + p + " exists, but the property is not available.");
          return;
        }
        if (r && d + 1 >= l.length) {
          var V = r(S, G);
          R = !!V, R && "get" in V && !("originalValue" in V.get) ? S = V.get : S = S[G];
        } else
          R = T(S, G), S = S[G];
        R && !g && (m[A] = S);
      }
    }
    return S;
  }, ro;
}
var no = { exports: {} }, Dh;
function hf() {
  return Dh || (Dh = 1, function(e) {
    var t = r0(), n = Ui(), i = n("%Function.prototype.apply%"), s = n("%Function.prototype.call%"), r = n("%Reflect.apply%", !0) || t.call(s, i), o = n("%Object.getOwnPropertyDescriptor%", !0), u = n("%Object.defineProperty%", !0), c = n("%Math.max%");
    if (u)
      try {
        u({}, "a", { value: 1 });
      } catch {
        u = null;
      }
    e.exports = function(b) {
      var v = r(t, s, arguments);
      if (o && u) {
        var m = o(v, "length");
        m.configurable && u(
          v,
          "length",
          { value: 1 + c(0, b.length - (arguments.length - 1)) }
        );
      }
      return v;
    };
    var h = function() {
      return r(t, i, arguments);
    };
    u ? u(e.exports, "apply", { value: h }) : e.exports.apply = h;
  }(no)), no.exports;
}
var io, $h;
function lf() {
  if ($h)
    return io;
  $h = 1;
  var e = Ui(), t = hf(), n = t(e("String.prototype.indexOf"));
  return io = function(s, r) {
    var o = e(s, !!r);
    return typeof o == "function" && n(s, ".prototype.") > -1 ? t(o) : o;
  }, io;
}
var ao, Uh;
function O4() {
  if (Uh)
    return ao;
  Uh = 1;
  var e = t0()(), t = lf(), n = t("Object.prototype.toString"), i = function(u) {
    return e && u && typeof u == "object" && Symbol.toStringTag in u ? !1 : n(u) === "[object Arguments]";
  }, s = function(u) {
    return i(u) ? !0 : u !== null && typeof u == "object" && typeof u.length == "number" && u.length >= 0 && n(u) !== "[object Array]" && n(u.callee) === "[object Function]";
  }, r = function() {
    return i(arguments);
  }();
  return i.isLegacyArguments = s, ao = r ? i : s, ao;
}
var fo, Fh;
function P4() {
  if (Fh)
    return fo;
  Fh = 1;
  var e = Object.prototype.toString, t = Function.prototype.toString, n = /^\s*(?:function)?\*/, i = t0()(), s = Object.getPrototypeOf, r = function() {
    if (!i)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, o;
  return fo = function(c) {
    if (typeof c != "function")
      return !1;
    if (n.test(t.call(c)))
      return !0;
    if (!i) {
      var h = e.call(c);
      return h === "[object GeneratorFunction]";
    }
    if (!s)
      return !1;
    if (typeof o > "u") {
      var f = r();
      o = f ? s(f) : !1;
    }
    return s(c) === o;
  }, fo;
}
var oo, Hh;
function C4() {
  if (Hh)
    return oo;
  Hh = 1;
  var e = Function.prototype.toString, t = typeof Reflect == "object" && Reflect !== null && Reflect.apply, n, i;
  if (typeof t == "function" && typeof Object.defineProperty == "function")
    try {
      n = Object.defineProperty({}, "length", {
        get: function() {
          throw i;
        }
      }), i = {}, t(function() {
        throw 42;
      }, null, n);
    } catch (T) {
      T !== i && (t = null);
    }
  else
    t = null;
  var s = /^\s*class\b/, r = function(k) {
    try {
      var j = e.call(k);
      return s.test(j);
    } catch {
      return !1;
    }
  }, o = function(k) {
    try {
      return r(k) ? !1 : (e.call(k), !0);
    } catch {
      return !1;
    }
  }, u = Object.prototype.toString, c = "[object Object]", h = "[object Function]", f = "[object GeneratorFunction]", b = "[object HTMLAllCollection]", v = "[object HTML document.all class]", m = "[object HTMLCollection]", E = typeof Symbol == "function" && !!Symbol.toStringTag, M = !(0 in [,]), B = function() {
    return !1;
  };
  if (typeof document == "object") {
    var I = document.all;
    u.call(I) === u.call(document.all) && (B = function(k) {
      if ((M || !k) && (typeof k > "u" || typeof k == "object"))
        try {
          var j = u.call(k);
          return (j === b || j === v || j === m || j === c) && k("") == null;
        } catch {
        }
      return !1;
    });
  }
  return oo = t ? function(k) {
    if (B(k))
      return !0;
    if (!k || typeof k != "function" && typeof k != "object")
      return !1;
    try {
      t(k, null, n);
    } catch (j) {
      if (j !== i)
        return !1;
    }
    return !r(k) && o(k);
  } : function(k) {
    if (B(k))
      return !0;
    if (!k || typeof k != "function" && typeof k != "object")
      return !1;
    if (E)
      return o(k);
    if (r(k))
      return !1;
    var j = u.call(k);
    return j !== h && j !== f && !/^\[object HTML/.test(j) ? !1 : o(k);
  }, oo;
}
var so, zh;
function N4() {
  if (zh)
    return so;
  zh = 1;
  var e = C4(), t = Object.prototype.toString, n = Object.prototype.hasOwnProperty, i = function(c, h, f) {
    for (var b = 0, v = c.length; b < v; b++)
      n.call(c, b) && (f == null ? h(c[b], b, c) : h.call(f, c[b], b, c));
  }, s = function(c, h, f) {
    for (var b = 0, v = c.length; b < v; b++)
      f == null ? h(c.charAt(b), b, c) : h.call(f, c.charAt(b), b, c);
  }, r = function(c, h, f) {
    for (var b in c)
      n.call(c, b) && (f == null ? h(c[b], b, c) : h.call(f, c[b], b, c));
  }, o = function(c, h, f) {
    if (!e(h))
      throw new TypeError("iterator must be a function");
    var b;
    arguments.length >= 3 && (b = f), t.call(c) === "[object Array]" ? i(c, h, b) : typeof c == "string" ? s(c, h, b) : r(c, h, b);
  };
  return so = o, so;
}
var uo, Vh;
function L4() {
  if (Vh)
    return uo;
  Vh = 1;
  var e = [
    "BigInt64Array",
    "BigUint64Array",
    "Float32Array",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray"
  ], t = typeof globalThis > "u" ? Ze : globalThis;
  return uo = function() {
    for (var i = [], s = 0; s < e.length; s++)
      typeof t[e[s]] == "function" && (i[i.length] = e[s]);
    return i;
  }, uo;
}
var co, Kh;
function bb() {
  if (Kh)
    return co;
  Kh = 1;
  var e = Ui(), t = e("%Object.getOwnPropertyDescriptor%", !0);
  if (t)
    try {
      t([], "length");
    } catch {
      t = null;
    }
  return co = t, co;
}
var ho, Zh;
function yb() {
  if (Zh)
    return ho;
  Zh = 1;
  var e = N4(), t = L4(), n = hf(), i = lf(), s = bb(), r = i("Object.prototype.toString"), o = t0()(), u = typeof globalThis > "u" ? Ze : globalThis, c = t(), h = i("String.prototype.slice"), f = Object.getPrototypeOf, b = i("Array.prototype.indexOf", !0) || function(B, I) {
    for (var T = 0; T < B.length; T += 1)
      if (B[T] === I)
        return T;
    return -1;
  }, v = { __proto__: null };
  o && s && f ? e(c, function(M) {
    var B = new u[M]();
    if (Symbol.toStringTag in B) {
      var I = f(B), T = s(I, Symbol.toStringTag);
      if (!T) {
        var k = f(I);
        T = s(k, Symbol.toStringTag);
      }
      v["$" + M] = n(T.get);
    }
  }) : e(c, function(M) {
    var B = new u[M]();
    v["$" + M] = n(B.slice);
  });
  var m = function(B) {
    var I = !1;
    return e(v, function(T, k) {
      if (!I)
        try {
          "$" + T(B) === k && (I = h(k, 1));
        } catch {
        }
    }), I;
  }, E = function(B) {
    var I = !1;
    return e(v, function(T, k) {
      if (!I)
        try {
          T(B), I = h(k, 1);
        } catch {
        }
    }), I;
  };
  return ho = function(B) {
    if (!B || typeof B != "object")
      return !1;
    if (!o) {
      var I = h(r(B), 8, -1);
      return b(c, I) > -1 ? I : I !== "Object" ? !1 : E(B);
    }
    return s ? m(B) : null;
  }, ho;
}
var lo, Gh;
function k4() {
  if (Gh)
    return lo;
  Gh = 1;
  var e = yb();
  return lo = function(n) {
    return !!e(n);
  }, lo;
}
var Wh;
function j4() {
  return Wh || (Wh = 1, function(e) {
    var t = O4(), n = P4(), i = yb(), s = k4();
    function r(W) {
      return W.call.bind(W);
    }
    var o = typeof BigInt < "u", u = typeof Symbol < "u", c = r(Object.prototype.toString), h = r(Number.prototype.valueOf), f = r(String.prototype.valueOf), b = r(Boolean.prototype.valueOf);
    if (o)
      var v = r(BigInt.prototype.valueOf);
    if (u)
      var m = r(Symbol.prototype.valueOf);
    function E(W, de) {
      if (typeof W != "object")
        return !1;
      try {
        return de(W), !0;
      } catch {
        return !1;
      }
    }
    e.isArgumentsObject = t, e.isGeneratorFunction = n, e.isTypedArray = s;
    function M(W) {
      return typeof Promise < "u" && W instanceof Promise || W !== null && typeof W == "object" && typeof W.then == "function" && typeof W.catch == "function";
    }
    e.isPromise = M;
    function B(W) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(W) : s(W) || R(W);
    }
    e.isArrayBufferView = B;
    function I(W) {
      return i(W) === "Uint8Array";
    }
    e.isUint8Array = I;
    function T(W) {
      return i(W) === "Uint8ClampedArray";
    }
    e.isUint8ClampedArray = T;
    function k(W) {
      return i(W) === "Uint16Array";
    }
    e.isUint16Array = k;
    function j(W) {
      return i(W) === "Uint32Array";
    }
    e.isUint32Array = j;
    function N(W) {
      return i(W) === "Int8Array";
    }
    e.isInt8Array = N;
    function q(W) {
      return i(W) === "Int16Array";
    }
    e.isInt16Array = q;
    function D(W) {
      return i(W) === "Int32Array";
    }
    e.isInt32Array = D;
    function re(W) {
      return i(W) === "Float32Array";
    }
    e.isFloat32Array = re;
    function te(W) {
      return i(W) === "Float64Array";
    }
    e.isFloat64Array = te;
    function oe(W) {
      return i(W) === "BigInt64Array";
    }
    e.isBigInt64Array = oe;
    function U(W) {
      return i(W) === "BigUint64Array";
    }
    e.isBigUint64Array = U;
    function y(W) {
      return c(W) === "[object Map]";
    }
    y.working = typeof Map < "u" && y(/* @__PURE__ */ new Map());
    function p(W) {
      return typeof Map > "u" ? !1 : y.working ? y(W) : W instanceof Map;
    }
    e.isMap = p;
    function a(W) {
      return c(W) === "[object Set]";
    }
    a.working = typeof Set < "u" && a(/* @__PURE__ */ new Set());
    function l(W) {
      return typeof Set > "u" ? !1 : a.working ? a(W) : W instanceof Set;
    }
    e.isSet = l;
    function _(W) {
      return c(W) === "[object WeakMap]";
    }
    _.working = typeof WeakMap < "u" && _(/* @__PURE__ */ new WeakMap());
    function x(W) {
      return typeof WeakMap > "u" ? !1 : _.working ? _(W) : W instanceof WeakMap;
    }
    e.isWeakMap = x;
    function A(W) {
      return c(W) === "[object WeakSet]";
    }
    A.working = typeof WeakSet < "u" && A(/* @__PURE__ */ new WeakSet());
    function S(W) {
      return A(W);
    }
    e.isWeakSet = S;
    function g(W) {
      return c(W) === "[object ArrayBuffer]";
    }
    g.working = typeof ArrayBuffer < "u" && g(new ArrayBuffer());
    function w(W) {
      return typeof ArrayBuffer > "u" ? !1 : g.working ? g(W) : W instanceof ArrayBuffer;
    }
    e.isArrayBuffer = w;
    function d(W) {
      return c(W) === "[object DataView]";
    }
    d.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && d(new DataView(new ArrayBuffer(1), 0, 1));
    function R(W) {
      return typeof DataView > "u" ? !1 : d.working ? d(W) : W instanceof DataView;
    }
    e.isDataView = R;
    var G = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function fe(W) {
      return c(W) === "[object SharedArrayBuffer]";
    }
    function z(W) {
      return typeof G > "u" ? !1 : (typeof fe.working > "u" && (fe.working = fe(new G())), fe.working ? fe(W) : W instanceof G);
    }
    e.isSharedArrayBuffer = z;
    function V(W) {
      return c(W) === "[object AsyncFunction]";
    }
    e.isAsyncFunction = V;
    function F(W) {
      return c(W) === "[object Map Iterator]";
    }
    e.isMapIterator = F;
    function ee(W) {
      return c(W) === "[object Set Iterator]";
    }
    e.isSetIterator = ee;
    function he(W) {
      return c(W) === "[object Generator]";
    }
    e.isGeneratorObject = he;
    function Z(W) {
      return c(W) === "[object WebAssembly.Module]";
    }
    e.isWebAssemblyCompiledModule = Z;
    function K(W) {
      return E(W, h);
    }
    e.isNumberObject = K;
    function ce(W) {
      return E(W, f);
    }
    e.isStringObject = ce;
    function ve(W) {
      return E(W, b);
    }
    e.isBooleanObject = ve;
    function Be(W) {
      return o && E(W, v);
    }
    e.isBigIntObject = Be;
    function Q(W) {
      return u && E(W, m);
    }
    e.isSymbolObject = Q;
    function C(W) {
      return K(W) || ce(W) || ve(W) || Be(W) || Q(W);
    }
    e.isBoxedPrimitive = C;
    function L(W) {
      return typeof Uint8Array < "u" && (w(W) || z(W));
    }
    e.isAnyArrayBuffer = L, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(W) {
      Object.defineProperty(e, W, {
        enumerable: !1,
        value: function() {
          throw new Error(W + " is not supported in userland");
        }
      });
    });
  }(Gf)), Gf;
}
var po, Jh;
function q4() {
  return Jh || (Jh = 1, po = function(t) {
    return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
  }), po;
}
var Xh;
function nn() {
  return Xh || (Xh = 1, function(e) {
    var t = Object.getOwnPropertyDescriptors || function(R) {
      for (var G = Object.keys(R), fe = {}, z = 0; z < G.length; z++)
        fe[G[z]] = Object.getOwnPropertyDescriptor(R, G[z]);
      return fe;
    }, n = /%[sdj%]/g;
    e.format = function(d) {
      if (!N(d)) {
        for (var R = [], G = 0; G < arguments.length; G++)
          R.push(o(arguments[G]));
        return R.join(" ");
      }
      for (var G = 1, fe = arguments, z = fe.length, V = String(d).replace(n, function(ee) {
        if (ee === "%%")
          return "%";
        if (G >= z)
          return ee;
        switch (ee) {
          case "%s":
            return String(fe[G++]);
          case "%d":
            return Number(fe[G++]);
          case "%j":
            try {
              return JSON.stringify(fe[G++]);
            } catch {
              return "[Circular]";
            }
          default:
            return ee;
        }
      }), F = fe[G]; G < z; F = fe[++G])
        T(F) || !te(F) ? V += " " + F : V += " " + o(F);
      return V;
    }, e.deprecate = function(d, R) {
      if (typeof process < "u" && process.noDeprecation === !0)
        return d;
      if (typeof process > "u")
        return function() {
          return e.deprecate(d, R).apply(this, arguments);
        };
      var G = !1;
      function fe() {
        if (!G) {
          if (process.throwDeprecation)
            throw new Error(R);
          process.traceDeprecation ? console.trace(R) : console.error(R), G = !0;
        }
        return d.apply(this, arguments);
      }
      return fe;
    };
    var i = {}, s = /^$/;
    if (process.env.NODE_DEBUG) {
      var r = process.env.NODE_DEBUG;
      r = r.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), s = new RegExp("^" + r + "$", "i");
    }
    e.debuglog = function(d) {
      if (d = d.toUpperCase(), !i[d])
        if (s.test(d)) {
          var R = process.pid;
          i[d] = function() {
            var G = e.format.apply(e, arguments);
            console.error("%s %d: %s", d, R, G);
          };
        } else
          i[d] = function() {
          };
      return i[d];
    };
    function o(d, R) {
      var G = {
        seen: [],
        stylize: c
      };
      return arguments.length >= 3 && (G.depth = arguments[2]), arguments.length >= 4 && (G.colors = arguments[3]), I(R) ? G.showHidden = R : R && e._extend(G, R), D(G.showHidden) && (G.showHidden = !1), D(G.depth) && (G.depth = 2), D(G.colors) && (G.colors = !1), D(G.customInspect) && (G.customInspect = !0), G.colors && (G.stylize = u), f(G, d, G.depth);
    }
    e.inspect = o, o.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, o.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function u(d, R) {
      var G = o.styles[R];
      return G ? "\x1B[" + o.colors[G][0] + "m" + d + "\x1B[" + o.colors[G][1] + "m" : d;
    }
    function c(d, R) {
      return d;
    }
    function h(d) {
      var R = {};
      return d.forEach(function(G, fe) {
        R[G] = !0;
      }), R;
    }
    function f(d, R, G) {
      if (d.customInspect && R && y(R.inspect) && // Filter out the util module, it's inspect function is special
      R.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
      !(R.constructor && R.constructor.prototype === R)) {
        var fe = R.inspect(G, d);
        return N(fe) || (fe = f(d, fe, G)), fe;
      }
      var z = b(d, R);
      if (z)
        return z;
      var V = Object.keys(R), F = h(V);
      if (d.showHidden && (V = Object.getOwnPropertyNames(R)), U(R) && (V.indexOf("message") >= 0 || V.indexOf("description") >= 0))
        return v(R);
      if (V.length === 0) {
        if (y(R)) {
          var ee = R.name ? ": " + R.name : "";
          return d.stylize("[Function" + ee + "]", "special");
        }
        if (re(R))
          return d.stylize(RegExp.prototype.toString.call(R), "regexp");
        if (oe(R))
          return d.stylize(Date.prototype.toString.call(R), "date");
        if (U(R))
          return v(R);
      }
      var he = "", Z = !1, K = ["{", "}"];
      if (B(R) && (Z = !0, K = ["[", "]"]), y(R)) {
        var ce = R.name ? ": " + R.name : "";
        he = " [Function" + ce + "]";
      }
      if (re(R) && (he = " " + RegExp.prototype.toString.call(R)), oe(R) && (he = " " + Date.prototype.toUTCString.call(R)), U(R) && (he = " " + v(R)), V.length === 0 && (!Z || R.length == 0))
        return K[0] + he + K[1];
      if (G < 0)
        return re(R) ? d.stylize(RegExp.prototype.toString.call(R), "regexp") : d.stylize("[Object]", "special");
      d.seen.push(R);
      var ve;
      return Z ? ve = m(d, R, G, F, V) : ve = V.map(function(Be) {
        return E(d, R, G, F, Be, Z);
      }), d.seen.pop(), M(ve, he, K);
    }
    function b(d, R) {
      if (D(R))
        return d.stylize("undefined", "undefined");
      if (N(R)) {
        var G = "'" + JSON.stringify(R).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return d.stylize(G, "string");
      }
      if (j(R))
        return d.stylize("" + R, "number");
      if (I(R))
        return d.stylize("" + R, "boolean");
      if (T(R))
        return d.stylize("null", "null");
    }
    function v(d) {
      return "[" + Error.prototype.toString.call(d) + "]";
    }
    function m(d, R, G, fe, z) {
      for (var V = [], F = 0, ee = R.length; F < ee; ++F)
        A(R, String(F)) ? V.push(E(
          d,
          R,
          G,
          fe,
          String(F),
          !0
        )) : V.push("");
      return z.forEach(function(he) {
        he.match(/^\d+$/) || V.push(E(
          d,
          R,
          G,
          fe,
          he,
          !0
        ));
      }), V;
    }
    function E(d, R, G, fe, z, V) {
      var F, ee, he;
      if (he = Object.getOwnPropertyDescriptor(R, z) || { value: R[z] }, he.get ? he.set ? ee = d.stylize("[Getter/Setter]", "special") : ee = d.stylize("[Getter]", "special") : he.set && (ee = d.stylize("[Setter]", "special")), A(fe, z) || (F = "[" + z + "]"), ee || (d.seen.indexOf(he.value) < 0 ? (T(G) ? ee = f(d, he.value, null) : ee = f(d, he.value, G - 1), ee.indexOf(`
`) > -1 && (V ? ee = ee.split(`
`).map(function(Z) {
        return "  " + Z;
      }).join(`
`).slice(2) : ee = `
` + ee.split(`
`).map(function(Z) {
        return "   " + Z;
      }).join(`
`))) : ee = d.stylize("[Circular]", "special")), D(F)) {
        if (V && z.match(/^\d+$/))
          return ee;
        F = JSON.stringify("" + z), F.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (F = F.slice(1, -1), F = d.stylize(F, "name")) : (F = F.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), F = d.stylize(F, "string"));
      }
      return F + ": " + ee;
    }
    function M(d, R, G) {
      var fe = d.reduce(function(z, V) {
        return V.indexOf(`
`) >= 0, z + V.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return fe > 60 ? G[0] + (R === "" ? "" : R + `
 `) + " " + d.join(`,
  `) + " " + G[1] : G[0] + R + " " + d.join(", ") + " " + G[1];
    }
    e.types = j4();
    function B(d) {
      return Array.isArray(d);
    }
    e.isArray = B;
    function I(d) {
      return typeof d == "boolean";
    }
    e.isBoolean = I;
    function T(d) {
      return d === null;
    }
    e.isNull = T;
    function k(d) {
      return d == null;
    }
    e.isNullOrUndefined = k;
    function j(d) {
      return typeof d == "number";
    }
    e.isNumber = j;
    function N(d) {
      return typeof d == "string";
    }
    e.isString = N;
    function q(d) {
      return typeof d == "symbol";
    }
    e.isSymbol = q;
    function D(d) {
      return d === void 0;
    }
    e.isUndefined = D;
    function re(d) {
      return te(d) && a(d) === "[object RegExp]";
    }
    e.isRegExp = re, e.types.isRegExp = re;
    function te(d) {
      return typeof d == "object" && d !== null;
    }
    e.isObject = te;
    function oe(d) {
      return te(d) && a(d) === "[object Date]";
    }
    e.isDate = oe, e.types.isDate = oe;
    function U(d) {
      return te(d) && (a(d) === "[object Error]" || d instanceof Error);
    }
    e.isError = U, e.types.isNativeError = U;
    function y(d) {
      return typeof d == "function";
    }
    e.isFunction = y;
    function p(d) {
      return d === null || typeof d == "boolean" || typeof d == "number" || typeof d == "string" || typeof d == "symbol" || // ES6 symbol
      typeof d > "u";
    }
    e.isPrimitive = p, e.isBuffer = q4();
    function a(d) {
      return Object.prototype.toString.call(d);
    }
    function l(d) {
      return d < 10 ? "0" + d.toString(10) : d.toString(10);
    }
    var _ = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function x() {
      var d = /* @__PURE__ */ new Date(), R = [
        l(d.getHours()),
        l(d.getMinutes()),
        l(d.getSeconds())
      ].join(":");
      return [d.getDate(), _[d.getMonth()], R].join(" ");
    }
    e.log = function() {
      console.log("%s - %s", x(), e.format.apply(e, arguments));
    }, e.inherits = mt(), e._extend = function(d, R) {
      if (!R || !te(R))
        return d;
      for (var G = Object.keys(R), fe = G.length; fe--; )
        d[G[fe]] = R[G[fe]];
      return d;
    };
    function A(d, R) {
      return Object.prototype.hasOwnProperty.call(d, R);
    }
    var S = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    e.promisify = function(R) {
      if (typeof R != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (S && R[S]) {
        var G = R[S];
        if (typeof G != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(G, S, {
          value: G,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), G;
      }
      function G() {
        for (var fe, z, V = new Promise(function(he, Z) {
          fe = he, z = Z;
        }), F = [], ee = 0; ee < arguments.length; ee++)
          F.push(arguments[ee]);
        F.push(function(he, Z) {
          he ? z(he) : fe(Z);
        });
        try {
          R.apply(this, F);
        } catch (he) {
          z(he);
        }
        return V;
      }
      return Object.setPrototypeOf(G, Object.getPrototypeOf(R)), S && Object.defineProperty(G, S, {
        value: G,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        G,
        t(R)
      );
    }, e.promisify.custom = S;
    function g(d, R) {
      if (!d) {
        var G = new Error("Promise was rejected with a falsy value");
        G.reason = d, d = G;
      }
      return R(d);
    }
    function w(d) {
      if (typeof d != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function R() {
        for (var G = [], fe = 0; fe < arguments.length; fe++)
          G.push(arguments[fe]);
        var z = G.pop();
        if (typeof z != "function")
          throw new TypeError("The last argument must be of type Function");
        var V = this, F = function() {
          return z.apply(V, arguments);
        };
        d.apply(this, G).then(
          function(ee) {
            process.nextTick(F.bind(null, null, ee));
          },
          function(ee) {
            process.nextTick(g.bind(null, ee, F));
          }
        );
      }
      return Object.setPrototypeOf(R, Object.getPrototypeOf(d)), Object.defineProperties(
        R,
        t(d)
      ), R;
    }
    e.callbackify = w;
  }(Zf)), Zf;
}
var vo, Yh;
function D4() {
  if (Yh)
    return vo;
  Yh = 1;
  function e(E, M) {
    var B = Object.keys(E);
    if (Object.getOwnPropertySymbols) {
      var I = Object.getOwnPropertySymbols(E);
      M && (I = I.filter(function(T) {
        return Object.getOwnPropertyDescriptor(E, T).enumerable;
      })), B.push.apply(B, I);
    }
    return B;
  }
  function t(E) {
    for (var M = 1; M < arguments.length; M++) {
      var B = arguments[M] != null ? arguments[M] : {};
      M % 2 ? e(Object(B), !0).forEach(function(I) {
        n(E, I, B[I]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(E, Object.getOwnPropertyDescriptors(B)) : e(Object(B)).forEach(function(I) {
        Object.defineProperty(E, I, Object.getOwnPropertyDescriptor(B, I));
      });
    }
    return E;
  }
  function n(E, M, B) {
    return M = o(M), M in E ? Object.defineProperty(E, M, { value: B, enumerable: !0, configurable: !0, writable: !0 }) : E[M] = B, E;
  }
  function i(E, M) {
    if (!(E instanceof M))
      throw new TypeError("Cannot call a class as a function");
  }
  function s(E, M) {
    for (var B = 0; B < M.length; B++) {
      var I = M[B];
      I.enumerable = I.enumerable || !1, I.configurable = !0, "value" in I && (I.writable = !0), Object.defineProperty(E, o(I.key), I);
    }
  }
  function r(E, M, B) {
    return M && s(E.prototype, M), B && s(E, B), Object.defineProperty(E, "prototype", { writable: !1 }), E;
  }
  function o(E) {
    var M = u(E, "string");
    return typeof M == "symbol" ? M : String(M);
  }
  function u(E, M) {
    if (typeof E != "object" || E === null)
      return E;
    var B = E[Symbol.toPrimitive];
    if (B !== void 0) {
      var I = B.call(E, M || "default");
      if (typeof I != "object")
        return I;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (M === "string" ? String : Number)(E);
  }
  var c = dr, h = c.Buffer, f = nn(), b = f.inspect, v = b && b.custom || "inspect";
  function m(E, M, B) {
    h.prototype.copy.call(E, M, B);
  }
  return vo = /* @__PURE__ */ function() {
    function E() {
      i(this, E), this.head = null, this.tail = null, this.length = 0;
    }
    return r(E, [{
      key: "push",
      value: function(B) {
        var I = {
          data: B,
          next: null
        };
        this.length > 0 ? this.tail.next = I : this.head = I, this.tail = I, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(B) {
        var I = {
          data: B,
          next: this.head
        };
        this.length === 0 && (this.tail = I), this.head = I, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var B = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, B;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(B) {
        if (this.length === 0)
          return "";
        for (var I = this.head, T = "" + I.data; I = I.next; )
          T += B + I.data;
        return T;
      }
    }, {
      key: "concat",
      value: function(B) {
        if (this.length === 0)
          return h.alloc(0);
        for (var I = h.allocUnsafe(B >>> 0), T = this.head, k = 0; T; )
          m(T.data, I, k), k += T.data.length, T = T.next;
        return I;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(B, I) {
        var T;
        return B < this.head.data.length ? (T = this.head.data.slice(0, B), this.head.data = this.head.data.slice(B)) : B === this.head.data.length ? T = this.shift() : T = I ? this._getString(B) : this._getBuffer(B), T;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(B) {
        var I = this.head, T = 1, k = I.data;
        for (B -= k.length; I = I.next; ) {
          var j = I.data, N = B > j.length ? j.length : B;
          if (N === j.length ? k += j : k += j.slice(0, B), B -= N, B === 0) {
            N === j.length ? (++T, I.next ? this.head = I.next : this.head = this.tail = null) : (this.head = I, I.data = j.slice(N));
            break;
          }
          ++T;
        }
        return this.length -= T, k;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(B) {
        var I = h.allocUnsafe(B), T = this.head, k = 1;
        for (T.data.copy(I), B -= T.data.length; T = T.next; ) {
          var j = T.data, N = B > j.length ? j.length : B;
          if (j.copy(I, I.length - B, 0, N), B -= N, B === 0) {
            N === j.length ? (++k, T.next ? this.head = T.next : this.head = this.tail = null) : (this.head = T, T.data = j.slice(N));
            break;
          }
          ++k;
        }
        return this.length -= k, I;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: v,
      value: function(B, I) {
        return b(this, t(t({}, I), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), E;
  }(), vo;
}
var bo, Qh;
function gb() {
  if (Qh)
    return bo;
  Qh = 1;
  function e(o, u) {
    var c = this, h = this._readableState && this._readableState.destroyed, f = this._writableState && this._writableState.destroyed;
    return h || f ? (u ? u(o) : o && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(s, this, o)) : process.nextTick(s, this, o)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(o || null, function(b) {
      !u && b ? c._writableState ? c._writableState.errorEmitted ? process.nextTick(n, c) : (c._writableState.errorEmitted = !0, process.nextTick(t, c, b)) : process.nextTick(t, c, b) : u ? (process.nextTick(n, c), u(b)) : process.nextTick(n, c);
    }), this);
  }
  function t(o, u) {
    s(o, u), n(o);
  }
  function n(o) {
    o._writableState && !o._writableState.emitClose || o._readableState && !o._readableState.emitClose || o.emit("close");
  }
  function i() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function s(o, u) {
    o.emit("error", u);
  }
  function r(o, u) {
    var c = o._readableState, h = o._writableState;
    c && c.autoDestroy || h && h.autoDestroy ? o.destroy(u) : o.emit("error", u);
  }
  return bo = {
    destroy: e,
    undestroy: i,
    errorOrDestroy: r
  }, bo;
}
var yo = {}, el;
function ui() {
  if (el)
    return yo;
  el = 1;
  function e(u, c) {
    u.prototype = Object.create(c.prototype), u.prototype.constructor = u, u.__proto__ = c;
  }
  var t = {};
  function n(u, c, h) {
    h || (h = Error);
    function f(v, m, E) {
      return typeof c == "string" ? c : c(v, m, E);
    }
    var b = /* @__PURE__ */ function(v) {
      e(m, v);
      function m(E, M, B) {
        return v.call(this, f(E, M, B)) || this;
      }
      return m;
    }(h);
    b.prototype.name = h.name, b.prototype.code = u, t[u] = b;
  }
  function i(u, c) {
    if (Array.isArray(u)) {
      var h = u.length;
      return u = u.map(function(f) {
        return String(f);
      }), h > 2 ? "one of ".concat(c, " ").concat(u.slice(0, h - 1).join(", "), ", or ") + u[h - 1] : h === 2 ? "one of ".concat(c, " ").concat(u[0], " or ").concat(u[1]) : "of ".concat(c, " ").concat(u[0]);
    } else
      return "of ".concat(c, " ").concat(String(u));
  }
  function s(u, c, h) {
    return u.substr(!h || h < 0 ? 0 : +h, c.length) === c;
  }
  function r(u, c, h) {
    return (h === void 0 || h > u.length) && (h = u.length), u.substring(h - c.length, h) === c;
  }
  function o(u, c, h) {
    return typeof h != "number" && (h = 0), h + c.length > u.length ? !1 : u.indexOf(c, h) !== -1;
  }
  return n("ERR_INVALID_OPT_VALUE", function(u, c) {
    return 'The value "' + c + '" is invalid for option "' + u + '"';
  }, TypeError), n("ERR_INVALID_ARG_TYPE", function(u, c, h) {
    var f;
    typeof c == "string" && s(c, "not ") ? (f = "must not be", c = c.replace(/^not /, "")) : f = "must be";
    var b;
    if (r(u, " argument"))
      b = "The ".concat(u, " ").concat(f, " ").concat(i(c, "type"));
    else {
      var v = o(u, ".") ? "property" : "argument";
      b = 'The "'.concat(u, '" ').concat(v, " ").concat(f, " ").concat(i(c, "type"));
    }
    return b += ". Received type ".concat(typeof h), b;
  }, TypeError), n("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), n("ERR_METHOD_NOT_IMPLEMENTED", function(u) {
    return "The " + u + " method is not implemented";
  }), n("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), n("ERR_STREAM_DESTROYED", function(u) {
    return "Cannot call " + u + " after a stream was destroyed";
  }), n("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), n("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), n("ERR_STREAM_WRITE_AFTER_END", "write after end"), n("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), n("ERR_UNKNOWN_ENCODING", function(u) {
    return "Unknown encoding: " + u;
  }, TypeError), n("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), yo.codes = t, yo;
}
var go, tl;
function mb() {
  if (tl)
    return go;
  tl = 1;
  var e = ui().codes.ERR_INVALID_OPT_VALUE;
  function t(i, s, r) {
    return i.highWaterMark != null ? i.highWaterMark : s ? i[r] : null;
  }
  function n(i, s, r, o) {
    var u = t(s, o, r);
    if (u != null) {
      if (!(isFinite(u) && Math.floor(u) === u) || u < 0) {
        var c = o ? r : "highWaterMark";
        throw new e(c, u);
      }
      return Math.floor(u);
    }
    return i.objectMode ? 16 : 16 * 1024;
  }
  return go = {
    getHighWaterMark: n
  }, go;
}
var mo, rl;
function $4() {
  if (rl)
    return mo;
  rl = 1, mo = e;
  function e(n, i) {
    if (t("noDeprecation"))
      return n;
    var s = !1;
    function r() {
      if (!s) {
        if (t("throwDeprecation"))
          throw new Error(i);
        t("traceDeprecation") ? console.trace(i) : console.warn(i), s = !0;
      }
      return n.apply(this, arguments);
    }
    return r;
  }
  function t(n) {
    try {
      if (!Ze.localStorage)
        return !1;
    } catch {
      return !1;
    }
    var i = Ze.localStorage[n];
    return i == null ? !1 : String(i).toLowerCase() === "true";
  }
  return mo;
}
var _o, nl;
function n0() {
  if (nl)
    return _o;
  nl = 1, _o = re;
  function e(z) {
    var V = this;
    this.next = null, this.entry = null, this.finish = function() {
      fe(V, z);
    };
  }
  var t;
  re.WritableState = q;
  var n = {
    deprecate: $4()
  }, i = vb(), s = dr.Buffer, r = (typeof Ze < "u" ? Ze : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function o(z) {
    return s.from(z);
  }
  function u(z) {
    return s.isBuffer(z) || z instanceof r;
  }
  var c = gb(), h = mb(), f = h.getHighWaterMark, b = ui().codes, v = b.ERR_INVALID_ARG_TYPE, m = b.ERR_METHOD_NOT_IMPLEMENTED, E = b.ERR_MULTIPLE_CALLBACK, M = b.ERR_STREAM_CANNOT_PIPE, B = b.ERR_STREAM_DESTROYED, I = b.ERR_STREAM_NULL_VALUES, T = b.ERR_STREAM_WRITE_AFTER_END, k = b.ERR_UNKNOWN_ENCODING, j = c.errorOrDestroy;
  mt()(re, i);
  function N() {
  }
  function q(z, V, F) {
    t = t || Tn(), z = z || {}, typeof F != "boolean" && (F = V instanceof t), this.objectMode = !!z.objectMode, F && (this.objectMode = this.objectMode || !!z.writableObjectMode), this.highWaterMark = f(this, z, "writableHighWaterMark", F), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var ee = z.decodeStrings === !1;
    this.decodeStrings = !ee, this.defaultEncoding = z.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(he) {
      _(V, he);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = z.emitClose !== !1, this.autoDestroy = !!z.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  q.prototype.getBuffer = function() {
    for (var V = this.bufferedRequest, F = []; V; )
      F.push(V), V = V.next;
    return F;
  }, function() {
    try {
      Object.defineProperty(q.prototype, "buffer", {
        get: n.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var D;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (D = Function.prototype[Symbol.hasInstance], Object.defineProperty(re, Symbol.hasInstance, {
    value: function(V) {
      return D.call(this, V) ? !0 : this !== re ? !1 : V && V._writableState instanceof q;
    }
  })) : D = function(V) {
    return V instanceof this;
  };
  function re(z) {
    t = t || Tn();
    var V = this instanceof t;
    if (!V && !D.call(re, this))
      return new re(z);
    this._writableState = new q(z, this, V), this.writable = !0, z && (typeof z.write == "function" && (this._write = z.write), typeof z.writev == "function" && (this._writev = z.writev), typeof z.destroy == "function" && (this._destroy = z.destroy), typeof z.final == "function" && (this._final = z.final)), i.call(this);
  }
  re.prototype.pipe = function() {
    j(this, new M());
  };
  function te(z, V) {
    var F = new T();
    j(z, F), process.nextTick(V, F);
  }
  function oe(z, V, F, ee) {
    var he;
    return F === null ? he = new I() : typeof F != "string" && !V.objectMode && (he = new v("chunk", ["string", "Buffer"], F)), he ? (j(z, he), process.nextTick(ee, he), !1) : !0;
  }
  re.prototype.write = function(z, V, F) {
    var ee = this._writableState, he = !1, Z = !ee.objectMode && u(z);
    return Z && !s.isBuffer(z) && (z = o(z)), typeof V == "function" && (F = V, V = null), Z ? V = "buffer" : V || (V = ee.defaultEncoding), typeof F != "function" && (F = N), ee.ending ? te(this, F) : (Z || oe(this, ee, z, F)) && (ee.pendingcb++, he = y(this, ee, Z, z, V, F)), he;
  }, re.prototype.cork = function() {
    this._writableState.corked++;
  }, re.prototype.uncork = function() {
    var z = this._writableState;
    z.corked && (z.corked--, !z.writing && !z.corked && !z.bufferProcessing && z.bufferedRequest && S(this, z));
  }, re.prototype.setDefaultEncoding = function(V) {
    if (typeof V == "string" && (V = V.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((V + "").toLowerCase()) > -1))
      throw new k(V);
    return this._writableState.defaultEncoding = V, this;
  }, Object.defineProperty(re.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function U(z, V, F) {
    return !z.objectMode && z.decodeStrings !== !1 && typeof V == "string" && (V = s.from(V, F)), V;
  }
  Object.defineProperty(re.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function y(z, V, F, ee, he, Z) {
    if (!F) {
      var K = U(V, ee, he);
      ee !== K && (F = !0, he = "buffer", ee = K);
    }
    var ce = V.objectMode ? 1 : ee.length;
    V.length += ce;
    var ve = V.length < V.highWaterMark;
    if (ve || (V.needDrain = !0), V.writing || V.corked) {
      var Be = V.lastBufferedRequest;
      V.lastBufferedRequest = {
        chunk: ee,
        encoding: he,
        isBuf: F,
        callback: Z,
        next: null
      }, Be ? Be.next = V.lastBufferedRequest : V.bufferedRequest = V.lastBufferedRequest, V.bufferedRequestCount += 1;
    } else
      p(z, V, !1, ce, ee, he, Z);
    return ve;
  }
  function p(z, V, F, ee, he, Z, K) {
    V.writelen = ee, V.writecb = K, V.writing = !0, V.sync = !0, V.destroyed ? V.onwrite(new B("write")) : F ? z._writev(he, V.onwrite) : z._write(he, Z, V.onwrite), V.sync = !1;
  }
  function a(z, V, F, ee, he) {
    --V.pendingcb, F ? (process.nextTick(he, ee), process.nextTick(R, z, V), z._writableState.errorEmitted = !0, j(z, ee)) : (he(ee), z._writableState.errorEmitted = !0, j(z, ee), R(z, V));
  }
  function l(z) {
    z.writing = !1, z.writecb = null, z.length -= z.writelen, z.writelen = 0;
  }
  function _(z, V) {
    var F = z._writableState, ee = F.sync, he = F.writecb;
    if (typeof he != "function")
      throw new E();
    if (l(F), V)
      a(z, F, ee, V, he);
    else {
      var Z = g(F) || z.destroyed;
      !Z && !F.corked && !F.bufferProcessing && F.bufferedRequest && S(z, F), ee ? process.nextTick(x, z, F, Z, he) : x(z, F, Z, he);
    }
  }
  function x(z, V, F, ee) {
    F || A(z, V), V.pendingcb--, ee(), R(z, V);
  }
  function A(z, V) {
    V.length === 0 && V.needDrain && (V.needDrain = !1, z.emit("drain"));
  }
  function S(z, V) {
    V.bufferProcessing = !0;
    var F = V.bufferedRequest;
    if (z._writev && F && F.next) {
      var ee = V.bufferedRequestCount, he = new Array(ee), Z = V.corkedRequestsFree;
      Z.entry = F;
      for (var K = 0, ce = !0; F; )
        he[K] = F, F.isBuf || (ce = !1), F = F.next, K += 1;
      he.allBuffers = ce, p(z, V, !0, V.length, he, "", Z.finish), V.pendingcb++, V.lastBufferedRequest = null, Z.next ? (V.corkedRequestsFree = Z.next, Z.next = null) : V.corkedRequestsFree = new e(V), V.bufferedRequestCount = 0;
    } else {
      for (; F; ) {
        var ve = F.chunk, Be = F.encoding, Q = F.callback, C = V.objectMode ? 1 : ve.length;
        if (p(z, V, !1, C, ve, Be, Q), F = F.next, V.bufferedRequestCount--, V.writing)
          break;
      }
      F === null && (V.lastBufferedRequest = null);
    }
    V.bufferedRequest = F, V.bufferProcessing = !1;
  }
  re.prototype._write = function(z, V, F) {
    F(new m("_write()"));
  }, re.prototype._writev = null, re.prototype.end = function(z, V, F) {
    var ee = this._writableState;
    return typeof z == "function" ? (F = z, z = null, V = null) : typeof V == "function" && (F = V, V = null), z != null && this.write(z, V), ee.corked && (ee.corked = 1, this.uncork()), ee.ending || G(this, ee, F), this;
  }, Object.defineProperty(re.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function g(z) {
    return z.ending && z.length === 0 && z.bufferedRequest === null && !z.finished && !z.writing;
  }
  function w(z, V) {
    z._final(function(F) {
      V.pendingcb--, F && j(z, F), V.prefinished = !0, z.emit("prefinish"), R(z, V);
    });
  }
  function d(z, V) {
    !V.prefinished && !V.finalCalled && (typeof z._final == "function" && !V.destroyed ? (V.pendingcb++, V.finalCalled = !0, process.nextTick(w, z, V)) : (V.prefinished = !0, z.emit("prefinish")));
  }
  function R(z, V) {
    var F = g(V);
    if (F && (d(z, V), V.pendingcb === 0 && (V.finished = !0, z.emit("finish"), V.autoDestroy))) {
      var ee = z._readableState;
      (!ee || ee.autoDestroy && ee.endEmitted) && z.destroy();
    }
    return F;
  }
  function G(z, V, F) {
    V.ending = !0, R(z, V), F && (V.finished ? process.nextTick(F) : z.once("finish", F)), V.ended = !0, z.writable = !1;
  }
  function fe(z, V, F) {
    var ee = z.entry;
    for (z.entry = null; ee; ) {
      var he = ee.callback;
      V.pendingcb--, he(F), ee = ee.next;
    }
    V.corkedRequestsFree.next = z;
  }
  return Object.defineProperty(re.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(V) {
      this._writableState && (this._writableState.destroyed = V);
    }
  }), re.prototype.destroy = c.destroy, re.prototype._undestroy = c.undestroy, re.prototype._destroy = function(z, V) {
    V(z);
  }, _o;
}
var wo, il;
function Tn() {
  if (il)
    return wo;
  il = 1;
  var e = Object.keys || function(h) {
    var f = [];
    for (var b in h)
      f.push(b);
    return f;
  };
  wo = o;
  var t = i0(), n = n0();
  mt()(o, t);
  for (var i = e(n.prototype), s = 0; s < i.length; s++) {
    var r = i[s];
    o.prototype[r] || (o.prototype[r] = n.prototype[r]);
  }
  function o(h) {
    if (!(this instanceof o))
      return new o(h);
    t.call(this, h), n.call(this, h), this.allowHalfOpen = !0, h && (h.readable === !1 && (this.readable = !1), h.writable === !1 && (this.writable = !1), h.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", u)));
  }
  Object.defineProperty(o.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(o.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(o.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function u() {
    this._writableState.ended || process.nextTick(c, this);
  }
  function c(h) {
    h.end();
  }
  return Object.defineProperty(o.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(f) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = f, this._writableState.destroyed = f);
    }
  }), wo;
}
var xo = {}, ra = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var al;
function At() {
  return al || (al = 1, function(e, t) {
    var n = dr, i = n.Buffer;
    function s(o, u) {
      for (var c in o)
        u[c] = o[c];
    }
    i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? e.exports = n : (s(n, t), t.Buffer = r);
    function r(o, u, c) {
      return i(o, u, c);
    }
    r.prototype = Object.create(i.prototype), s(i, r), r.from = function(o, u, c) {
      if (typeof o == "number")
        throw new TypeError("Argument must not be a number");
      return i(o, u, c);
    }, r.alloc = function(o, u, c) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      var h = i(o);
      return u !== void 0 ? typeof c == "string" ? h.fill(u, c) : h.fill(u) : h.fill(0), h;
    }, r.allocUnsafe = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return i(o);
    }, r.allocUnsafeSlow = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return n.SlowBuffer(o);
    };
  }(ra, ra.exports)), ra.exports;
}
var fl;
function vc() {
  if (fl)
    return xo;
  fl = 1;
  var e = At().Buffer, t = e.isEncoding || function(I) {
    switch (I = "" + I, I && I.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function n(I) {
    if (!I)
      return "utf8";
    for (var T; ; )
      switch (I) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return I;
        default:
          if (T)
            return;
          I = ("" + I).toLowerCase(), T = !0;
      }
  }
  function i(I) {
    var T = n(I);
    if (typeof T != "string" && (e.isEncoding === t || !t(I)))
      throw new Error("Unknown encoding: " + I);
    return T || I;
  }
  xo.StringDecoder = s;
  function s(I) {
    this.encoding = i(I);
    var T;
    switch (this.encoding) {
      case "utf16le":
        this.text = b, this.end = v, T = 4;
        break;
      case "utf8":
        this.fillLast = c, T = 4;
        break;
      case "base64":
        this.text = m, this.end = E, T = 3;
        break;
      default:
        this.write = M, this.end = B;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(T);
  }
  s.prototype.write = function(I) {
    if (I.length === 0)
      return "";
    var T, k;
    if (this.lastNeed) {
      if (T = this.fillLast(I), T === void 0)
        return "";
      k = this.lastNeed, this.lastNeed = 0;
    } else
      k = 0;
    return k < I.length ? T ? T + this.text(I, k) : this.text(I, k) : T || "";
  }, s.prototype.end = f, s.prototype.text = h, s.prototype.fillLast = function(I) {
    if (this.lastNeed <= I.length)
      return I.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    I.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, I.length), this.lastNeed -= I.length;
  };
  function r(I) {
    return I <= 127 ? 0 : I >> 5 === 6 ? 2 : I >> 4 === 14 ? 3 : I >> 3 === 30 ? 4 : I >> 6 === 2 ? -1 : -2;
  }
  function o(I, T, k) {
    var j = T.length - 1;
    if (j < k)
      return 0;
    var N = r(T[j]);
    return N >= 0 ? (N > 0 && (I.lastNeed = N - 1), N) : --j < k || N === -2 ? 0 : (N = r(T[j]), N >= 0 ? (N > 0 && (I.lastNeed = N - 2), N) : --j < k || N === -2 ? 0 : (N = r(T[j]), N >= 0 ? (N > 0 && (N === 2 ? N = 0 : I.lastNeed = N - 3), N) : 0));
  }
  function u(I, T, k) {
    if ((T[0] & 192) !== 128)
      return I.lastNeed = 0, "";
    if (I.lastNeed > 1 && T.length > 1) {
      if ((T[1] & 192) !== 128)
        return I.lastNeed = 1, "";
      if (I.lastNeed > 2 && T.length > 2 && (T[2] & 192) !== 128)
        return I.lastNeed = 2, "";
    }
  }
  function c(I) {
    var T = this.lastTotal - this.lastNeed, k = u(this, I);
    if (k !== void 0)
      return k;
    if (this.lastNeed <= I.length)
      return I.copy(this.lastChar, T, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    I.copy(this.lastChar, T, 0, I.length), this.lastNeed -= I.length;
  }
  function h(I, T) {
    var k = o(this, I, T);
    if (!this.lastNeed)
      return I.toString("utf8", T);
    this.lastTotal = k;
    var j = I.length - (k - this.lastNeed);
    return I.copy(this.lastChar, 0, j), I.toString("utf8", T, j);
  }
  function f(I) {
    var T = I && I.length ? this.write(I) : "";
    return this.lastNeed ? T + "" : T;
  }
  function b(I, T) {
    if ((I.length - T) % 2 === 0) {
      var k = I.toString("utf16le", T);
      if (k) {
        var j = k.charCodeAt(k.length - 1);
        if (j >= 55296 && j <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = I[I.length - 2], this.lastChar[1] = I[I.length - 1], k.slice(0, -1);
      }
      return k;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = I[I.length - 1], I.toString("utf16le", T, I.length - 1);
  }
  function v(I) {
    var T = I && I.length ? this.write(I) : "";
    if (this.lastNeed) {
      var k = this.lastTotal - this.lastNeed;
      return T + this.lastChar.toString("utf16le", 0, k);
    }
    return T;
  }
  function m(I, T) {
    var k = (I.length - T) % 3;
    return k === 0 ? I.toString("base64", T) : (this.lastNeed = 3 - k, this.lastTotal = 3, k === 1 ? this.lastChar[0] = I[I.length - 1] : (this.lastChar[0] = I[I.length - 2], this.lastChar[1] = I[I.length - 1]), I.toString("base64", T, I.length - k));
  }
  function E(I) {
    var T = I && I.length ? this.write(I) : "";
    return this.lastNeed ? T + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : T;
  }
  function M(I) {
    return I.toString(this.encoding);
  }
  function B(I) {
    return I && I.length ? this.write(I) : "";
  }
  return xo;
}
var Eo, ol;
function df() {
  if (ol)
    return Eo;
  ol = 1;
  var e = ui().codes.ERR_STREAM_PREMATURE_CLOSE;
  function t(r) {
    var o = !1;
    return function() {
      if (!o) {
        o = !0;
        for (var u = arguments.length, c = new Array(u), h = 0; h < u; h++)
          c[h] = arguments[h];
        r.apply(this, c);
      }
    };
  }
  function n() {
  }
  function i(r) {
    return r.setHeader && typeof r.abort == "function";
  }
  function s(r, o, u) {
    if (typeof o == "function")
      return s(r, null, o);
    o || (o = {}), u = t(u || n);
    var c = o.readable || o.readable !== !1 && r.readable, h = o.writable || o.writable !== !1 && r.writable, f = function() {
      r.writable || v();
    }, b = r._writableState && r._writableState.finished, v = function() {
      h = !1, b = !0, c || u.call(r);
    }, m = r._readableState && r._readableState.endEmitted, E = function() {
      c = !1, m = !0, h || u.call(r);
    }, M = function(k) {
      u.call(r, k);
    }, B = function() {
      var k;
      if (c && !m)
        return (!r._readableState || !r._readableState.ended) && (k = new e()), u.call(r, k);
      if (h && !b)
        return (!r._writableState || !r._writableState.ended) && (k = new e()), u.call(r, k);
    }, I = function() {
      r.req.on("finish", v);
    };
    return i(r) ? (r.on("complete", v), r.on("abort", B), r.req ? I() : r.on("request", I)) : h && !r._writableState && (r.on("end", f), r.on("close", f)), r.on("end", E), r.on("finish", v), o.error !== !1 && r.on("error", M), r.on("close", B), function() {
      r.removeListener("complete", v), r.removeListener("abort", B), r.removeListener("request", I), r.req && r.req.removeListener("finish", v), r.removeListener("end", f), r.removeListener("close", f), r.removeListener("finish", v), r.removeListener("end", E), r.removeListener("error", M), r.removeListener("close", B);
    };
  }
  return Eo = s, Eo;
}
var So, sl;
function U4() {
  if (sl)
    return So;
  sl = 1;
  var e;
  function t(k, j, N) {
    return j = n(j), j in k ? Object.defineProperty(k, j, { value: N, enumerable: !0, configurable: !0, writable: !0 }) : k[j] = N, k;
  }
  function n(k) {
    var j = i(k, "string");
    return typeof j == "symbol" ? j : String(j);
  }
  function i(k, j) {
    if (typeof k != "object" || k === null)
      return k;
    var N = k[Symbol.toPrimitive];
    if (N !== void 0) {
      var q = N.call(k, j || "default");
      if (typeof q != "object")
        return q;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (j === "string" ? String : Number)(k);
  }
  var s = df(), r = Symbol("lastResolve"), o = Symbol("lastReject"), u = Symbol("error"), c = Symbol("ended"), h = Symbol("lastPromise"), f = Symbol("handlePromise"), b = Symbol("stream");
  function v(k, j) {
    return {
      value: k,
      done: j
    };
  }
  function m(k) {
    var j = k[r];
    if (j !== null) {
      var N = k[b].read();
      N !== null && (k[h] = null, k[r] = null, k[o] = null, j(v(N, !1)));
    }
  }
  function E(k) {
    process.nextTick(m, k);
  }
  function M(k, j) {
    return function(N, q) {
      k.then(function() {
        if (j[c]) {
          N(v(void 0, !0));
          return;
        }
        j[f](N, q);
      }, q);
    };
  }
  var B = Object.getPrototypeOf(function() {
  }), I = Object.setPrototypeOf((e = {
    get stream() {
      return this[b];
    },
    next: function() {
      var j = this, N = this[u];
      if (N !== null)
        return Promise.reject(N);
      if (this[c])
        return Promise.resolve(v(void 0, !0));
      if (this[b].destroyed)
        return new Promise(function(te, oe) {
          process.nextTick(function() {
            j[u] ? oe(j[u]) : te(v(void 0, !0));
          });
        });
      var q = this[h], D;
      if (q)
        D = new Promise(M(q, this));
      else {
        var re = this[b].read();
        if (re !== null)
          return Promise.resolve(v(re, !1));
        D = new Promise(this[f]);
      }
      return this[h] = D, D;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var j = this;
    return new Promise(function(N, q) {
      j[b].destroy(null, function(D) {
        if (D) {
          q(D);
          return;
        }
        N(v(void 0, !0));
      });
    });
  }), e), B), T = function(j) {
    var N, q = Object.create(I, (N = {}, t(N, b, {
      value: j,
      writable: !0
    }), t(N, r, {
      value: null,
      writable: !0
    }), t(N, o, {
      value: null,
      writable: !0
    }), t(N, u, {
      value: null,
      writable: !0
    }), t(N, c, {
      value: j._readableState.endEmitted,
      writable: !0
    }), t(N, f, {
      value: function(re, te) {
        var oe = q[b].read();
        oe ? (q[h] = null, q[r] = null, q[o] = null, re(v(oe, !1))) : (q[r] = re, q[o] = te);
      },
      writable: !0
    }), N));
    return q[h] = null, s(j, function(D) {
      if (D && D.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var re = q[o];
        re !== null && (q[h] = null, q[r] = null, q[o] = null, re(D)), q[u] = D;
        return;
      }
      var te = q[r];
      te !== null && (q[h] = null, q[r] = null, q[o] = null, te(v(void 0, !0))), q[c] = !0;
    }), j.on("readable", E.bind(null, q)), q;
  };
  return So = T, So;
}
var Ao, ul;
function F4() {
  return ul || (ul = 1, Ao = function() {
    throw new Error("Readable.from is not available in the browser");
  }), Ao;
}
var Mo, cl;
function i0() {
  if (cl)
    return Mo;
  cl = 1, Mo = te;
  var e;
  te.ReadableState = re, ii.EventEmitter;
  var t = function(K, ce) {
    return K.listeners(ce).length;
  }, n = vb(), i = dr.Buffer, s = (typeof Ze < "u" ? Ze : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function r(Z) {
    return i.from(Z);
  }
  function o(Z) {
    return i.isBuffer(Z) || Z instanceof s;
  }
  var u = nn(), c;
  u && u.debuglog ? c = u.debuglog("stream") : c = function() {
  };
  var h = D4(), f = gb(), b = mb(), v = b.getHighWaterMark, m = ui().codes, E = m.ERR_INVALID_ARG_TYPE, M = m.ERR_STREAM_PUSH_AFTER_EOF, B = m.ERR_METHOD_NOT_IMPLEMENTED, I = m.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, T, k, j;
  mt()(te, n);
  var N = f.errorOrDestroy, q = ["error", "close", "destroy", "pause", "resume"];
  function D(Z, K, ce) {
    if (typeof Z.prependListener == "function")
      return Z.prependListener(K, ce);
    !Z._events || !Z._events[K] ? Z.on(K, ce) : Array.isArray(Z._events[K]) ? Z._events[K].unshift(ce) : Z._events[K] = [ce, Z._events[K]];
  }
  function re(Z, K, ce) {
    e = e || Tn(), Z = Z || {}, typeof ce != "boolean" && (ce = K instanceof e), this.objectMode = !!Z.objectMode, ce && (this.objectMode = this.objectMode || !!Z.readableObjectMode), this.highWaterMark = v(this, Z, "readableHighWaterMark", ce), this.buffer = new h(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Z.emitClose !== !1, this.autoDestroy = !!Z.autoDestroy, this.destroyed = !1, this.defaultEncoding = Z.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Z.encoding && (T || (T = vc().StringDecoder), this.decoder = new T(Z.encoding), this.encoding = Z.encoding);
  }
  function te(Z) {
    if (e = e || Tn(), !(this instanceof te))
      return new te(Z);
    var K = this instanceof e;
    this._readableState = new re(Z, this, K), this.readable = !0, Z && (typeof Z.read == "function" && (this._read = Z.read), typeof Z.destroy == "function" && (this._destroy = Z.destroy)), n.call(this);
  }
  Object.defineProperty(te.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(K) {
      this._readableState && (this._readableState.destroyed = K);
    }
  }), te.prototype.destroy = f.destroy, te.prototype._undestroy = f.undestroy, te.prototype._destroy = function(Z, K) {
    K(Z);
  }, te.prototype.push = function(Z, K) {
    var ce = this._readableState, ve;
    return ce.objectMode ? ve = !0 : typeof Z == "string" && (K = K || ce.defaultEncoding, K !== ce.encoding && (Z = i.from(Z, K), K = ""), ve = !0), oe(this, Z, K, !1, ve);
  }, te.prototype.unshift = function(Z) {
    return oe(this, Z, null, !0, !1);
  };
  function oe(Z, K, ce, ve, Be) {
    c("readableAddChunk", K);
    var Q = Z._readableState;
    if (K === null)
      Q.reading = !1, _(Z, Q);
    else {
      var C;
      if (Be || (C = y(Q, K)), C)
        N(Z, C);
      else if (Q.objectMode || K && K.length > 0)
        if (typeof K != "string" && !Q.objectMode && Object.getPrototypeOf(K) !== i.prototype && (K = r(K)), ve)
          Q.endEmitted ? N(Z, new I()) : U(Z, Q, K, !0);
        else if (Q.ended)
          N(Z, new M());
        else {
          if (Q.destroyed)
            return !1;
          Q.reading = !1, Q.decoder && !ce ? (K = Q.decoder.write(K), Q.objectMode || K.length !== 0 ? U(Z, Q, K, !1) : S(Z, Q)) : U(Z, Q, K, !1);
        }
      else
        ve || (Q.reading = !1, S(Z, Q));
    }
    return !Q.ended && (Q.length < Q.highWaterMark || Q.length === 0);
  }
  function U(Z, K, ce, ve) {
    K.flowing && K.length === 0 && !K.sync ? (K.awaitDrain = 0, Z.emit("data", ce)) : (K.length += K.objectMode ? 1 : ce.length, ve ? K.buffer.unshift(ce) : K.buffer.push(ce), K.needReadable && x(Z)), S(Z, K);
  }
  function y(Z, K) {
    var ce;
    return !o(K) && typeof K != "string" && K !== void 0 && !Z.objectMode && (ce = new E("chunk", ["string", "Buffer", "Uint8Array"], K)), ce;
  }
  te.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, te.prototype.setEncoding = function(Z) {
    T || (T = vc().StringDecoder);
    var K = new T(Z);
    this._readableState.decoder = K, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var ce = this._readableState.buffer.head, ve = ""; ce !== null; )
      ve += K.write(ce.data), ce = ce.next;
    return this._readableState.buffer.clear(), ve !== "" && this._readableState.buffer.push(ve), this._readableState.length = ve.length, this;
  };
  var p = 1073741824;
  function a(Z) {
    return Z >= p ? Z = p : (Z--, Z |= Z >>> 1, Z |= Z >>> 2, Z |= Z >>> 4, Z |= Z >>> 8, Z |= Z >>> 16, Z++), Z;
  }
  function l(Z, K) {
    return Z <= 0 || K.length === 0 && K.ended ? 0 : K.objectMode ? 1 : Z !== Z ? K.flowing && K.length ? K.buffer.head.data.length : K.length : (Z > K.highWaterMark && (K.highWaterMark = a(Z)), Z <= K.length ? Z : K.ended ? K.length : (K.needReadable = !0, 0));
  }
  te.prototype.read = function(Z) {
    c("read", Z), Z = parseInt(Z, 10);
    var K = this._readableState, ce = Z;
    if (Z !== 0 && (K.emittedReadable = !1), Z === 0 && K.needReadable && ((K.highWaterMark !== 0 ? K.length >= K.highWaterMark : K.length > 0) || K.ended))
      return c("read: emitReadable", K.length, K.ended), K.length === 0 && K.ended ? F(this) : x(this), null;
    if (Z = l(Z, K), Z === 0 && K.ended)
      return K.length === 0 && F(this), null;
    var ve = K.needReadable;
    c("need readable", ve), (K.length === 0 || K.length - Z < K.highWaterMark) && (ve = !0, c("length less than watermark", ve)), K.ended || K.reading ? (ve = !1, c("reading or ended", ve)) : ve && (c("do read"), K.reading = !0, K.sync = !0, K.length === 0 && (K.needReadable = !0), this._read(K.highWaterMark), K.sync = !1, K.reading || (Z = l(ce, K)));
    var Be;
    return Z > 0 ? Be = V(Z, K) : Be = null, Be === null ? (K.needReadable = K.length <= K.highWaterMark, Z = 0) : (K.length -= Z, K.awaitDrain = 0), K.length === 0 && (K.ended || (K.needReadable = !0), ce !== Z && K.ended && F(this)), Be !== null && this.emit("data", Be), Be;
  };
  function _(Z, K) {
    if (c("onEofChunk"), !K.ended) {
      if (K.decoder) {
        var ce = K.decoder.end();
        ce && ce.length && (K.buffer.push(ce), K.length += K.objectMode ? 1 : ce.length);
      }
      K.ended = !0, K.sync ? x(Z) : (K.needReadable = !1, K.emittedReadable || (K.emittedReadable = !0, A(Z)));
    }
  }
  function x(Z) {
    var K = Z._readableState;
    c("emitReadable", K.needReadable, K.emittedReadable), K.needReadable = !1, K.emittedReadable || (c("emitReadable", K.flowing), K.emittedReadable = !0, process.nextTick(A, Z));
  }
  function A(Z) {
    var K = Z._readableState;
    c("emitReadable_", K.destroyed, K.length, K.ended), !K.destroyed && (K.length || K.ended) && (Z.emit("readable"), K.emittedReadable = !1), K.needReadable = !K.flowing && !K.ended && K.length <= K.highWaterMark, z(Z);
  }
  function S(Z, K) {
    K.readingMore || (K.readingMore = !0, process.nextTick(g, Z, K));
  }
  function g(Z, K) {
    for (; !K.reading && !K.ended && (K.length < K.highWaterMark || K.flowing && K.length === 0); ) {
      var ce = K.length;
      if (c("maybeReadMore read 0"), Z.read(0), ce === K.length)
        break;
    }
    K.readingMore = !1;
  }
  te.prototype._read = function(Z) {
    N(this, new B("_read()"));
  }, te.prototype.pipe = function(Z, K) {
    var ce = this, ve = this._readableState;
    switch (ve.pipesCount) {
      case 0:
        ve.pipes = Z;
        break;
      case 1:
        ve.pipes = [ve.pipes, Z];
        break;
      default:
        ve.pipes.push(Z);
        break;
    }
    ve.pipesCount += 1, c("pipe count=%d opts=%j", ve.pipesCount, K);
    var Be = (!K || K.end !== !1) && Z !== process.stdout && Z !== process.stderr, Q = Be ? L : se;
    ve.endEmitted ? process.nextTick(Q) : ce.once("end", Q), Z.on("unpipe", C);
    function C(we, Ce) {
      c("onunpipe"), we === ce && Ce && Ce.hasUnpiped === !1 && (Ce.hasUnpiped = !0, me());
    }
    function L() {
      c("onend"), Z.end();
    }
    var W = w(ce);
    Z.on("drain", W);
    var de = !1;
    function me() {
      c("cleanup"), Z.removeListener("close", H), Z.removeListener("finish", ue), Z.removeListener("drain", W), Z.removeListener("error", Fe), Z.removeListener("unpipe", C), ce.removeListener("end", L), ce.removeListener("end", se), ce.removeListener("data", Te), de = !0, ve.awaitDrain && (!Z._writableState || Z._writableState.needDrain) && W();
    }
    ce.on("data", Te);
    function Te(we) {
      c("ondata");
      var Ce = Z.write(we);
      c("dest.write", Ce), Ce === !1 && ((ve.pipesCount === 1 && ve.pipes === Z || ve.pipesCount > 1 && he(ve.pipes, Z) !== -1) && !de && (c("false write response, pause", ve.awaitDrain), ve.awaitDrain++), ce.pause());
    }
    function Fe(we) {
      c("onerror", we), se(), Z.removeListener("error", Fe), t(Z, "error") === 0 && N(Z, we);
    }
    D(Z, "error", Fe);
    function H() {
      Z.removeListener("finish", ue), se();
    }
    Z.once("close", H);
    function ue() {
      c("onfinish"), Z.removeListener("close", H), se();
    }
    Z.once("finish", ue);
    function se() {
      c("unpipe"), ce.unpipe(Z);
    }
    return Z.emit("pipe", ce), ve.flowing || (c("pipe resume"), ce.resume()), Z;
  };
  function w(Z) {
    return function() {
      var ce = Z._readableState;
      c("pipeOnDrain", ce.awaitDrain), ce.awaitDrain && ce.awaitDrain--, ce.awaitDrain === 0 && t(Z, "data") && (ce.flowing = !0, z(Z));
    };
  }
  te.prototype.unpipe = function(Z) {
    var K = this._readableState, ce = {
      hasUnpiped: !1
    };
    if (K.pipesCount === 0)
      return this;
    if (K.pipesCount === 1)
      return Z && Z !== K.pipes ? this : (Z || (Z = K.pipes), K.pipes = null, K.pipesCount = 0, K.flowing = !1, Z && Z.emit("unpipe", this, ce), this);
    if (!Z) {
      var ve = K.pipes, Be = K.pipesCount;
      K.pipes = null, K.pipesCount = 0, K.flowing = !1;
      for (var Q = 0; Q < Be; Q++)
        ve[Q].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var C = he(K.pipes, Z);
    return C === -1 ? this : (K.pipes.splice(C, 1), K.pipesCount -= 1, K.pipesCount === 1 && (K.pipes = K.pipes[0]), Z.emit("unpipe", this, ce), this);
  }, te.prototype.on = function(Z, K) {
    var ce = n.prototype.on.call(this, Z, K), ve = this._readableState;
    return Z === "data" ? (ve.readableListening = this.listenerCount("readable") > 0, ve.flowing !== !1 && this.resume()) : Z === "readable" && !ve.endEmitted && !ve.readableListening && (ve.readableListening = ve.needReadable = !0, ve.flowing = !1, ve.emittedReadable = !1, c("on readable", ve.length, ve.reading), ve.length ? x(this) : ve.reading || process.nextTick(R, this)), ce;
  }, te.prototype.addListener = te.prototype.on, te.prototype.removeListener = function(Z, K) {
    var ce = n.prototype.removeListener.call(this, Z, K);
    return Z === "readable" && process.nextTick(d, this), ce;
  }, te.prototype.removeAllListeners = function(Z) {
    var K = n.prototype.removeAllListeners.apply(this, arguments);
    return (Z === "readable" || Z === void 0) && process.nextTick(d, this), K;
  };
  function d(Z) {
    var K = Z._readableState;
    K.readableListening = Z.listenerCount("readable") > 0, K.resumeScheduled && !K.paused ? K.flowing = !0 : Z.listenerCount("data") > 0 && Z.resume();
  }
  function R(Z) {
    c("readable nexttick read 0"), Z.read(0);
  }
  te.prototype.resume = function() {
    var Z = this._readableState;
    return Z.flowing || (c("resume"), Z.flowing = !Z.readableListening, G(this, Z)), Z.paused = !1, this;
  };
  function G(Z, K) {
    K.resumeScheduled || (K.resumeScheduled = !0, process.nextTick(fe, Z, K));
  }
  function fe(Z, K) {
    c("resume", K.reading), K.reading || Z.read(0), K.resumeScheduled = !1, Z.emit("resume"), z(Z), K.flowing && !K.reading && Z.read(0);
  }
  te.prototype.pause = function() {
    return c("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (c("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function z(Z) {
    var K = Z._readableState;
    for (c("flow", K.flowing); K.flowing && Z.read() !== null; )
      ;
  }
  te.prototype.wrap = function(Z) {
    var K = this, ce = this._readableState, ve = !1;
    Z.on("end", function() {
      if (c("wrapped end"), ce.decoder && !ce.ended) {
        var C = ce.decoder.end();
        C && C.length && K.push(C);
      }
      K.push(null);
    }), Z.on("data", function(C) {
      if (c("wrapped data"), ce.decoder && (C = ce.decoder.write(C)), !(ce.objectMode && C == null) && !(!ce.objectMode && (!C || !C.length))) {
        var L = K.push(C);
        L || (ve = !0, Z.pause());
      }
    });
    for (var Be in Z)
      this[Be] === void 0 && typeof Z[Be] == "function" && (this[Be] = function(L) {
        return function() {
          return Z[L].apply(Z, arguments);
        };
      }(Be));
    for (var Q = 0; Q < q.length; Q++)
      Z.on(q[Q], this.emit.bind(this, q[Q]));
    return this._read = function(C) {
      c("wrapped _read", C), ve && (ve = !1, Z.resume());
    }, this;
  }, typeof Symbol == "function" && (te.prototype[Symbol.asyncIterator] = function() {
    return k === void 0 && (k = U4()), k(this);
  }), Object.defineProperty(te.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(te.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(te.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(K) {
      this._readableState && (this._readableState.flowing = K);
    }
  }), te._fromList = V, Object.defineProperty(te.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function V(Z, K) {
    if (K.length === 0)
      return null;
    var ce;
    return K.objectMode ? ce = K.buffer.shift() : !Z || Z >= K.length ? (K.decoder ? ce = K.buffer.join("") : K.buffer.length === 1 ? ce = K.buffer.first() : ce = K.buffer.concat(K.length), K.buffer.clear()) : ce = K.buffer.consume(Z, K.decoder), ce;
  }
  function F(Z) {
    var K = Z._readableState;
    c("endReadable", K.endEmitted), K.endEmitted || (K.ended = !0, process.nextTick(ee, K, Z));
  }
  function ee(Z, K) {
    if (c("endReadableNT", Z.endEmitted, Z.length), !Z.endEmitted && Z.length === 0 && (Z.endEmitted = !0, K.readable = !1, K.emit("end"), Z.autoDestroy)) {
      var ce = K._writableState;
      (!ce || ce.autoDestroy && ce.finished) && K.destroy();
    }
  }
  typeof Symbol == "function" && (te.from = function(Z, K) {
    return j === void 0 && (j = F4()), j(te, Z, K);
  });
  function he(Z, K) {
    for (var ce = 0, ve = Z.length; ce < ve; ce++)
      if (Z[ce] === K)
        return ce;
    return -1;
  }
  return Mo;
}
var Ro, hl;
function a0() {
  if (hl)
    return Ro;
  hl = 1, Ro = u;
  var e = ui().codes, t = e.ERR_METHOD_NOT_IMPLEMENTED, n = e.ERR_MULTIPLE_CALLBACK, i = e.ERR_TRANSFORM_ALREADY_TRANSFORMING, s = e.ERR_TRANSFORM_WITH_LENGTH_0, r = Tn();
  mt()(u, r);
  function o(f, b) {
    var v = this._transformState;
    v.transforming = !1;
    var m = v.writecb;
    if (m === null)
      return this.emit("error", new n());
    v.writechunk = null, v.writecb = null, b != null && this.push(b), m(f);
    var E = this._readableState;
    E.reading = !1, (E.needReadable || E.length < E.highWaterMark) && this._read(E.highWaterMark);
  }
  function u(f) {
    if (!(this instanceof u))
      return new u(f);
    r.call(this, f), this._transformState = {
      afterTransform: o.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, f && (typeof f.transform == "function" && (this._transform = f.transform), typeof f.flush == "function" && (this._flush = f.flush)), this.on("prefinish", c);
  }
  function c() {
    var f = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(b, v) {
      h(f, b, v);
    }) : h(this, null, null);
  }
  u.prototype.push = function(f, b) {
    return this._transformState.needTransform = !1, r.prototype.push.call(this, f, b);
  }, u.prototype._transform = function(f, b, v) {
    v(new t("_transform()"));
  }, u.prototype._write = function(f, b, v) {
    var m = this._transformState;
    if (m.writecb = v, m.writechunk = f, m.writeencoding = b, !m.transforming) {
      var E = this._readableState;
      (m.needTransform || E.needReadable || E.length < E.highWaterMark) && this._read(E.highWaterMark);
    }
  }, u.prototype._read = function(f) {
    var b = this._transformState;
    b.writechunk !== null && !b.transforming ? (b.transforming = !0, this._transform(b.writechunk, b.writeencoding, b.afterTransform)) : b.needTransform = !0;
  }, u.prototype._destroy = function(f, b) {
    r.prototype._destroy.call(this, f, function(v) {
      b(v);
    });
  };
  function h(f, b, v) {
    if (b)
      return f.emit("error", b);
    if (v != null && f.push(v), f._writableState.length)
      throw new s();
    if (f._transformState.transforming)
      throw new i();
    return f.push(null);
  }
  return Ro;
}
var Bo, ll;
function _b() {
  if (ll)
    return Bo;
  ll = 1, Bo = t;
  var e = a0();
  mt()(t, e);
  function t(n) {
    if (!(this instanceof t))
      return new t(n);
    e.call(this, n);
  }
  return t.prototype._transform = function(n, i, s) {
    s(null, n);
  }, Bo;
}
var Io, dl;
function wb() {
  if (dl)
    return Io;
  dl = 1;
  var e;
  function t(v) {
    var m = !1;
    return function() {
      m || (m = !0, v.apply(void 0, arguments));
    };
  }
  var n = ui().codes, i = n.ERR_MISSING_ARGS, s = n.ERR_STREAM_DESTROYED;
  function r(v) {
    if (v)
      throw v;
  }
  function o(v) {
    return v.setHeader && typeof v.abort == "function";
  }
  function u(v, m, E, M) {
    M = t(M);
    var B = !1;
    v.on("close", function() {
      B = !0;
    }), e === void 0 && (e = df()), e(v, {
      readable: m,
      writable: E
    }, function(T) {
      if (T)
        return M(T);
      B = !0, M();
    });
    var I = !1;
    return function(T) {
      if (!B && !I) {
        if (I = !0, o(v))
          return v.abort();
        if (typeof v.destroy == "function")
          return v.destroy();
        M(T || new s("pipe"));
      }
    };
  }
  function c(v) {
    v();
  }
  function h(v, m) {
    return v.pipe(m);
  }
  function f(v) {
    return !v.length || typeof v[v.length - 1] != "function" ? r : v.pop();
  }
  function b() {
    for (var v = arguments.length, m = new Array(v), E = 0; E < v; E++)
      m[E] = arguments[E];
    var M = f(m);
    if (Array.isArray(m[0]) && (m = m[0]), m.length < 2)
      throw new i("streams");
    var B, I = m.map(function(T, k) {
      var j = k < m.length - 1, N = k > 0;
      return u(T, j, N, function(q) {
        B || (B = q), q && I.forEach(c), !j && (I.forEach(c), M(B));
      });
    });
    return m.reduce(h);
  }
  return Io = b, Io;
}
var pl;
function pf() {
  return pl || (pl = 1, function(e, t) {
    t = e.exports = i0(), t.Stream = t, t.Readable = t, t.Writable = n0(), t.Duplex = Tn(), t.Transform = a0(), t.PassThrough = _b(), t.finished = df(), t.pipeline = wb();
  }(ta, ta.exports)), ta.exports;
}
var vl;
function xb() {
  if (vl)
    return ea;
  vl = 1;
  var e = pb(), t = mt(), n = pf(), i = ea.readyStates = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
  }, s = ea.IncomingMessage = function(r, o, u, c) {
    var h = this;
    if (n.Readable.call(h), h._mode = u, h.headers = {}, h.rawHeaders = [], h.trailers = {}, h.rawTrailers = [], h.on("end", function() {
      process.nextTick(function() {
        h.emit("close");
      });
    }), u === "fetch") {
      let M = function() {
        b.read().then(function(B) {
          if (!h._destroyed) {
            if (c(B.done), B.done) {
              h.push(null);
              return;
            }
            h.push(Buffer.from(B.value)), M();
          }
        }).catch(function(B) {
          c(!0), h._destroyed || h.emit("error", B);
        });
      };
      if (h._fetchResponse = o, h.url = o.url, h.statusCode = o.status, h.statusMessage = o.statusText, o.headers.forEach(function(B, I) {
        h.headers[I.toLowerCase()] = B, h.rawHeaders.push(I, B);
      }), e.writableStream) {
        var f = new WritableStream({
          write: function(B) {
            return c(!1), new Promise(function(I, T) {
              h._destroyed ? T() : h.push(Buffer.from(B)) ? I() : h._resumeFetch = I;
            });
          },
          close: function() {
            c(!0), h._destroyed || h.push(null);
          },
          abort: function(B) {
            c(!0), h._destroyed || h.emit("error", B);
          }
        });
        try {
          o.body.pipeTo(f).catch(function(B) {
            c(!0), h._destroyed || h.emit("error", B);
          });
          return;
        } catch {
        }
      }
      var b = o.body.getReader();
      M();
    } else {
      h._xhr = r, h._pos = 0, h.url = r.responseURL, h.statusCode = r.status, h.statusMessage = r.statusText;
      var v = r.getAllResponseHeaders().split(/\r?\n/);
      if (v.forEach(function(M) {
        var B = M.match(/^([^:]+):\s*(.*)/);
        if (B) {
          var I = B[1].toLowerCase();
          I === "set-cookie" ? (h.headers[I] === void 0 && (h.headers[I] = []), h.headers[I].push(B[2])) : h.headers[I] !== void 0 ? h.headers[I] += ", " + B[2] : h.headers[I] = B[2], h.rawHeaders.push(B[1], B[2]);
        }
      }), h._charset = "x-user-defined", !e.overrideMimeType) {
        var m = h.rawHeaders["mime-type"];
        if (m) {
          var E = m.match(/;\s*charset=([^;])(;|$)/);
          E && (h._charset = E[1].toLowerCase());
        }
        h._charset || (h._charset = "utf-8");
      }
    }
  };
  return t(s, n.Readable), s.prototype._read = function() {
    var r = this, o = r._resumeFetch;
    o && (r._resumeFetch = null, o());
  }, s.prototype._onXHRProgress = function(r) {
    var o = this, u = o._xhr, c = null;
    switch (o._mode) {
      case "text":
        if (c = u.responseText, c.length > o._pos) {
          var h = c.substr(o._pos);
          if (o._charset === "x-user-defined") {
            for (var f = Buffer.alloc(h.length), b = 0; b < h.length; b++)
              f[b] = h.charCodeAt(b) & 255;
            o.push(f);
          } else
            o.push(h, o._charset);
          o._pos = c.length;
        }
        break;
      case "arraybuffer":
        if (u.readyState !== i.DONE || !u.response)
          break;
        c = u.response, o.push(Buffer.from(new Uint8Array(c)));
        break;
      case "moz-chunked-arraybuffer":
        if (c = u.response, u.readyState !== i.LOADING || !c)
          break;
        o.push(Buffer.from(new Uint8Array(c)));
        break;
      case "ms-stream":
        if (c = u.response, u.readyState !== i.LOADING)
          break;
        var v = new Ze.MSStreamReader();
        v.onprogress = function() {
          v.result.byteLength > o._pos && (o.push(Buffer.from(new Uint8Array(v.result.slice(o._pos)))), o._pos = v.result.byteLength);
        }, v.onload = function() {
          r(!0), o.push(null);
        }, v.readAsArrayBuffer(c);
        break;
    }
    o._xhr.readyState === i.DONE && o._mode !== "ms-stream" && (r(!0), o.push(null));
  }, ea;
}
var bl;
function H4() {
  if (bl)
    return zf.exports;
  bl = 1;
  var e = pb(), t = mt(), n = xb(), i = pf(), s = n.IncomingMessage, r = n.readyStates;
  function o(f, b) {
    return e.fetch && b ? "fetch" : e.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : e.msstream ? "ms-stream" : e.arraybuffer && f ? "arraybuffer" : "text";
  }
  var u = zf.exports = function(f) {
    var b = this;
    i.Writable.call(b), b._opts = f, b._body = [], b._headers = {}, f.auth && b.setHeader("Authorization", "Basic " + Buffer.from(f.auth).toString("base64")), Object.keys(f.headers).forEach(function(E) {
      b.setHeader(E, f.headers[E]);
    });
    var v, m = !0;
    if (f.mode === "disable-fetch" || "requestTimeout" in f && !e.abortController)
      m = !1, v = !0;
    else if (f.mode === "prefer-streaming")
      v = !1;
    else if (f.mode === "allow-wrong-content-type")
      v = !e.overrideMimeType;
    else if (!f.mode || f.mode === "default" || f.mode === "prefer-fast")
      v = !0;
    else
      throw new Error("Invalid value for opts.mode");
    b._mode = o(v, m), b._fetchTimer = null, b._socketTimeout = null, b._socketTimer = null, b.on("finish", function() {
      b._onFinish();
    });
  };
  t(u, i.Writable), u.prototype.setHeader = function(f, b) {
    var v = this, m = f.toLowerCase();
    h.indexOf(m) === -1 && (v._headers[m] = {
      name: f,
      value: b
    });
  }, u.prototype.getHeader = function(f) {
    var b = this._headers[f.toLowerCase()];
    return b ? b.value : null;
  }, u.prototype.removeHeader = function(f) {
    var b = this;
    delete b._headers[f.toLowerCase()];
  }, u.prototype._onFinish = function() {
    var f = this;
    if (!f._destroyed) {
      var b = f._opts;
      "timeout" in b && b.timeout !== 0 && f.setTimeout(b.timeout);
      var v = f._headers, m = null;
      b.method !== "GET" && b.method !== "HEAD" && (m = new Blob(f._body, {
        type: (v["content-type"] || {}).value || ""
      }));
      var E = [];
      if (Object.keys(v).forEach(function(T) {
        var k = v[T].name, j = v[T].value;
        Array.isArray(j) ? j.forEach(function(N) {
          E.push([k, N]);
        }) : E.push([k, j]);
      }), f._mode === "fetch") {
        var M = null;
        if (e.abortController) {
          var B = new AbortController();
          M = B.signal, f._fetchAbortController = B, "requestTimeout" in b && b.requestTimeout !== 0 && (f._fetchTimer = Ze.setTimeout(function() {
            f.emit("requestTimeout"), f._fetchAbortController && f._fetchAbortController.abort();
          }, b.requestTimeout));
        }
        Ze.fetch(f._opts.url, {
          method: f._opts.method,
          headers: E,
          body: m || void 0,
          mode: "cors",
          credentials: b.withCredentials ? "include" : "same-origin",
          signal: M
        }).then(function(T) {
          f._fetchResponse = T, f._resetTimers(!1), f._connect();
        }, function(T) {
          f._resetTimers(!0), f._destroyed || f.emit("error", T);
        });
      } else {
        var I = f._xhr = new Ze.XMLHttpRequest();
        try {
          I.open(f._opts.method, f._opts.url, !0);
        } catch (T) {
          process.nextTick(function() {
            f.emit("error", T);
          });
          return;
        }
        "responseType" in I && (I.responseType = f._mode), "withCredentials" in I && (I.withCredentials = !!b.withCredentials), f._mode === "text" && "overrideMimeType" in I && I.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in b && (I.timeout = b.requestTimeout, I.ontimeout = function() {
          f.emit("requestTimeout");
        }), E.forEach(function(T) {
          I.setRequestHeader(T[0], T[1]);
        }), f._response = null, I.onreadystatechange = function() {
          switch (I.readyState) {
            case r.LOADING:
            case r.DONE:
              f._onXHRProgress();
              break;
          }
        }, f._mode === "moz-chunked-arraybuffer" && (I.onprogress = function() {
          f._onXHRProgress();
        }), I.onerror = function() {
          f._destroyed || (f._resetTimers(!0), f.emit("error", new Error("XHR error")));
        };
        try {
          I.send(m);
        } catch (T) {
          process.nextTick(function() {
            f.emit("error", T);
          });
          return;
        }
      }
    }
  };
  function c(f) {
    try {
      var b = f.status;
      return b !== null && b !== 0;
    } catch {
      return !1;
    }
  }
  u.prototype._onXHRProgress = function() {
    var f = this;
    f._resetTimers(!1), !(!c(f._xhr) || f._destroyed) && (f._response || f._connect(), f._response._onXHRProgress(f._resetTimers.bind(f)));
  }, u.prototype._connect = function() {
    var f = this;
    f._destroyed || (f._response = new s(f._xhr, f._fetchResponse, f._mode, f._resetTimers.bind(f)), f._response.on("error", function(b) {
      f.emit("error", b);
    }), f.emit("response", f._response));
  }, u.prototype._write = function(f, b, v) {
    var m = this;
    m._body.push(f), v();
  }, u.prototype._resetTimers = function(f) {
    var b = this;
    Ze.clearTimeout(b._socketTimer), b._socketTimer = null, f ? (Ze.clearTimeout(b._fetchTimer), b._fetchTimer = null) : b._socketTimeout && (b._socketTimer = Ze.setTimeout(function() {
      b.emit("timeout");
    }, b._socketTimeout));
  }, u.prototype.abort = u.prototype.destroy = function(f) {
    var b = this;
    b._destroyed = !0, b._resetTimers(!0), b._response && (b._response._destroyed = !0), b._xhr ? b._xhr.abort() : b._fetchAbortController && b._fetchAbortController.abort(), f && b.emit("error", f);
  }, u.prototype.end = function(f, b, v) {
    var m = this;
    typeof f == "function" && (v = f, f = void 0), i.Writable.prototype.end.call(m, f, b, v);
  }, u.prototype.setTimeout = function(f, b) {
    var v = this;
    b && v.once("timeout", b), v._socketTimeout = f, v._resetTimers(!1);
  }, u.prototype.flushHeaders = function() {
  }, u.prototype.setNoDelay = function() {
  }, u.prototype.setSocketKeepAlive = function() {
  };
  var h = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "date",
    "dnt",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "via"
  ];
  return zf.exports;
}
var To, yl;
function z4() {
  if (yl)
    return To;
  yl = 1, To = t;
  var e = Object.prototype.hasOwnProperty;
  function t() {
    for (var n = {}, i = 0; i < arguments.length; i++) {
      var s = arguments[i];
      for (var r in s)
        e.call(s, r) && (n[r] = s[r]);
    }
    return n;
  }
  return To;
}
var Oo, gl;
function V4() {
  return gl || (gl = 1, Oo = {
    100: "Continue",
    101: "Switching Protocols",
    102: "Processing",
    200: "OK",
    201: "Created",
    202: "Accepted",
    203: "Non-Authoritative Information",
    204: "No Content",
    205: "Reset Content",
    206: "Partial Content",
    207: "Multi-Status",
    208: "Already Reported",
    226: "IM Used",
    300: "Multiple Choices",
    301: "Moved Permanently",
    302: "Found",
    303: "See Other",
    304: "Not Modified",
    305: "Use Proxy",
    307: "Temporary Redirect",
    308: "Permanent Redirect",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Timeout",
    409: "Conflict",
    410: "Gone",
    411: "Length Required",
    412: "Precondition Failed",
    413: "Payload Too Large",
    414: "URI Too Long",
    415: "Unsupported Media Type",
    416: "Range Not Satisfiable",
    417: "Expectation Failed",
    418: "I'm a teapot",
    421: "Misdirected Request",
    422: "Unprocessable Entity",
    423: "Locked",
    424: "Failed Dependency",
    425: "Unordered Collection",
    426: "Upgrade Required",
    428: "Precondition Required",
    429: "Too Many Requests",
    431: "Request Header Fields Too Large",
    451: "Unavailable For Legal Reasons",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Timeout",
    505: "HTTP Version Not Supported",
    506: "Variant Also Negotiates",
    507: "Insufficient Storage",
    508: "Loop Detected",
    509: "Bandwidth Limit Exceeded",
    510: "Not Extended",
    511: "Network Authentication Required"
  }), Oo;
}
var na = { exports: {} }, mi = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
mi.exports;
var ml;
function K4() {
  return ml || (ml = 1, function(e, t) {
    (function(n) {
      var i = t && !t.nodeType && t, s = e && !e.nodeType && e, r = typeof Ze == "object" && Ze;
      (r.global === r || r.window === r || r.self === r) && (n = r);
      var o, u = 2147483647, c = 36, h = 1, f = 26, b = 38, v = 700, m = 72, E = 128, M = "-", B = /^xn--/, I = /[^\x20-\x7E]/, T = /[\x2E\u3002\uFF0E\uFF61]/g, k = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, j = c - h, N = Math.floor, q = String.fromCharCode, D;
      function re(g) {
        throw new RangeError(k[g]);
      }
      function te(g, w) {
        for (var d = g.length, R = []; d--; )
          R[d] = w(g[d]);
        return R;
      }
      function oe(g, w) {
        var d = g.split("@"), R = "";
        d.length > 1 && (R = d[0] + "@", g = d[1]), g = g.replace(T, ".");
        var G = g.split("."), fe = te(G, w).join(".");
        return R + fe;
      }
      function U(g) {
        for (var w = [], d = 0, R = g.length, G, fe; d < R; )
          G = g.charCodeAt(d++), G >= 55296 && G <= 56319 && d < R ? (fe = g.charCodeAt(d++), (fe & 64512) == 56320 ? w.push(((G & 1023) << 10) + (fe & 1023) + 65536) : (w.push(G), d--)) : w.push(G);
        return w;
      }
      function y(g) {
        return te(g, function(w) {
          var d = "";
          return w > 65535 && (w -= 65536, d += q(w >>> 10 & 1023 | 55296), w = 56320 | w & 1023), d += q(w), d;
        }).join("");
      }
      function p(g) {
        return g - 48 < 10 ? g - 22 : g - 65 < 26 ? g - 65 : g - 97 < 26 ? g - 97 : c;
      }
      function a(g, w) {
        return g + 22 + 75 * (g < 26) - ((w != 0) << 5);
      }
      function l(g, w, d) {
        var R = 0;
        for (g = d ? N(g / v) : g >> 1, g += N(g / w); g > j * f >> 1; R += c)
          g = N(g / j);
        return N(R + (j + 1) * g / (g + b));
      }
      function _(g) {
        var w = [], d = g.length, R, G = 0, fe = E, z = m, V, F, ee, he, Z, K, ce, ve, Be;
        for (V = g.lastIndexOf(M), V < 0 && (V = 0), F = 0; F < V; ++F)
          g.charCodeAt(F) >= 128 && re("not-basic"), w.push(g.charCodeAt(F));
        for (ee = V > 0 ? V + 1 : 0; ee < d; ) {
          for (he = G, Z = 1, K = c; ee >= d && re("invalid-input"), ce = p(g.charCodeAt(ee++)), (ce >= c || ce > N((u - G) / Z)) && re("overflow"), G += ce * Z, ve = K <= z ? h : K >= z + f ? f : K - z, !(ce < ve); K += c)
            Be = c - ve, Z > N(u / Be) && re("overflow"), Z *= Be;
          R = w.length + 1, z = l(G - he, R, he == 0), N(G / R) > u - fe && re("overflow"), fe += N(G / R), G %= R, w.splice(G++, 0, fe);
        }
        return y(w);
      }
      function x(g) {
        var w, d, R, G, fe, z, V, F, ee, he, Z, K = [], ce, ve, Be, Q;
        for (g = U(g), ce = g.length, w = E, d = 0, fe = m, z = 0; z < ce; ++z)
          Z = g[z], Z < 128 && K.push(q(Z));
        for (R = G = K.length, G && K.push(M); R < ce; ) {
          for (V = u, z = 0; z < ce; ++z)
            Z = g[z], Z >= w && Z < V && (V = Z);
          for (ve = R + 1, V - w > N((u - d) / ve) && re("overflow"), d += (V - w) * ve, w = V, z = 0; z < ce; ++z)
            if (Z = g[z], Z < w && ++d > u && re("overflow"), Z == w) {
              for (F = d, ee = c; he = ee <= fe ? h : ee >= fe + f ? f : ee - fe, !(F < he); ee += c)
                Q = F - he, Be = c - he, K.push(
                  q(a(he + Q % Be, 0))
                ), F = N(Q / Be);
              K.push(q(a(F, 0))), fe = l(d, ve, R == G), d = 0, ++R;
            }
          ++d, ++w;
        }
        return K.join("");
      }
      function A(g) {
        return oe(g, function(w) {
          return B.test(w) ? _(w.slice(4).toLowerCase()) : w;
        });
      }
      function S(g) {
        return oe(g, function(w) {
          return I.test(w) ? "xn--" + x(w) : w;
        });
      }
      if (o = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        version: "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        ucs2: {
          decode: U,
          encode: y
        },
        decode: _,
        encode: x,
        toASCII: S,
        toUnicode: A
      }, i && s)
        if (e.exports == i)
          s.exports = o;
        else
          for (D in o)
            o.hasOwnProperty(D) && (i[D] = o[D]);
      else
        n.punycode = o;
    })(Ze);
  }(mi, mi.exports)), mi.exports;
}
var ia = { exports: {} }, $n = {}, Po, _l;
function Z4() {
  if (_l)
    return Po;
  _l = 1;
  function e(n, i) {
    return Object.prototype.hasOwnProperty.call(n, i);
  }
  Po = function(n, i, s, r) {
    i = i || "&", s = s || "=";
    var o = {};
    if (typeof n != "string" || n.length === 0)
      return o;
    var u = /\+/g;
    n = n.split(i);
    var c = 1e3;
    r && typeof r.maxKeys == "number" && (c = r.maxKeys);
    var h = n.length;
    c > 0 && h > c && (h = c);
    for (var f = 0; f < h; ++f) {
      var b = n[f].replace(u, "%20"), v = b.indexOf(s), m, E, M, B;
      v >= 0 ? (m = b.substr(0, v), E = b.substr(v + 1)) : (m = b, E = ""), M = decodeURIComponent(m), B = decodeURIComponent(E), e(o, M) ? t(o[M]) ? o[M].push(B) : o[M] = [o[M], B] : o[M] = B;
    }
    return o;
  };
  var t = Array.isArray || function(n) {
    return Object.prototype.toString.call(n) === "[object Array]";
  };
  return Po;
}
var Co, wl;
function G4() {
  if (wl)
    return Co;
  wl = 1;
  var e = function(s) {
    switch (typeof s) {
      case "string":
        return s;
      case "boolean":
        return s ? "true" : "false";
      case "number":
        return isFinite(s) ? s : "";
      default:
        return "";
    }
  };
  Co = function(s, r, o, u) {
    return r = r || "&", o = o || "=", s === null && (s = void 0), typeof s == "object" ? n(i(s), function(c) {
      var h = encodeURIComponent(e(c)) + o;
      return t(s[c]) ? n(s[c], function(f) {
        return h + encodeURIComponent(e(f));
      }).join(r) : h + encodeURIComponent(e(s[c]));
    }).join(r) : u ? encodeURIComponent(e(u)) + o + encodeURIComponent(e(s)) : "";
  };
  var t = Array.isArray || function(s) {
    return Object.prototype.toString.call(s) === "[object Array]";
  };
  function n(s, r) {
    if (s.map)
      return s.map(r);
    for (var o = [], u = 0; u < s.length; u++)
      o.push(r(s[u], u));
    return o;
  }
  var i = Object.keys || function(s) {
    var r = [];
    for (var o in s)
      Object.prototype.hasOwnProperty.call(s, o) && r.push(o);
    return r;
  };
  return Co;
}
var xl;
function W4() {
  return xl || (xl = 1, $n.decode = $n.parse = Z4(), $n.encode = $n.stringify = G4()), $n;
}
var El;
function J4() {
  return El || (El = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var n = W4();
    function i(o) {
      return encodeURIComponent(o);
    }
    function s(o) {
      return decodeURIComponent(o);
    }
    var r = {
      decode: n.decode,
      encode: n.encode,
      parse: n.parse,
      stringify: n.stringify,
      escape: i,
      unescape: s
    };
    Object.defineProperty(t, "decode", {
      enumerable: !0,
      get: function() {
        return n.decode;
      }
    }), Object.defineProperty(t, "encode", {
      enumerable: !0,
      get: function() {
        return n.encode;
      }
    }), Object.defineProperty(t, "parse", {
      enumerable: !0,
      get: function() {
        return n.parse;
      }
    }), Object.defineProperty(t, "stringify", {
      enumerable: !0,
      get: function() {
        return n.stringify;
      }
    }), t.default = r, t.escape = i, t.unescape = s, t = e.exports = r;
  }(ia, ia.exports)), ia.exports;
}
var Sl;
function f0() {
  return Sl || (Sl = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var n = K4(), i = J4();
    function s(H) {
      return H && typeof H == "object" && "default" in H ? H : { default: H };
    }
    var r = /* @__PURE__ */ s(n), o = /* @__PURE__ */ s(i), u = {
      isString: function(H) {
        return typeof H == "string";
      },
      isObject: function(H) {
        return typeof H == "object" && H !== null;
      },
      isNull: function(H) {
        return H === null;
      },
      isNullOrUndefined: function(H) {
        return H == null;
      }
    }, c = r.default, h = u, f = l, b = x, v = A, m = _, E = M;
    function M() {
      this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
    }
    var B = /^([a-z0-9.+-]+:)/i, I = /:[0-9]*$/, T = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, k = ["<", ">", '"', "`", " ", "\r", `
`, "	"], j = ["{", "}", "|", "\\", "^", "`"].concat(k), N = ["'"].concat(j), q = ["%", "/", "?", ";", "#"].concat(N), D = ["/", "?", "#"], re = 255, te = /^[+a-z0-9A-Z_-]{0,63}$/, oe = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, U = {
      javascript: !0,
      "javascript:": !0
    }, y = {
      javascript: !0,
      "javascript:": !0
    }, p = {
      http: !0,
      https: !0,
      ftp: !0,
      gopher: !0,
      file: !0,
      "http:": !0,
      "https:": !0,
      "ftp:": !0,
      "gopher:": !0,
      "file:": !0
    }, a = o.default;
    function l(H, ue, se) {
      if (H && h.isObject(H) && H instanceof M)
        return H;
      var we = new M();
      return we.parse(H, ue, se), we;
    }
    M.prototype.parse = function(H, ue, se) {
      if (!h.isString(H))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof H);
      var we = H.indexOf("?"), Ce = we !== -1 && we < H.indexOf("#") ? "?" : "#", ze = H.split(Ce), Le = /\\/g;
      ze[0] = ze[0].replace(Le, "/"), H = ze.join(Ce);
      var Y = H;
      if (Y = Y.trim(), !se && H.split("#").length === 1) {
        var Se = T.exec(Y);
        if (Se)
          return this.path = Y, this.href = Y, this.pathname = Se[1], Se[2] ? (this.search = Se[2], ue ? this.query = a.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : ue && (this.search = "", this.query = {}), this;
      }
      var Ae = B.exec(Y);
      if (Ae) {
        Ae = Ae[0];
        var je = Ae.toLowerCase();
        this.protocol = je, Y = Y.substr(Ae.length);
      }
      if (se || Ae || Y.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var pe = Y.substr(0, 2) === "//";
        pe && !(Ae && y[Ae]) && (Y = Y.substr(2), this.slashes = !0);
      }
      if (!y[Ae] && (pe || Ae && !p[Ae])) {
        for (var Ee = -1, J = 0; J < D.length; J++) {
          var Ie = Y.indexOf(D[J]);
          Ie !== -1 && (Ee === -1 || Ie < Ee) && (Ee = Ie);
        }
        var ke, P;
        Ee === -1 ? P = Y.lastIndexOf("@") : P = Y.lastIndexOf("@", Ee), P !== -1 && (ke = Y.slice(0, P), Y = Y.slice(P + 1), this.auth = decodeURIComponent(ke)), Ee = -1;
        for (var J = 0; J < q.length; J++) {
          var Ie = Y.indexOf(q[J]);
          Ie !== -1 && (Ee === -1 || Ie < Ee) && (Ee = Ie);
        }
        Ee === -1 && (Ee = Y.length), this.host = Y.slice(0, Ee), Y = Y.slice(Ee), this.parseHost(), this.hostname = this.hostname || "";
        var Me = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!Me)
          for (var be = this.hostname.split(/\./), J = 0, ie = be.length; J < ie; J++) {
            var le = be[J];
            if (le && !le.match(te)) {
              for (var ge = "", Ge = 0, De = le.length; Ge < De; Ge++)
                le.charCodeAt(Ge) > 127 ? ge += "x" : ge += le[Ge];
              if (!ge.match(te)) {
                var Ne = be.slice(0, J), rt = be.slice(J + 1), ft = le.match(oe);
                ft && (Ne.push(ft[1]), rt.unshift(ft[2])), rt.length && (Y = "/" + rt.join(".") + Y), this.hostname = Ne.join(".");
                break;
              }
            }
          }
        this.hostname.length > re ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), Me || (this.hostname = c.toASCII(this.hostname));
        var We = this.port ? ":" + this.port : "", at = this.hostname || "";
        this.host = at + We, this.href += this.host, Me && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), Y[0] !== "/" && (Y = "/" + Y));
      }
      if (!U[je])
        for (var J = 0, ie = N.length; J < ie; J++) {
          var $ = N[J];
          if (Y.indexOf($) !== -1) {
            var X = encodeURIComponent($);
            X === $ && (X = escape($)), Y = Y.split($).join(X);
          }
        }
      var ne = Y.indexOf("#");
      ne !== -1 && (this.hash = Y.substr(ne), Y = Y.slice(0, ne));
      var O = Y.indexOf("?");
      if (O !== -1 ? (this.search = Y.substr(O), this.query = Y.substr(O + 1), ue && (this.query = a.parse(this.query)), Y = Y.slice(0, O)) : ue && (this.search = "", this.query = {}), Y && (this.pathname = Y), p[je] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        var We = this.pathname || "", ae = this.search || "";
        this.path = We + ae;
      }
      return this.href = this.format(), this;
    };
    function _(H) {
      return h.isString(H) && (H = l(H)), H instanceof M ? H.format() : M.prototype.format.call(H);
    }
    M.prototype.format = function() {
      var H = this.auth || "";
      H && (H = encodeURIComponent(H), H = H.replace(/%3A/i, ":"), H += "@");
      var ue = this.protocol || "", se = this.pathname || "", we = this.hash || "", Ce = !1, ze = "";
      this.host ? Ce = H + this.host : this.hostname && (Ce = H + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (Ce += ":" + this.port)), this.query && h.isObject(this.query) && Object.keys(this.query).length && (ze = a.stringify(this.query));
      var Le = this.search || ze && "?" + ze || "";
      return ue && ue.substr(-1) !== ":" && (ue += ":"), this.slashes || (!ue || p[ue]) && Ce !== !1 ? (Ce = "//" + (Ce || ""), se && se.charAt(0) !== "/" && (se = "/" + se)) : Ce || (Ce = ""), we && we.charAt(0) !== "#" && (we = "#" + we), Le && Le.charAt(0) !== "?" && (Le = "?" + Le), se = se.replace(/[?#]/g, function(Y) {
        return encodeURIComponent(Y);
      }), Le = Le.replace("#", "%23"), ue + Ce + se + Le + we;
    };
    function x(H, ue) {
      return l(H, !1, !0).resolve(ue);
    }
    M.prototype.resolve = function(H) {
      return this.resolveObject(l(H, !1, !0)).format();
    };
    function A(H, ue) {
      return H ? l(H, !1, !0).resolveObject(ue) : ue;
    }
    M.prototype.resolveObject = function(H) {
      if (h.isString(H)) {
        var ue = new M();
        ue.parse(H, !1, !0), H = ue;
      }
      for (var se = new M(), we = Object.keys(this), Ce = 0; Ce < we.length; Ce++) {
        var ze = we[Ce];
        se[ze] = this[ze];
      }
      if (se.hash = H.hash, H.href === "")
        return se.href = se.format(), se;
      if (H.slashes && !H.protocol) {
        for (var Le = Object.keys(H), Y = 0; Y < Le.length; Y++) {
          var Se = Le[Y];
          Se !== "protocol" && (se[Se] = H[Se]);
        }
        return p[se.protocol] && se.hostname && !se.pathname && (se.path = se.pathname = "/"), se.href = se.format(), se;
      }
      if (H.protocol && H.protocol !== se.protocol) {
        if (!p[H.protocol]) {
          for (var Ae = Object.keys(H), je = 0; je < Ae.length; je++) {
            var pe = Ae[je];
            se[pe] = H[pe];
          }
          return se.href = se.format(), se;
        }
        if (se.protocol = H.protocol, !H.host && !y[H.protocol]) {
          for (var ie = (H.pathname || "").split("/"); ie.length && !(H.host = ie.shift()); )
            ;
          H.host || (H.host = ""), H.hostname || (H.hostname = ""), ie[0] !== "" && ie.unshift(""), ie.length < 2 && ie.unshift(""), se.pathname = ie.join("/");
        } else
          se.pathname = H.pathname;
        if (se.search = H.search, se.query = H.query, se.host = H.host || "", se.auth = H.auth, se.hostname = H.hostname || H.host, se.port = H.port, se.pathname || se.search) {
          var Ee = se.pathname || "", J = se.search || "";
          se.path = Ee + J;
        }
        return se.slashes = se.slashes || H.slashes, se.href = se.format(), se;
      }
      var Ie = se.pathname && se.pathname.charAt(0) === "/", ke = H.host || H.pathname && H.pathname.charAt(0) === "/", P = ke || Ie || se.host && H.pathname, Me = P, be = se.pathname && se.pathname.split("/") || [], ie = H.pathname && H.pathname.split("/") || [], le = se.protocol && !p[se.protocol];
      if (le && (se.hostname = "", se.port = null, se.host && (be[0] === "" ? be[0] = se.host : be.unshift(se.host)), se.host = "", H.protocol && (H.hostname = null, H.port = null, H.host && (ie[0] === "" ? ie[0] = H.host : ie.unshift(H.host)), H.host = null), P = P && (ie[0] === "" || be[0] === "")), ke)
        se.host = H.host || H.host === "" ? H.host : se.host, se.hostname = H.hostname || H.hostname === "" ? H.hostname : se.hostname, se.search = H.search, se.query = H.query, be = ie;
      else if (ie.length)
        be || (be = []), be.pop(), be = be.concat(ie), se.search = H.search, se.query = H.query;
      else if (!h.isNullOrUndefined(H.search)) {
        if (le) {
          se.hostname = se.host = be.shift();
          var ge = se.host && se.host.indexOf("@") > 0 ? se.host.split("@") : !1;
          ge && (se.auth = ge.shift(), se.host = se.hostname = ge.shift());
        }
        return se.search = H.search, se.query = H.query, (!h.isNull(se.pathname) || !h.isNull(se.search)) && (se.path = (se.pathname ? se.pathname : "") + (se.search ? se.search : "")), se.href = se.format(), se;
      }
      if (!be.length)
        return se.pathname = null, se.search ? se.path = "/" + se.search : se.path = null, se.href = se.format(), se;
      for (var Ge = be.slice(-1)[0], De = (se.host || H.host || be.length > 1) && (Ge === "." || Ge === "..") || Ge === "", Ne = 0, rt = be.length; rt >= 0; rt--)
        Ge = be[rt], Ge === "." ? be.splice(rt, 1) : Ge === ".." ? (be.splice(rt, 1), Ne++) : Ne && (be.splice(rt, 1), Ne--);
      if (!P && !Me)
        for (; Ne--; Ne)
          be.unshift("..");
      P && be[0] !== "" && (!be[0] || be[0].charAt(0) !== "/") && be.unshift(""), De && be.join("/").substr(-1) !== "/" && be.push("");
      var ft = be[0] === "" || be[0] && be[0].charAt(0) === "/";
      if (le) {
        se.hostname = se.host = ft ? "" : be.length ? be.shift() : "";
        var ge = se.host && se.host.indexOf("@") > 0 ? se.host.split("@") : !1;
        ge && (se.auth = ge.shift(), se.host = se.hostname = ge.shift());
      }
      return P = P || se.host && be.length, P && !ft && be.unshift(""), be.length ? se.pathname = be.join("/") : (se.pathname = null, se.path = null), (!h.isNull(se.pathname) || !h.isNull(se.search)) && (se.path = (se.pathname ? se.pathname : "") + (se.search ? se.search : "")), se.auth = H.auth || se.auth, se.slashes = se.slashes || H.slashes, se.href = se.format(), se;
    }, M.prototype.parseHost = function() {
      var H = this.host, ue = I.exec(H);
      ue && (ue = ue[0], ue !== ":" && (this.port = ue.substr(1)), H = H.substr(0, H.length - ue.length)), H && (this.hostname = H);
    };
    function S(H, ue) {
      for (var se = 0, we = H.length - 1; we >= 0; we--) {
        var Ce = H[we];
        Ce === "." ? H.splice(we, 1) : Ce === ".." ? (H.splice(we, 1), se++) : se && (H.splice(we, 1), se--);
      }
      if (ue)
        for (; se--; se)
          H.unshift("..");
      return H;
    }
    function g() {
      for (var H = "", ue = !1, se = arguments.length - 1; se >= -1 && !ue; se--) {
        var we = se >= 0 ? arguments[se] : "/";
        if (typeof we != "string")
          throw new TypeError("Arguments to path.resolve must be strings");
        if (!we)
          continue;
        H = we + "/" + H, ue = we.charAt(0) === "/";
      }
      return H = S(w(H.split("/"), function(Ce) {
        return !!Ce;
      }), !ue).join("/"), (ue ? "/" : "") + H || ".";
    }
    function w(H, ue) {
      if (H.filter)
        return H.filter(ue);
      for (var se = [], we = 0; we < H.length; we++)
        ue(H[we], we, H) && se.push(H[we]);
      return se;
    }
    var d = function(H) {
      function ue() {
        var we = this || self;
        return delete H.prototype.__magic__, we;
      }
      if (typeof globalThis == "object")
        return globalThis;
      if (this)
        return ue();
      H.defineProperty(H.prototype, "__magic__", {
        configurable: !0,
        get: ue
      });
      var se = __magic__;
      return se;
    }(Object), R = (
      /** @type {formatImport}*/
      m
    ), G = (
      /** @type {parseImport}*/
      f
    ), fe = (
      /** @type {resolveImport}*/
      b
    ), z = (
      /** @type {UrlImport}*/
      E
    ), V = d.URL, F = d.URLSearchParams, ee = /%/g, he = /\\/g, Z = /\n/g, K = /\r/g, ce = /\t/g, ve = 47;
    function Be(H) {
      var ue = (
        /** @type {URL|null} */
        H ?? null
      );
      return !!(ue !== null && (ue != null && ue.href) && (ue != null && ue.origin));
    }
    function Q(H) {
      if (H.hostname !== "")
        throw new TypeError('File URL host must be "localhost" or empty on browser');
      for (var ue = H.pathname, se = 0; se < ue.length; se++)
        if (ue[se] === "%") {
          var we = ue.codePointAt(se + 2) | 32;
          if (ue[se + 1] === "2" && we === 102)
            throw new TypeError("File URL path must not include encoded / characters");
        }
      return decodeURIComponent(ue);
    }
    function C(H) {
      return H.includes("%") && (H = H.replace(ee, "%25")), H.includes("\\") && (H = H.replace(he, "%5C")), H.includes(`
`) && (H = H.replace(Z, "%0A")), H.includes("\r") && (H = H.replace(K, "%0D")), H.includes("	") && (H = H.replace(ce, "%09")), H;
    }
    var L = (
      /**
       * @type {domainToASCII}
       */
      function(ue) {
        if (typeof ue > "u")
          throw new TypeError('The "domain" argument must be specified');
        return new V("http://" + ue).hostname;
      }
    ), W = (
      /**
       * @type {domainToUnicode}
       */
      function(ue) {
        if (typeof ue > "u")
          throw new TypeError('The "domain" argument must be specified');
        return new V("http://" + ue).hostname;
      }
    ), de = (
      /**
       * @type {(url: string) => URL}
       */
      function(ue) {
        var se = new V("file://"), we = g(ue), Ce = ue.charCodeAt(ue.length - 1);
        return Ce === ve && we[we.length - 1] !== "/" && (we += "/"), se.pathname = C(we), se;
      }
    ), me = (
      /**
       * @type {fileURLToPath & ((path: string | URL) => string)}
       */
      function(ue) {
        if (!Be(ue) && typeof ue != "string")
          throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof ue + " (" + ue + ")");
        var se = new V(ue);
        if (se.protocol !== "file:")
          throw new TypeError("The URL must be of scheme file");
        return Q(se);
      }
    ), Te = (
      /**
       * @type {(
       *   ((urlObject: URL, options?: URLFormatOptions) => string) &
       *   ((urlObject: UrlObject | string, options?: never) => string)
       * )}
       */
      function(ue, se) {
        var we, Ce, ze;
        if (se === void 0 && (se = {}), !(ue instanceof V))
          return R(ue);
        if (typeof se != "object" || se === null)
          throw new TypeError('The "options" argument must be of type object.');
        var Le = (we = se.auth) != null ? we : !0, Y = (Ce = se.fragment) != null ? Ce : !0, Se = (ze = se.search) != null ? ze : !0, Ae = new V(ue.toString());
        return Le || (Ae.username = "", Ae.password = ""), Y || (Ae.hash = ""), Se || (Ae.search = ""), Ae.toString();
      }
    ), Fe = {
      format: Te,
      parse: G,
      resolve: fe,
      resolveObject: v,
      Url: z,
      URL: V,
      URLSearchParams: F,
      domainToASCII: L,
      domainToUnicode: W,
      pathToFileURL: de,
      fileURLToPath: me
    };
    t.URL = V, t.URLSearchParams = F, t.Url = z, t.default = Fe, t.domainToASCII = L, t.domainToUnicode = W, t.fileURLToPath = me, t.format = Te, t.parse = G, t.pathToFileURL = de, t.resolve = fe, t.resolveObject = v, t = e.exports = Fe;
  }(na, na.exports)), na.exports;
}
var Al;
function Eb() {
  return Al || (Al = 1, function(e) {
    var t = H4(), n = xb(), i = z4(), s = V4(), r = f0(), o = e;
    o.request = function(u, c) {
      typeof u == "string" ? u = r.parse(u) : u = i(u);
      var h = Ze.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", f = u.protocol || h, b = u.hostname || u.host, v = u.port, m = u.path || "/";
      b && b.indexOf(":") !== -1 && (b = "[" + b + "]"), u.url = (b ? f + "//" + b : "") + (v ? ":" + v : "") + m, u.method = (u.method || "GET").toUpperCase(), u.headers = u.headers || {};
      var E = new t(u);
      return c && E.on("response", c), E;
    }, o.get = function(c, h) {
      var f = o.request(c, h);
      return f.end(), f;
    }, o.ClientRequest = t, o.IncomingMessage = n.IncomingMessage, o.Agent = function() {
    }, o.Agent.defaultMaxSockets = 4, o.globalAgent = new o.Agent(), o.STATUS_CODES = s, o.METHODS = [
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REPORT",
      "SEARCH",
      "SUBSCRIBE",
      "TRACE",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
  }(Hf)), Hf;
}
var No = { exports: {} }, Ml;
function X4() {
  return Ml || (Ml = 1, function(e) {
    var t = Eb(), n = f0(), i = e.exports;
    for (var s in t)
      t.hasOwnProperty(s) && (i[s] = t[s]);
    i.request = function(o, u) {
      return o = r(o), t.request.call(this, o, u);
    }, i.get = function(o, u) {
      return o = r(o), t.get.call(this, o, u);
    };
    function r(o) {
      if (typeof o == "string" && (o = n.parse(o)), o.protocol || (o.protocol = "https:"), o.protocol !== "https:")
        throw new Error('Protocol "' + o.protocol + '" not supported. Expected "https:"');
      return o;
    }
  }(No)), No.exports;
}
var Lo = {}, ko, Rl;
function Sb() {
  if (Rl)
    return ko;
  Rl = 1, ko = n;
  var e = ii.EventEmitter, t = mt();
  t(n, e), n.Readable = i0(), n.Writable = n0(), n.Duplex = Tn(), n.Transform = a0(), n.PassThrough = _b(), n.finished = df(), n.pipeline = wb(), n.Stream = n;
  function n() {
    e.call(this);
  }
  return n.prototype.pipe = function(i, s) {
    var r = this;
    function o(m) {
      i.writable && i.write(m) === !1 && r.pause && r.pause();
    }
    r.on("data", o);
    function u() {
      r.readable && r.resume && r.resume();
    }
    i.on("drain", u), !i._isStdio && (!s || s.end !== !1) && (r.on("end", h), r.on("close", f));
    var c = !1;
    function h() {
      c || (c = !0, i.end());
    }
    function f() {
      c || (c = !0, typeof i.destroy == "function" && i.destroy());
    }
    function b(m) {
      if (v(), e.listenerCount(this, "error") === 0)
        throw m;
    }
    r.on("error", b), i.on("error", b);
    function v() {
      r.removeListener("data", o), i.removeListener("drain", u), r.removeListener("end", h), r.removeListener("close", f), r.removeListener("error", b), i.removeListener("error", b), r.removeListener("end", v), r.removeListener("close", v), i.removeListener("close", v);
    }
    return r.on("end", v), r.on("close", v), i.on("close", v), i.emit("pipe", r), i;
  }, ko;
}
var jo = {}, qo = { exports: {} }, Do = {}, Bl;
function Ab() {
  if (Bl)
    return Do;
  Bl = 1;
  function e(N) {
    "@babel/helpers - typeof";
    return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(q) {
      return typeof q;
    } : function(q) {
      return q && typeof Symbol == "function" && q.constructor === Symbol && q !== Symbol.prototype ? "symbol" : typeof q;
    }, e(N);
  }
  function t(N, q) {
    for (var D = 0; D < q.length; D++) {
      var re = q[D];
      re.enumerable = re.enumerable || !1, re.configurable = !0, "value" in re && (re.writable = !0), Object.defineProperty(N, i(re.key), re);
    }
  }
  function n(N, q, D) {
    return q && t(N.prototype, q), D && t(N, D), Object.defineProperty(N, "prototype", { writable: !1 }), N;
  }
  function i(N) {
    var q = s(N, "string");
    return e(q) === "symbol" ? q : String(q);
  }
  function s(N, q) {
    if (e(N) !== "object" || N === null)
      return N;
    var D = N[Symbol.toPrimitive];
    if (D !== void 0) {
      var re = D.call(N, q || "default");
      if (e(re) !== "object")
        return re;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (q === "string" ? String : Number)(N);
  }
  function r(N, q) {
    if (!(N instanceof q))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(N, q) {
    if (typeof q != "function" && q !== null)
      throw new TypeError("Super expression must either be null or a function");
    N.prototype = Object.create(q && q.prototype, { constructor: { value: N, writable: !0, configurable: !0 } }), Object.defineProperty(N, "prototype", { writable: !1 }), q && u(N, q);
  }
  function u(N, q) {
    return u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(re, te) {
      return re.__proto__ = te, re;
    }, u(N, q);
  }
  function c(N) {
    var q = b();
    return function() {
      var re = v(N), te;
      if (q) {
        var oe = v(this).constructor;
        te = Reflect.construct(re, arguments, oe);
      } else
        te = re.apply(this, arguments);
      return h(this, te);
    };
  }
  function h(N, q) {
    if (q && (e(q) === "object" || typeof q == "function"))
      return q;
    if (q !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return f(N);
  }
  function f(N) {
    if (N === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return N;
  }
  function b() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function v(N) {
    return v = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(D) {
      return D.__proto__ || Object.getPrototypeOf(D);
    }, v(N);
  }
  var m = {}, E, M;
  function B(N, q, D) {
    D || (D = Error);
    function re(oe, U, y) {
      return typeof q == "string" ? q : q(oe, U, y);
    }
    var te = /* @__PURE__ */ function(oe) {
      o(y, oe);
      var U = c(y);
      function y(p, a, l) {
        var _;
        return r(this, y), _ = U.call(this, re(p, a, l)), _.code = N, _;
      }
      return n(y);
    }(D);
    m[N] = te;
  }
  function I(N, q) {
    if (Array.isArray(N)) {
      var D = N.length;
      return N = N.map(function(re) {
        return String(re);
      }), D > 2 ? "one of ".concat(q, " ").concat(N.slice(0, D - 1).join(", "), ", or ") + N[D - 1] : D === 2 ? "one of ".concat(q, " ").concat(N[0], " or ").concat(N[1]) : "of ".concat(q, " ").concat(N[0]);
    } else
      return "of ".concat(q, " ").concat(String(N));
  }
  function T(N, q, D) {
    return N.substr(!D || D < 0 ? 0 : +D, q.length) === q;
  }
  function k(N, q, D) {
    return (D === void 0 || D > N.length) && (D = N.length), N.substring(D - q.length, D) === q;
  }
  function j(N, q, D) {
    return typeof D != "number" && (D = 0), D + q.length > N.length ? !1 : N.indexOf(q, D) !== -1;
  }
  return B("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), B("ERR_INVALID_ARG_TYPE", function(N, q, D) {
    E === void 0 && (E = Sa()), E(typeof N == "string", "'name' must be a string");
    var re;
    typeof q == "string" && T(q, "not ") ? (re = "must not be", q = q.replace(/^not /, "")) : re = "must be";
    var te;
    if (k(N, " argument"))
      te = "The ".concat(N, " ").concat(re, " ").concat(I(q, "type"));
    else {
      var oe = j(N, ".") ? "property" : "argument";
      te = 'The "'.concat(N, '" ').concat(oe, " ").concat(re, " ").concat(I(q, "type"));
    }
    return te += ". Received type ".concat(e(D)), te;
  }, TypeError), B("ERR_INVALID_ARG_VALUE", function(N, q) {
    var D = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
    M === void 0 && (M = nn());
    var re = M.inspect(q);
    return re.length > 128 && (re = "".concat(re.slice(0, 128), "...")), "The argument '".concat(N, "' ").concat(D, ". Received ").concat(re);
  }, TypeError), B("ERR_INVALID_RETURN_VALUE", function(N, q, D) {
    var re;
    return D && D.constructor && D.constructor.name ? re = "instance of ".concat(D.constructor.name) : re = "type ".concat(e(D)), "Expected ".concat(N, ' to be returned from the "').concat(q, '"') + " function but got ".concat(re, ".");
  }, TypeError), B("ERR_MISSING_ARGS", function() {
    for (var N = arguments.length, q = new Array(N), D = 0; D < N; D++)
      q[D] = arguments[D];
    E === void 0 && (E = Sa()), E(q.length > 0, "At least one arg needs to be specified");
    var re = "The ", te = q.length;
    switch (q = q.map(function(oe) {
      return '"'.concat(oe, '"');
    }), te) {
      case 1:
        re += "".concat(q[0], " argument");
        break;
      case 2:
        re += "".concat(q[0], " and ").concat(q[1], " arguments");
        break;
      default:
        re += q.slice(0, te - 1).join(", "), re += ", and ".concat(q[te - 1], " arguments");
        break;
    }
    return "".concat(re, " must be specified");
  }, TypeError), Do.codes = m, Do;
}
var $o, Il;
function Y4() {
  if (Il)
    return $o;
  Il = 1;
  function e(S, g) {
    var w = Object.keys(S);
    if (Object.getOwnPropertySymbols) {
      var d = Object.getOwnPropertySymbols(S);
      g && (d = d.filter(function(R) {
        return Object.getOwnPropertyDescriptor(S, R).enumerable;
      })), w.push.apply(w, d);
    }
    return w;
  }
  function t(S) {
    for (var g = 1; g < arguments.length; g++) {
      var w = arguments[g] != null ? arguments[g] : {};
      g % 2 ? e(Object(w), !0).forEach(function(d) {
        n(S, d, w[d]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(S, Object.getOwnPropertyDescriptors(w)) : e(Object(w)).forEach(function(d) {
        Object.defineProperty(S, d, Object.getOwnPropertyDescriptor(w, d));
      });
    }
    return S;
  }
  function n(S, g, w) {
    return g = o(g), g in S ? Object.defineProperty(S, g, { value: w, enumerable: !0, configurable: !0, writable: !0 }) : S[g] = w, S;
  }
  function i(S, g) {
    if (!(S instanceof g))
      throw new TypeError("Cannot call a class as a function");
  }
  function s(S, g) {
    for (var w = 0; w < g.length; w++) {
      var d = g[w];
      d.enumerable = d.enumerable || !1, d.configurable = !0, "value" in d && (d.writable = !0), Object.defineProperty(S, o(d.key), d);
    }
  }
  function r(S, g, w) {
    return g && s(S.prototype, g), w && s(S, w), Object.defineProperty(S, "prototype", { writable: !1 }), S;
  }
  function o(S) {
    var g = u(S, "string");
    return T(g) === "symbol" ? g : String(g);
  }
  function u(S, g) {
    if (T(S) !== "object" || S === null)
      return S;
    var w = S[Symbol.toPrimitive];
    if (w !== void 0) {
      var d = w.call(S, g || "default");
      if (T(d) !== "object")
        return d;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (g === "string" ? String : Number)(S);
  }
  function c(S, g) {
    if (typeof g != "function" && g !== null)
      throw new TypeError("Super expression must either be null or a function");
    S.prototype = Object.create(g && g.prototype, { constructor: { value: S, writable: !0, configurable: !0 } }), Object.defineProperty(S, "prototype", { writable: !1 }), g && B(S, g);
  }
  function h(S) {
    var g = E();
    return function() {
      var d = I(S), R;
      if (g) {
        var G = I(this).constructor;
        R = Reflect.construct(d, arguments, G);
      } else
        R = d.apply(this, arguments);
      return f(this, R);
    };
  }
  function f(S, g) {
    if (g && (T(g) === "object" || typeof g == "function"))
      return g;
    if (g !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return b(S);
  }
  function b(S) {
    if (S === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return S;
  }
  function v(S) {
    var g = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return v = function(d) {
      if (d === null || !M(d))
        return d;
      if (typeof d != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof g < "u") {
        if (g.has(d))
          return g.get(d);
        g.set(d, R);
      }
      function R() {
        return m(d, arguments, I(this).constructor);
      }
      return R.prototype = Object.create(d.prototype, { constructor: { value: R, enumerable: !1, writable: !0, configurable: !0 } }), B(R, d);
    }, v(S);
  }
  function m(S, g, w) {
    return E() ? m = Reflect.construct.bind() : m = function(R, G, fe) {
      var z = [null];
      z.push.apply(z, G);
      var V = Function.bind.apply(R, z), F = new V();
      return fe && B(F, fe.prototype), F;
    }, m.apply(null, arguments);
  }
  function E() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function M(S) {
    return Function.toString.call(S).indexOf("[native code]") !== -1;
  }
  function B(S, g) {
    return B = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, R) {
      return d.__proto__ = R, d;
    }, B(S, g);
  }
  function I(S) {
    return I = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(w) {
      return w.__proto__ || Object.getPrototypeOf(w);
    }, I(S);
  }
  function T(S) {
    "@babel/helpers - typeof";
    return T = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
      return typeof g;
    } : function(g) {
      return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
    }, T(S);
  }
  var k = nn(), j = k.inspect, N = Ab(), q = N.codes.ERR_INVALID_ARG_TYPE;
  function D(S, g, w) {
    return (w === void 0 || w > S.length) && (w = S.length), S.substring(w - g.length, w) === g;
  }
  function re(S, g) {
    if (g = Math.floor(g), S.length == 0 || g == 0)
      return "";
    var w = S.length * g;
    for (g = Math.floor(Math.log(g) / Math.log(2)); g; )
      S += S, g--;
    return S += S.substring(0, w - S.length), S;
  }
  var te = "", oe = "", U = "", y = "", p = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    equal: "Expected values to be loosely equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: "Values identical but not reference-equal:"
  }, a = 10;
  function l(S) {
    var g = Object.keys(S), w = Object.create(Object.getPrototypeOf(S));
    return g.forEach(function(d) {
      w[d] = S[d];
    }), Object.defineProperty(w, "message", {
      value: S.message
    }), w;
  }
  function _(S) {
    return j(S, {
      compact: !1,
      customInspect: !1,
      depth: 1e3,
      maxArrayLength: 1 / 0,
      // Assert compares only enumerable properties (with a few exceptions).
      showHidden: !1,
      // Having a long line as error is better than wrapping the line for
      // comparison for now.
      // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
      // have meta information about the inspected properties (i.e., know where
      // in what line the property starts and ends).
      breakLength: 1 / 0,
      // Assert does not detect proxies currently.
      showProxy: !1,
      sorted: !0,
      // Inspect getters as we also check them when comparing entries.
      getters: !0
    });
  }
  function x(S, g, w) {
    var d = "", R = "", G = 0, fe = "", z = !1, V = _(S), F = V.split(`
`), ee = _(g).split(`
`), he = 0, Z = "";
    if (w === "strictEqual" && T(S) === "object" && T(g) === "object" && S !== null && g !== null && (w = "strictEqualObject"), F.length === 1 && ee.length === 1 && F[0] !== ee[0]) {
      var K = F[0].length + ee[0].length;
      if (K <= a) {
        if ((T(S) !== "object" || S === null) && (T(g) !== "object" || g === null) && (S !== 0 || g !== 0))
          return "".concat(p[w], `

`) + "".concat(F[0], " !== ").concat(ee[0], `
`);
      } else if (w !== "strictEqualObject") {
        var ce = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
        if (K < ce) {
          for (; F[0][he] === ee[0][he]; )
            he++;
          he > 2 && (Z = `
  `.concat(re(" ", he), "^"), he = 0);
        }
      }
    }
    for (var ve = F[F.length - 1], Be = ee[ee.length - 1]; ve === Be && (he++ < 2 ? fe = `
  `.concat(ve).concat(fe) : d = ve, F.pop(), ee.pop(), !(F.length === 0 || ee.length === 0)); )
      ve = F[F.length - 1], Be = ee[ee.length - 1];
    var Q = Math.max(F.length, ee.length);
    if (Q === 0) {
      var C = V.split(`
`);
      if (C.length > 30)
        for (C[26] = "".concat(te, "...").concat(y); C.length > 27; )
          C.pop();
      return "".concat(p.notIdentical, `

`).concat(C.join(`
`), `
`);
    }
    he > 3 && (fe = `
`.concat(te, "...").concat(y).concat(fe), z = !0), d !== "" && (fe = `
  `.concat(d).concat(fe), d = "");
    var L = 0, W = p[w] + `
`.concat(oe, "+ actual").concat(y, " ").concat(U, "- expected").concat(y), de = " ".concat(te, "...").concat(y, " Lines skipped");
    for (he = 0; he < Q; he++) {
      var me = he - G;
      if (F.length < he + 1)
        me > 1 && he > 2 && (me > 4 ? (R += `
`.concat(te, "...").concat(y), z = !0) : me > 3 && (R += `
  `.concat(ee[he - 2]), L++), R += `
  `.concat(ee[he - 1]), L++), G = he, d += `
`.concat(U, "-").concat(y, " ").concat(ee[he]), L++;
      else if (ee.length < he + 1)
        me > 1 && he > 2 && (me > 4 ? (R += `
`.concat(te, "...").concat(y), z = !0) : me > 3 && (R += `
  `.concat(F[he - 2]), L++), R += `
  `.concat(F[he - 1]), L++), G = he, R += `
`.concat(oe, "+").concat(y, " ").concat(F[he]), L++;
      else {
        var Te = ee[he], Fe = F[he], H = Fe !== Te && (!D(Fe, ",") || Fe.slice(0, -1) !== Te);
        H && D(Te, ",") && Te.slice(0, -1) === Fe && (H = !1, Fe += ","), H ? (me > 1 && he > 2 && (me > 4 ? (R += `
`.concat(te, "...").concat(y), z = !0) : me > 3 && (R += `
  `.concat(F[he - 2]), L++), R += `
  `.concat(F[he - 1]), L++), G = he, R += `
`.concat(oe, "+").concat(y, " ").concat(Fe), d += `
`.concat(U, "-").concat(y, " ").concat(Te), L += 2) : (R += d, d = "", (me === 1 || he === 0) && (R += `
  `.concat(Fe), L++));
      }
      if (L > 20 && he < Q - 2)
        return "".concat(W).concat(de, `
`).concat(R, `
`).concat(te, "...").concat(y).concat(d, `
`) + "".concat(te, "...").concat(y);
    }
    return "".concat(W).concat(z ? de : "", `
`).concat(R).concat(d).concat(fe).concat(Z);
  }
  var A = /* @__PURE__ */ function(S, g) {
    c(d, S);
    var w = h(d);
    function d(R) {
      var G;
      if (i(this, d), T(R) !== "object" || R === null)
        throw new q("options", "Object", R);
      var fe = R.message, z = R.operator, V = R.stackStartFn, F = R.actual, ee = R.expected, he = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, fe != null)
        G = w.call(this, String(fe));
      else if (process.stderr && process.stderr.isTTY && (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1 ? (te = "\x1B[34m", oe = "\x1B[32m", y = "\x1B[39m", U = "\x1B[31m") : (te = "", oe = "", y = "", U = "")), T(F) === "object" && F !== null && T(ee) === "object" && ee !== null && "stack" in F && F instanceof Error && "stack" in ee && ee instanceof Error && (F = l(F), ee = l(ee)), z === "deepStrictEqual" || z === "strictEqual")
        G = w.call(this, x(F, ee, z));
      else if (z === "notDeepStrictEqual" || z === "notStrictEqual") {
        var Z = p[z], K = _(F).split(`
`);
        if (z === "notStrictEqual" && T(F) === "object" && F !== null && (Z = p.notStrictEqualObject), K.length > 30)
          for (K[26] = "".concat(te, "...").concat(y); K.length > 27; )
            K.pop();
        K.length === 1 ? G = w.call(this, "".concat(Z, " ").concat(K[0])) : G = w.call(this, "".concat(Z, `

`).concat(K.join(`
`), `
`));
      } else {
        var ce = _(F), ve = "", Be = p[z];
        z === "notDeepEqual" || z === "notEqual" ? (ce = "".concat(p[z], `

`).concat(ce), ce.length > 1024 && (ce = "".concat(ce.slice(0, 1021), "..."))) : (ve = "".concat(_(ee)), ce.length > 512 && (ce = "".concat(ce.slice(0, 509), "...")), ve.length > 512 && (ve = "".concat(ve.slice(0, 509), "...")), z === "deepEqual" || z === "equal" ? ce = "".concat(Be, `

`).concat(ce, `

should equal

`) : ve = " ".concat(z, " ").concat(ve)), G = w.call(this, "".concat(ce).concat(ve));
      }
      return Error.stackTraceLimit = he, G.generatedMessage = !fe, Object.defineProperty(b(G), "name", {
        value: "AssertionError [ERR_ASSERTION]",
        enumerable: !1,
        writable: !0,
        configurable: !0
      }), G.code = "ERR_ASSERTION", G.actual = F, G.expected = ee, G.operator = z, Error.captureStackTrace && Error.captureStackTrace(b(G), V), G.stack, G.name = "AssertionError", f(G);
    }
    return r(d, [{
      key: "toString",
      value: function() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      }
    }, {
      key: g,
      value: function(G, fe) {
        return j(this, t(t({}, fe), {}, {
          customInspect: !1,
          depth: 0
        }));
      }
    }]), d;
  }(/* @__PURE__ */ v(Error), j.custom);
  return $o = A, $o;
}
var Uo, Tl;
function Mb() {
  if (Tl)
    return Uo;
  Tl = 1;
  var e = Object.prototype.toString;
  return Uo = function(n) {
    var i = e.call(n), s = i === "[object Arguments]";
    return s || (s = i !== "[object Array]" && n !== null && typeof n == "object" && typeof n.length == "number" && n.length >= 0 && e.call(n.callee) === "[object Function]"), s;
  }, Uo;
}
var Fo, Ol;
function Q4() {
  if (Ol)
    return Fo;
  Ol = 1;
  var e;
  if (!Object.keys) {
    var t = Object.prototype.hasOwnProperty, n = Object.prototype.toString, i = Mb(), s = Object.prototype.propertyIsEnumerable, r = !s.call({ toString: null }, "toString"), o = s.call(function() {
    }, "prototype"), u = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], c = function(v) {
      var m = v.constructor;
      return m && m.prototype === v;
    }, h = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, f = function() {
      if (typeof window > "u")
        return !1;
      for (var v in window)
        try {
          if (!h["$" + v] && t.call(window, v) && window[v] !== null && typeof window[v] == "object")
            try {
              c(window[v]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), b = function(v) {
      if (typeof window > "u" || !f)
        return c(v);
      try {
        return c(v);
      } catch {
        return !1;
      }
    };
    e = function(m) {
      var E = m !== null && typeof m == "object", M = n.call(m) === "[object Function]", B = i(m), I = E && n.call(m) === "[object String]", T = [];
      if (!E && !M && !B)
        throw new TypeError("Object.keys called on a non-object");
      var k = o && M;
      if (I && m.length > 0 && !t.call(m, 0))
        for (var j = 0; j < m.length; ++j)
          T.push(String(j));
      if (B && m.length > 0)
        for (var N = 0; N < m.length; ++N)
          T.push(String(N));
      else
        for (var q in m)
          !(k && q === "prototype") && t.call(m, q) && T.push(String(q));
      if (r)
        for (var D = b(m), re = 0; re < u.length; ++re)
          !(D && u[re] === "constructor") && t.call(m, u[re]) && T.push(u[re]);
      return T;
    };
  }
  return Fo = e, Fo;
}
var Ho, Pl;
function Rb() {
  if (Pl)
    return Ho;
  Pl = 1;
  var e = Array.prototype.slice, t = Mb(), n = Object.keys, i = n ? function(o) {
    return n(o);
  } : Q4(), s = Object.keys;
  return i.shim = function() {
    if (Object.keys) {
      var o = function() {
        var u = Object.keys(arguments);
        return u && u.length === arguments.length;
      }(1, 2);
      o || (Object.keys = function(c) {
        return t(c) ? s(e.call(c)) : s(c);
      });
    } else
      Object.keys = i;
    return Object.keys || i;
  }, Ho = i, Ho;
}
var zo, Cl;
function e8() {
  if (Cl)
    return zo;
  Cl = 1;
  var e = Rb(), t = e0()(), n = lf(), i = Object, s = n("Array.prototype.push"), r = n("Object.prototype.propertyIsEnumerable"), o = t ? Object.getOwnPropertySymbols : null;
  return zo = function(c, h) {
    if (c == null)
      throw new TypeError("target must be an object");
    var f = i(c);
    if (arguments.length === 1)
      return f;
    for (var b = 1; b < arguments.length; ++b) {
      var v = i(arguments[b]), m = e(v), E = t && (Object.getOwnPropertySymbols || o);
      if (E)
        for (var M = E(v), B = 0; B < M.length; ++B) {
          var I = M[B];
          r(v, I) && s(m, I);
        }
      for (var T = 0; T < m.length; ++T) {
        var k = m[T];
        if (r(v, k)) {
          var j = v[k];
          f[k] = j;
        }
      }
    }
    return f;
  }, zo;
}
var Vo, Nl;
function t8() {
  if (Nl)
    return Vo;
  Nl = 1;
  var e = e8(), t = function() {
    if (!Object.assign)
      return !1;
    for (var i = "abcdefghijklmnopqrst", s = i.split(""), r = {}, o = 0; o < s.length; ++o)
      r[s[o]] = s[o];
    var u = Object.assign({}, r), c = "";
    for (var h in u)
      c += h;
    return i !== c;
  }, n = function() {
    if (!Object.assign || !Object.preventExtensions)
      return !1;
    var i = Object.preventExtensions({ 1: 2 });
    try {
      Object.assign(i, "xy");
    } catch {
      return i[1] === "y";
    }
    return !1;
  };
  return Vo = function() {
    return !Object.assign || t() || n() ? e : Object.assign;
  }, Vo;
}
var Ko, Ll;
function Bb() {
  if (Ll)
    return Ko;
  Ll = 1;
  var e = function(t) {
    return t !== t;
  };
  return Ko = function(n, i) {
    return n === 0 && i === 0 ? 1 / n === 1 / i : !!(n === i || e(n) && e(i));
  }, Ko;
}
var Zo, kl;
function o0() {
  if (kl)
    return Zo;
  kl = 1;
  var e = Bb();
  return Zo = function() {
    return typeof Object.is == "function" ? Object.is : e;
  }, Zo;
}
var Go, jl;
function Ib() {
  if (jl)
    return Go;
  jl = 1;
  var e = Ui(), t = e("%Object.defineProperty%", !0), n = function() {
    if (t)
      try {
        return t({}, "a", { value: 1 }), !0;
      } catch {
        return !1;
      }
    return !1;
  };
  return n.hasArrayLengthDefineBug = function() {
    if (!n())
      return null;
    try {
      return t([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, Go = n, Go;
}
var Wo, ql;
function r8() {
  if (ql)
    return Wo;
  ql = 1;
  var e = Ib()(), t = Ui(), n = e && t("%Object.defineProperty%", !0), i = t("%SyntaxError%"), s = t("%TypeError%"), r = bb();
  return Wo = function(u, c, h) {
    if (!u || typeof u != "object" && typeof u != "function")
      throw new s("`obj` must be an object or a function`");
    if (typeof c != "string" && typeof c != "symbol")
      throw new s("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new s("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new s("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new s("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new s("`loose`, if provided, must be a boolean");
    var f = arguments.length > 3 ? arguments[3] : null, b = arguments.length > 4 ? arguments[4] : null, v = arguments.length > 5 ? arguments[5] : null, m = arguments.length > 6 ? arguments[6] : !1, E = !!r && r(u, c);
    if (n)
      n(u, c, {
        configurable: v === null && E ? E.configurable : !v,
        enumerable: f === null && E ? E.enumerable : !f,
        value: h,
        writable: b === null && E ? E.writable : !b
      });
    else if (m || !f && !b && !v)
      u[c] = h;
    else
      throw new i("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, Wo;
}
var Jo, Dl;
function vf() {
  if (Dl)
    return Jo;
  Dl = 1;
  var e = Rb(), t = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", n = Object.prototype.toString, i = Array.prototype.concat, s = r8(), r = function(h) {
    return typeof h == "function" && n.call(h) === "[object Function]";
  }, o = Ib()(), u = function(h, f, b, v) {
    if (f in h) {
      if (v === !0) {
        if (h[f] === b)
          return;
      } else if (!r(v) || !v())
        return;
    }
    o ? s(h, f, b, !0) : s(h, f, b);
  }, c = function(h, f) {
    var b = arguments.length > 2 ? arguments[2] : {}, v = e(f);
    t && (v = i.call(v, Object.getOwnPropertySymbols(f)));
    for (var m = 0; m < v.length; m += 1)
      u(h, v[m], f[v[m]], b[v[m]]);
  };
  return c.supportsDescriptors = !!o, Jo = c, Jo;
}
var Xo, $l;
function n8() {
  if ($l)
    return Xo;
  $l = 1;
  var e = o0(), t = vf();
  return Xo = function() {
    var i = e();
    return t(Object, { is: i }, {
      is: function() {
        return Object.is !== i;
      }
    }), i;
  }, Xo;
}
var Yo, Ul;
function i8() {
  if (Ul)
    return Yo;
  Ul = 1;
  var e = vf(), t = hf(), n = Bb(), i = o0(), s = n8(), r = t(i(), Object);
  return e(r, {
    getPolyfill: i,
    implementation: n,
    shim: s
  }), Yo = r, Yo;
}
var Qo, Fl;
function Tb() {
  return Fl || (Fl = 1, Qo = function(t) {
    return t !== t;
  }), Qo;
}
var es, Hl;
function Ob() {
  if (Hl)
    return es;
  Hl = 1;
  var e = Tb();
  return es = function() {
    return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : e;
  }, es;
}
var ts, zl;
function a8() {
  if (zl)
    return ts;
  zl = 1;
  var e = vf(), t = Ob();
  return ts = function() {
    var i = t();
    return e(Number, { isNaN: i }, {
      isNaN: function() {
        return Number.isNaN !== i;
      }
    }), i;
  }, ts;
}
var rs, Vl;
function f8() {
  if (Vl)
    return rs;
  Vl = 1;
  var e = hf(), t = vf(), n = Tb(), i = Ob(), s = a8(), r = e(i(), Number);
  return t(r, {
    getPolyfill: i,
    implementation: n,
    shim: s
  }), rs = r, rs;
}
var ns, Kl;
function o8() {
  if (Kl)
    return ns;
  Kl = 1;
  function e(H, ue) {
    return r(H) || s(H, ue) || n(H, ue) || t();
  }
  function t() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function n(H, ue) {
    if (H) {
      if (typeof H == "string")
        return i(H, ue);
      var se = Object.prototype.toString.call(H).slice(8, -1);
      if (se === "Object" && H.constructor && (se = H.constructor.name), se === "Map" || se === "Set")
        return Array.from(H);
      if (se === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(se))
        return i(H, ue);
    }
  }
  function i(H, ue) {
    (ue == null || ue > H.length) && (ue = H.length);
    for (var se = 0, we = new Array(ue); se < ue; se++)
      we[se] = H[se];
    return we;
  }
  function s(H, ue) {
    var se = H == null ? null : typeof Symbol < "u" && H[Symbol.iterator] || H["@@iterator"];
    if (se != null) {
      var we, Ce, ze, Le, Y = [], Se = !0, Ae = !1;
      try {
        if (ze = (se = se.call(H)).next, ue === 0) {
          if (Object(se) !== se)
            return;
          Se = !1;
        } else
          for (; !(Se = (we = ze.call(se)).done) && (Y.push(we.value), Y.length !== ue); Se = !0)
            ;
      } catch (je) {
        Ae = !0, Ce = je;
      } finally {
        try {
          if (!Se && se.return != null && (Le = se.return(), Object(Le) !== Le))
            return;
        } finally {
          if (Ae)
            throw Ce;
        }
      }
      return Y;
    }
  }
  function r(H) {
    if (Array.isArray(H))
      return H;
  }
  function o(H) {
    "@babel/helpers - typeof";
    return o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ue) {
      return typeof ue;
    } : function(ue) {
      return ue && typeof Symbol == "function" && ue.constructor === Symbol && ue !== Symbol.prototype ? "symbol" : typeof ue;
    }, o(H);
  }
  var u = /a/g.flags !== void 0, c = function(ue) {
    var se = [];
    return ue.forEach(function(we) {
      return se.push(we);
    }), se;
  }, h = function(ue) {
    var se = [];
    return ue.forEach(function(we, Ce) {
      return se.push([Ce, we]);
    }), se;
  }, f = Object.is ? Object.is : i8(), b = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
  }, v = Number.isNaN ? Number.isNaN : f8();
  function m(H) {
    return H.call.bind(H);
  }
  var E = m(Object.prototype.hasOwnProperty), M = m(Object.prototype.propertyIsEnumerable), B = m(Object.prototype.toString), I = nn().types, T = I.isAnyArrayBuffer, k = I.isArrayBufferView, j = I.isDate, N = I.isMap, q = I.isRegExp, D = I.isSet, re = I.isNativeError, te = I.isBoxedPrimitive, oe = I.isNumberObject, U = I.isStringObject, y = I.isBooleanObject, p = I.isBigIntObject, a = I.isSymbolObject, l = I.isFloat32Array, _ = I.isFloat64Array;
  function x(H) {
    if (H.length === 0 || H.length > 10)
      return !0;
    for (var ue = 0; ue < H.length; ue++) {
      var se = H.charCodeAt(ue);
      if (se < 48 || se > 57)
        return !0;
    }
    return H.length === 10 && H >= Math.pow(2, 32);
  }
  function A(H) {
    return Object.keys(H).filter(x).concat(b(H).filter(Object.prototype.propertyIsEnumerable.bind(H)));
  }
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  function S(H, ue) {
    if (H === ue)
      return 0;
    for (var se = H.length, we = ue.length, Ce = 0, ze = Math.min(se, we); Ce < ze; ++Ce)
      if (H[Ce] !== ue[Ce]) {
        se = H[Ce], we = ue[Ce];
        break;
      }
    return se < we ? -1 : we < se ? 1 : 0;
  }
  var g = !0, w = !1, d = 0, R = 1, G = 2, fe = 3;
  function z(H, ue) {
    return u ? H.source === ue.source && H.flags === ue.flags : RegExp.prototype.toString.call(H) === RegExp.prototype.toString.call(ue);
  }
  function V(H, ue) {
    if (H.byteLength !== ue.byteLength)
      return !1;
    for (var se = 0; se < H.byteLength; se++)
      if (H[se] !== ue[se])
        return !1;
    return !0;
  }
  function F(H, ue) {
    return H.byteLength !== ue.byteLength ? !1 : S(new Uint8Array(H.buffer, H.byteOffset, H.byteLength), new Uint8Array(ue.buffer, ue.byteOffset, ue.byteLength)) === 0;
  }
  function ee(H, ue) {
    return H.byteLength === ue.byteLength && S(new Uint8Array(H), new Uint8Array(ue)) === 0;
  }
  function he(H, ue) {
    return oe(H) ? oe(ue) && f(Number.prototype.valueOf.call(H), Number.prototype.valueOf.call(ue)) : U(H) ? U(ue) && String.prototype.valueOf.call(H) === String.prototype.valueOf.call(ue) : y(H) ? y(ue) && Boolean.prototype.valueOf.call(H) === Boolean.prototype.valueOf.call(ue) : p(H) ? p(ue) && BigInt.prototype.valueOf.call(H) === BigInt.prototype.valueOf.call(ue) : a(ue) && Symbol.prototype.valueOf.call(H) === Symbol.prototype.valueOf.call(ue);
  }
  function Z(H, ue, se, we) {
    if (H === ue)
      return H !== 0 ? !0 : se ? f(H, ue) : !0;
    if (se) {
      if (o(H) !== "object")
        return typeof H == "number" && v(H) && v(ue);
      if (o(ue) !== "object" || H === null || ue === null || Object.getPrototypeOf(H) !== Object.getPrototypeOf(ue))
        return !1;
    } else {
      if (H === null || o(H) !== "object")
        return ue === null || o(ue) !== "object" ? H == ue : !1;
      if (ue === null || o(ue) !== "object")
        return !1;
    }
    var Ce = B(H), ze = B(ue);
    if (Ce !== ze)
      return !1;
    if (Array.isArray(H)) {
      if (H.length !== ue.length)
        return !1;
      var Le = A(H), Y = A(ue);
      return Le.length !== Y.length ? !1 : ce(H, ue, se, we, R, Le);
    }
    if (Ce === "[object Object]" && (!N(H) && N(ue) || !D(H) && D(ue)))
      return !1;
    if (j(H)) {
      if (!j(ue) || Date.prototype.getTime.call(H) !== Date.prototype.getTime.call(ue))
        return !1;
    } else if (q(H)) {
      if (!q(ue) || !z(H, ue))
        return !1;
    } else if (re(H) || H instanceof Error) {
      if (H.message !== ue.message || H.name !== ue.name)
        return !1;
    } else if (k(H)) {
      if (!se && (l(H) || _(H))) {
        if (!V(H, ue))
          return !1;
      } else if (!F(H, ue))
        return !1;
      var Se = A(H), Ae = A(ue);
      return Se.length !== Ae.length ? !1 : ce(H, ue, se, we, d, Se);
    } else {
      if (D(H))
        return !D(ue) || H.size !== ue.size ? !1 : ce(H, ue, se, we, G);
      if (N(H))
        return !N(ue) || H.size !== ue.size ? !1 : ce(H, ue, se, we, fe);
      if (T(H)) {
        if (!ee(H, ue))
          return !1;
      } else if (te(H) && !he(H, ue))
        return !1;
    }
    return ce(H, ue, se, we, d);
  }
  function K(H, ue) {
    return ue.filter(function(se) {
      return M(H, se);
    });
  }
  function ce(H, ue, se, we, Ce, ze) {
    if (arguments.length === 5) {
      ze = Object.keys(H);
      var Le = Object.keys(ue);
      if (ze.length !== Le.length)
        return !1;
    }
    for (var Y = 0; Y < ze.length; Y++)
      if (!E(ue, ze[Y]))
        return !1;
    if (se && arguments.length === 5) {
      var Se = b(H);
      if (Se.length !== 0) {
        var Ae = 0;
        for (Y = 0; Y < Se.length; Y++) {
          var je = Se[Y];
          if (M(H, je)) {
            if (!M(ue, je))
              return !1;
            ze.push(je), Ae++;
          } else if (M(ue, je))
            return !1;
        }
        var pe = b(ue);
        if (Se.length !== pe.length && K(ue, pe).length !== Ae)
          return !1;
      } else {
        var Ee = b(ue);
        if (Ee.length !== 0 && K(ue, Ee).length !== 0)
          return !1;
      }
    }
    if (ze.length === 0 && (Ce === d || Ce === R && H.length === 0 || H.size === 0))
      return !0;
    if (we === void 0)
      we = {
        val1: /* @__PURE__ */ new Map(),
        val2: /* @__PURE__ */ new Map(),
        position: 0
      };
    else {
      var J = we.val1.get(H);
      if (J !== void 0) {
        var Ie = we.val2.get(ue);
        if (Ie !== void 0)
          return J === Ie;
      }
      we.position++;
    }
    we.val1.set(H, we.position), we.val2.set(ue, we.position);
    var ke = me(H, ue, se, ze, we, Ce);
    return we.val1.delete(H), we.val2.delete(ue), ke;
  }
  function ve(H, ue, se, we) {
    for (var Ce = c(H), ze = 0; ze < Ce.length; ze++) {
      var Le = Ce[ze];
      if (Z(ue, Le, se, we))
        return H.delete(Le), !0;
    }
    return !1;
  }
  function Be(H) {
    switch (o(H)) {
      case "undefined":
        return null;
      case "object":
        return;
      case "symbol":
        return !1;
      case "string":
        H = +H;
      case "number":
        if (v(H))
          return !1;
    }
    return !0;
  }
  function Q(H, ue, se) {
    var we = Be(se);
    return we ?? (ue.has(we) && !H.has(we));
  }
  function C(H, ue, se, we, Ce) {
    var ze = Be(se);
    if (ze != null)
      return ze;
    var Le = ue.get(ze);
    return Le === void 0 && !ue.has(ze) || !Z(we, Le, !1, Ce) ? !1 : !H.has(ze) && Z(we, Le, !1, Ce);
  }
  function L(H, ue, se, we) {
    for (var Ce = null, ze = c(H), Le = 0; Le < ze.length; Le++) {
      var Y = ze[Le];
      if (o(Y) === "object" && Y !== null)
        Ce === null && (Ce = /* @__PURE__ */ new Set()), Ce.add(Y);
      else if (!ue.has(Y)) {
        if (se || !Q(H, ue, Y))
          return !1;
        Ce === null && (Ce = /* @__PURE__ */ new Set()), Ce.add(Y);
      }
    }
    if (Ce !== null) {
      for (var Se = c(ue), Ae = 0; Ae < Se.length; Ae++) {
        var je = Se[Ae];
        if (o(je) === "object" && je !== null) {
          if (!ve(Ce, je, se, we))
            return !1;
        } else if (!se && !H.has(je) && !ve(Ce, je, se, we))
          return !1;
      }
      return Ce.size === 0;
    }
    return !0;
  }
  function W(H, ue, se, we, Ce, ze) {
    for (var Le = c(H), Y = 0; Y < Le.length; Y++) {
      var Se = Le[Y];
      if (Z(se, Se, Ce, ze) && Z(we, ue.get(Se), Ce, ze))
        return H.delete(Se), !0;
    }
    return !1;
  }
  function de(H, ue, se, we) {
    for (var Ce = null, ze = h(H), Le = 0; Le < ze.length; Le++) {
      var Y = e(ze[Le], 2), Se = Y[0], Ae = Y[1];
      if (o(Se) === "object" && Se !== null)
        Ce === null && (Ce = /* @__PURE__ */ new Set()), Ce.add(Se);
      else {
        var je = ue.get(Se);
        if (je === void 0 && !ue.has(Se) || !Z(Ae, je, se, we)) {
          if (se || !C(H, ue, Se, Ae, we))
            return !1;
          Ce === null && (Ce = /* @__PURE__ */ new Set()), Ce.add(Se);
        }
      }
    }
    if (Ce !== null) {
      for (var pe = h(ue), Ee = 0; Ee < pe.length; Ee++) {
        var J = e(pe[Ee], 2), Ie = J[0], ke = J[1];
        if (o(Ie) === "object" && Ie !== null) {
          if (!W(Ce, H, Ie, ke, se, we))
            return !1;
        } else if (!se && (!H.has(Ie) || !Z(H.get(Ie), ke, !1, we)) && !W(Ce, H, Ie, ke, !1, we))
          return !1;
      }
      return Ce.size === 0;
    }
    return !0;
  }
  function me(H, ue, se, we, Ce, ze) {
    var Le = 0;
    if (ze === G) {
      if (!L(H, ue, se, Ce))
        return !1;
    } else if (ze === fe) {
      if (!de(H, ue, se, Ce))
        return !1;
    } else if (ze === R)
      for (; Le < H.length; Le++)
        if (E(H, Le)) {
          if (!E(ue, Le) || !Z(H[Le], ue[Le], se, Ce))
            return !1;
        } else {
          if (E(ue, Le))
            return !1;
          for (var Y = Object.keys(H); Le < Y.length; Le++) {
            var Se = Y[Le];
            if (!E(ue, Se) || !Z(H[Se], ue[Se], se, Ce))
              return !1;
          }
          return Y.length === Object.keys(ue).length;
        }
    for (Le = 0; Le < we.length; Le++) {
      var Ae = we[Le];
      if (!Z(H[Ae], ue[Ae], se, Ce))
        return !1;
    }
    return !0;
  }
  function Te(H, ue) {
    return Z(H, ue, w);
  }
  function Fe(H, ue) {
    return Z(H, ue, g);
  }
  return ns = {
    isDeepEqual: Te,
    isDeepStrictEqual: Fe
  }, ns;
}
var Zl;
function Sa() {
  if (Zl)
    return qo.exports;
  Zl = 1;
  function e(V) {
    "@babel/helpers - typeof";
    return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(F) {
      return typeof F;
    } : function(F) {
      return F && typeof Symbol == "function" && F.constructor === Symbol && F !== Symbol.prototype ? "symbol" : typeof F;
    }, e(V);
  }
  function t(V, F) {
    for (var ee = 0; ee < F.length; ee++) {
      var he = F[ee];
      he.enumerable = he.enumerable || !1, he.configurable = !0, "value" in he && (he.writable = !0), Object.defineProperty(V, i(he.key), he);
    }
  }
  function n(V, F, ee) {
    return F && t(V.prototype, F), ee && t(V, ee), Object.defineProperty(V, "prototype", { writable: !1 }), V;
  }
  function i(V) {
    var F = s(V, "string");
    return e(F) === "symbol" ? F : String(F);
  }
  function s(V, F) {
    if (e(V) !== "object" || V === null)
      return V;
    var ee = V[Symbol.toPrimitive];
    if (ee !== void 0) {
      var he = ee.call(V, F || "default");
      if (e(he) !== "object")
        return he;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (F === "string" ? String : Number)(V);
  }
  function r(V, F) {
    if (!(V instanceof F))
      throw new TypeError("Cannot call a class as a function");
  }
  var o = Ab(), u = o.codes, c = u.ERR_AMBIGUOUS_ARGUMENT, h = u.ERR_INVALID_ARG_TYPE, f = u.ERR_INVALID_ARG_VALUE, b = u.ERR_INVALID_RETURN_VALUE, v = u.ERR_MISSING_ARGS, m = Y4(), E = nn(), M = E.inspect, B = nn().types, I = B.isPromise, T = B.isRegExp, k = t8()(), j = o0()(), N = lf()("RegExp.prototype.test"), q, D;
  function re() {
    var V = o8();
    q = V.isDeepEqual, D = V.isDeepStrictEqual;
  }
  var te = !1, oe = qo.exports = l, U = {};
  function y(V) {
    throw V.message instanceof Error ? V.message : new m(V);
  }
  function p(V, F, ee, he, Z) {
    var K = arguments.length, ce;
    if (K === 0)
      ce = "Failed";
    else if (K === 1)
      ee = V, V = void 0;
    else {
      if (te === !1) {
        te = !0;
        var ve = process.emitWarning ? process.emitWarning : console.warn.bind(console);
        ve("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      K === 2 && (he = "!=");
    }
    if (ee instanceof Error)
      throw ee;
    var Be = {
      actual: V,
      expected: F,
      operator: he === void 0 ? "fail" : he,
      stackStartFn: Z || p
    };
    ee !== void 0 && (Be.message = ee);
    var Q = new m(Be);
    throw ce && (Q.message = ce, Q.generatedMessage = !0), Q;
  }
  oe.fail = p, oe.AssertionError = m;
  function a(V, F, ee, he) {
    if (!ee) {
      var Z = !1;
      if (F === 0)
        Z = !0, he = "No value argument passed to `assert.ok()`";
      else if (he instanceof Error)
        throw he;
      var K = new m({
        actual: ee,
        expected: !0,
        message: he,
        operator: "==",
        stackStartFn: V
      });
      throw K.generatedMessage = Z, K;
    }
  }
  function l() {
    for (var V = arguments.length, F = new Array(V), ee = 0; ee < V; ee++)
      F[ee] = arguments[ee];
    a.apply(void 0, [l, F.length].concat(F));
  }
  oe.ok = l, oe.equal = function V(F, ee, he) {
    if (arguments.length < 2)
      throw new v("actual", "expected");
    F != ee && y({
      actual: F,
      expected: ee,
      message: he,
      operator: "==",
      stackStartFn: V
    });
  }, oe.notEqual = function V(F, ee, he) {
    if (arguments.length < 2)
      throw new v("actual", "expected");
    F == ee && y({
      actual: F,
      expected: ee,
      message: he,
      operator: "!=",
      stackStartFn: V
    });
  }, oe.deepEqual = function V(F, ee, he) {
    if (arguments.length < 2)
      throw new v("actual", "expected");
    q === void 0 && re(), q(F, ee) || y({
      actual: F,
      expected: ee,
      message: he,
      operator: "deepEqual",
      stackStartFn: V
    });
  }, oe.notDeepEqual = function V(F, ee, he) {
    if (arguments.length < 2)
      throw new v("actual", "expected");
    q === void 0 && re(), q(F, ee) && y({
      actual: F,
      expected: ee,
      message: he,
      operator: "notDeepEqual",
      stackStartFn: V
    });
  }, oe.deepStrictEqual = function V(F, ee, he) {
    if (arguments.length < 2)
      throw new v("actual", "expected");
    q === void 0 && re(), D(F, ee) || y({
      actual: F,
      expected: ee,
      message: he,
      operator: "deepStrictEqual",
      stackStartFn: V
    });
  }, oe.notDeepStrictEqual = _;
  function _(V, F, ee) {
    if (arguments.length < 2)
      throw new v("actual", "expected");
    q === void 0 && re(), D(V, F) && y({
      actual: V,
      expected: F,
      message: ee,
      operator: "notDeepStrictEqual",
      stackStartFn: _
    });
  }
  oe.strictEqual = function V(F, ee, he) {
    if (arguments.length < 2)
      throw new v("actual", "expected");
    j(F, ee) || y({
      actual: F,
      expected: ee,
      message: he,
      operator: "strictEqual",
      stackStartFn: V
    });
  }, oe.notStrictEqual = function V(F, ee, he) {
    if (arguments.length < 2)
      throw new v("actual", "expected");
    j(F, ee) && y({
      actual: F,
      expected: ee,
      message: he,
      operator: "notStrictEqual",
      stackStartFn: V
    });
  };
  var x = /* @__PURE__ */ n(function V(F, ee, he) {
    var Z = this;
    r(this, V), ee.forEach(function(K) {
      K in F && (he !== void 0 && typeof he[K] == "string" && T(F[K]) && N(F[K], he[K]) ? Z[K] = he[K] : Z[K] = F[K]);
    });
  });
  function A(V, F, ee, he, Z, K) {
    if (!(ee in V) || !D(V[ee], F[ee])) {
      if (!he) {
        var ce = new x(V, Z), ve = new x(F, Z, V), Be = new m({
          actual: ce,
          expected: ve,
          operator: "deepStrictEqual",
          stackStartFn: K
        });
        throw Be.actual = V, Be.expected = F, Be.operator = K.name, Be;
      }
      y({
        actual: V,
        expected: F,
        message: he,
        operator: K.name,
        stackStartFn: K
      });
    }
  }
  function S(V, F, ee, he) {
    if (typeof F != "function") {
      if (T(F))
        return N(F, V);
      if (arguments.length === 2)
        throw new h("expected", ["Function", "RegExp"], F);
      if (e(V) !== "object" || V === null) {
        var Z = new m({
          actual: V,
          expected: F,
          message: ee,
          operator: "deepStrictEqual",
          stackStartFn: he
        });
        throw Z.operator = he.name, Z;
      }
      var K = Object.keys(F);
      if (F instanceof Error)
        K.push("name", "message");
      else if (K.length === 0)
        throw new f("error", F, "may not be an empty object");
      return q === void 0 && re(), K.forEach(function(ce) {
        typeof V[ce] == "string" && T(F[ce]) && N(F[ce], V[ce]) || A(V, F, ce, ee, K, he);
      }), !0;
    }
    return F.prototype !== void 0 && V instanceof F ? !0 : Error.isPrototypeOf(F) ? !1 : F.call({}, V) === !0;
  }
  function g(V) {
    if (typeof V != "function")
      throw new h("fn", "Function", V);
    try {
      V();
    } catch (F) {
      return F;
    }
    return U;
  }
  function w(V) {
    return I(V) || V !== null && e(V) === "object" && typeof V.then == "function" && typeof V.catch == "function";
  }
  function d(V) {
    return Promise.resolve().then(function() {
      var F;
      if (typeof V == "function") {
        if (F = V(), !w(F))
          throw new b("instance of Promise", "promiseFn", F);
      } else if (w(V))
        F = V;
      else
        throw new h("promiseFn", ["Function", "Promise"], V);
      return Promise.resolve().then(function() {
        return F;
      }).then(function() {
        return U;
      }).catch(function(ee) {
        return ee;
      });
    });
  }
  function R(V, F, ee, he) {
    if (typeof ee == "string") {
      if (arguments.length === 4)
        throw new h("error", ["Object", "Error", "Function", "RegExp"], ee);
      if (e(F) === "object" && F !== null) {
        if (F.message === ee)
          throw new c("error/message", 'The error message "'.concat(F.message, '" is identical to the message.'));
      } else if (F === ee)
        throw new c("error/message", 'The error "'.concat(F, '" is identical to the message.'));
      he = ee, ee = void 0;
    } else if (ee != null && e(ee) !== "object" && typeof ee != "function")
      throw new h("error", ["Object", "Error", "Function", "RegExp"], ee);
    if (F === U) {
      var Z = "";
      ee && ee.name && (Z += " (".concat(ee.name, ")")), Z += he ? ": ".concat(he) : ".";
      var K = V.name === "rejects" ? "rejection" : "exception";
      y({
        actual: void 0,
        expected: ee,
        operator: V.name,
        message: "Missing expected ".concat(K).concat(Z),
        stackStartFn: V
      });
    }
    if (ee && !S(F, ee, he, V))
      throw F;
  }
  function G(V, F, ee, he) {
    if (F !== U) {
      if (typeof ee == "string" && (he = ee, ee = void 0), !ee || S(F, ee)) {
        var Z = he ? ": ".concat(he) : ".", K = V.name === "doesNotReject" ? "rejection" : "exception";
        y({
          actual: F,
          expected: ee,
          operator: V.name,
          message: "Got unwanted ".concat(K).concat(Z, `
`) + 'Actual message: "'.concat(F && F.message, '"'),
          stackStartFn: V
        });
      }
      throw F;
    }
  }
  oe.throws = function V(F) {
    for (var ee = arguments.length, he = new Array(ee > 1 ? ee - 1 : 0), Z = 1; Z < ee; Z++)
      he[Z - 1] = arguments[Z];
    R.apply(void 0, [V, g(F)].concat(he));
  }, oe.rejects = function V(F) {
    for (var ee = arguments.length, he = new Array(ee > 1 ? ee - 1 : 0), Z = 1; Z < ee; Z++)
      he[Z - 1] = arguments[Z];
    return d(F).then(function(K) {
      return R.apply(void 0, [V, K].concat(he));
    });
  }, oe.doesNotThrow = function V(F) {
    for (var ee = arguments.length, he = new Array(ee > 1 ? ee - 1 : 0), Z = 1; Z < ee; Z++)
      he[Z - 1] = arguments[Z];
    G.apply(void 0, [V, g(F)].concat(he));
  }, oe.doesNotReject = function V(F) {
    for (var ee = arguments.length, he = new Array(ee > 1 ? ee - 1 : 0), Z = 1; Z < ee; Z++)
      he[Z - 1] = arguments[Z];
    return d(F).then(function(K) {
      return G.apply(void 0, [V, K].concat(he));
    });
  }, oe.ifError = function V(F) {
    if (F != null) {
      var ee = "ifError got unwanted exception: ";
      e(F) === "object" && typeof F.message == "string" ? F.message.length === 0 && F.constructor ? ee += F.constructor.name : ee += F.message : ee += M(F);
      var he = new m({
        actual: F,
        expected: null,
        operator: "ifError",
        message: ee,
        stackStartFn: V
      }), Z = F.stack;
      if (typeof Z == "string") {
        var K = Z.split(`
`);
        K.shift();
        for (var ce = he.stack.split(`
`), ve = 0; ve < K.length; ve++) {
          var Be = ce.indexOf(K[ve]);
          if (Be !== -1) {
            ce = ce.slice(0, Be);
            break;
          }
        }
        he.stack = "".concat(ce.join(`
`), `
`).concat(K.join(`
`));
      }
      throw he;
    }
  };
  function fe(V, F, ee, he, Z) {
    if (!T(F))
      throw new h("regexp", "RegExp", F);
    var K = Z === "match";
    if (typeof V != "string" || N(F, V) !== K) {
      if (ee instanceof Error)
        throw ee;
      var ce = !ee;
      ee = ee || (typeof V != "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(e(V), " (").concat(M(V), ")") : (K ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(M(F), `. Input:

`).concat(M(V), `
`));
      var ve = new m({
        actual: V,
        expected: F,
        message: ee,
        operator: Z,
        stackStartFn: he
      });
      throw ve.generatedMessage = ce, ve;
    }
  }
  oe.match = function V(F, ee, he) {
    fe(F, ee, he, V, "match");
  }, oe.doesNotMatch = function V(F, ee, he) {
    fe(F, ee, he, V, "doesNotMatch");
  };
  function z() {
    for (var V = arguments.length, F = new Array(V), ee = 0; ee < V; ee++)
      F[ee] = arguments[ee];
    a.apply(void 0, [z, F.length].concat(F));
  }
  return oe.strict = k(z, oe, {
    equal: oe.strictEqual,
    deepEqual: oe.deepStrictEqual,
    notEqual: oe.notStrictEqual,
    notDeepEqual: oe.notDeepStrictEqual
  }), oe.strict.strict = oe.strict, qo.exports;
}
var is, Gl;
function s8() {
  if (Gl)
    return is;
  Gl = 1;
  function e() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  }
  return is = e, is;
}
var Cr = {}, as = {}, Wl;
function bf() {
  return Wl || (Wl = 1, function(e) {
    var t = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
    function n(r, o) {
      return Object.prototype.hasOwnProperty.call(r, o);
    }
    e.assign = function(r) {
      for (var o = Array.prototype.slice.call(arguments, 1); o.length; ) {
        var u = o.shift();
        if (u) {
          if (typeof u != "object")
            throw new TypeError(u + "must be non-object");
          for (var c in u)
            n(u, c) && (r[c] = u[c]);
        }
      }
      return r;
    }, e.shrinkBuf = function(r, o) {
      return r.length === o ? r : r.subarray ? r.subarray(0, o) : (r.length = o, r);
    };
    var i = {
      arraySet: function(r, o, u, c, h) {
        if (o.subarray && r.subarray) {
          r.set(o.subarray(u, u + c), h);
          return;
        }
        for (var f = 0; f < c; f++)
          r[h + f] = o[u + f];
      },
      // Join array of chunks to single array.
      flattenChunks: function(r) {
        var o, u, c, h, f, b;
        for (c = 0, o = 0, u = r.length; o < u; o++)
          c += r[o].length;
        for (b = new Uint8Array(c), h = 0, o = 0, u = r.length; o < u; o++)
          f = r[o], b.set(f, h), h += f.length;
        return b;
      }
    }, s = {
      arraySet: function(r, o, u, c, h) {
        for (var f = 0; f < c; f++)
          r[h + f] = o[u + f];
      },
      // Join array of chunks to single array.
      flattenChunks: function(r) {
        return [].concat.apply([], r);
      }
    };
    e.setTyped = function(r) {
      r ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, i)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, s));
    }, e.setTyped(t);
  }(as)), as;
}
var gn = {}, Jl;
function u8() {
  if (Jl)
    return gn;
  Jl = 1;
  var e = bf(), t = 4, n = 0, i = 1, s = 2;
  function r(Y) {
    for (var Se = Y.length; --Se >= 0; )
      Y[Se] = 0;
  }
  var o = 0, u = 1, c = 2, h = 3, f = 258, b = 29, v = 256, m = v + 1 + b, E = 30, M = 19, B = 2 * m + 1, I = 15, T = 16, k = 7, j = 256, N = 16, q = 17, D = 18, re = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  ), te = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  ), oe = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  ), U = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], y = 512, p = new Array((m + 2) * 2);
  r(p);
  var a = new Array(E * 2);
  r(a);
  var l = new Array(y);
  r(l);
  var _ = new Array(f - h + 1);
  r(_);
  var x = new Array(b);
  r(x);
  var A = new Array(E);
  r(A);
  function S(Y, Se, Ae, je, pe) {
    this.static_tree = Y, this.extra_bits = Se, this.extra_base = Ae, this.elems = je, this.max_length = pe, this.has_stree = Y && Y.length;
  }
  var g, w, d;
  function R(Y, Se) {
    this.dyn_tree = Y, this.max_code = 0, this.stat_desc = Se;
  }
  function G(Y) {
    return Y < 256 ? l[Y] : l[256 + (Y >>> 7)];
  }
  function fe(Y, Se) {
    Y.pending_buf[Y.pending++] = Se & 255, Y.pending_buf[Y.pending++] = Se >>> 8 & 255;
  }
  function z(Y, Se, Ae) {
    Y.bi_valid > T - Ae ? (Y.bi_buf |= Se << Y.bi_valid & 65535, fe(Y, Y.bi_buf), Y.bi_buf = Se >> T - Y.bi_valid, Y.bi_valid += Ae - T) : (Y.bi_buf |= Se << Y.bi_valid & 65535, Y.bi_valid += Ae);
  }
  function V(Y, Se, Ae) {
    z(
      Y,
      Ae[Se * 2],
      Ae[Se * 2 + 1]
      /*.Len*/
    );
  }
  function F(Y, Se) {
    var Ae = 0;
    do
      Ae |= Y & 1, Y >>>= 1, Ae <<= 1;
    while (--Se > 0);
    return Ae >>> 1;
  }
  function ee(Y) {
    Y.bi_valid === 16 ? (fe(Y, Y.bi_buf), Y.bi_buf = 0, Y.bi_valid = 0) : Y.bi_valid >= 8 && (Y.pending_buf[Y.pending++] = Y.bi_buf & 255, Y.bi_buf >>= 8, Y.bi_valid -= 8);
  }
  function he(Y, Se) {
    var Ae = Se.dyn_tree, je = Se.max_code, pe = Se.stat_desc.static_tree, Ee = Se.stat_desc.has_stree, J = Se.stat_desc.extra_bits, Ie = Se.stat_desc.extra_base, ke = Se.stat_desc.max_length, P, Me, be, ie, le, ge, Ge = 0;
    for (ie = 0; ie <= I; ie++)
      Y.bl_count[ie] = 0;
    for (Ae[Y.heap[Y.heap_max] * 2 + 1] = 0, P = Y.heap_max + 1; P < B; P++)
      Me = Y.heap[P], ie = Ae[Ae[Me * 2 + 1] * 2 + 1] + 1, ie > ke && (ie = ke, Ge++), Ae[Me * 2 + 1] = ie, !(Me > je) && (Y.bl_count[ie]++, le = 0, Me >= Ie && (le = J[Me - Ie]), ge = Ae[Me * 2], Y.opt_len += ge * (ie + le), Ee && (Y.static_len += ge * (pe[Me * 2 + 1] + le)));
    if (Ge !== 0) {
      do {
        for (ie = ke - 1; Y.bl_count[ie] === 0; )
          ie--;
        Y.bl_count[ie]--, Y.bl_count[ie + 1] += 2, Y.bl_count[ke]--, Ge -= 2;
      } while (Ge > 0);
      for (ie = ke; ie !== 0; ie--)
        for (Me = Y.bl_count[ie]; Me !== 0; )
          be = Y.heap[--P], !(be > je) && (Ae[be * 2 + 1] !== ie && (Y.opt_len += (ie - Ae[be * 2 + 1]) * Ae[be * 2], Ae[be * 2 + 1] = ie), Me--);
    }
  }
  function Z(Y, Se, Ae) {
    var je = new Array(I + 1), pe = 0, Ee, J;
    for (Ee = 1; Ee <= I; Ee++)
      je[Ee] = pe = pe + Ae[Ee - 1] << 1;
    for (J = 0; J <= Se; J++) {
      var Ie = Y[J * 2 + 1];
      Ie !== 0 && (Y[J * 2] = F(je[Ie]++, Ie));
    }
  }
  function K() {
    var Y, Se, Ae, je, pe, Ee = new Array(I + 1);
    for (Ae = 0, je = 0; je < b - 1; je++)
      for (x[je] = Ae, Y = 0; Y < 1 << re[je]; Y++)
        _[Ae++] = je;
    for (_[Ae - 1] = je, pe = 0, je = 0; je < 16; je++)
      for (A[je] = pe, Y = 0; Y < 1 << te[je]; Y++)
        l[pe++] = je;
    for (pe >>= 7; je < E; je++)
      for (A[je] = pe << 7, Y = 0; Y < 1 << te[je] - 7; Y++)
        l[256 + pe++] = je;
    for (Se = 0; Se <= I; Se++)
      Ee[Se] = 0;
    for (Y = 0; Y <= 143; )
      p[Y * 2 + 1] = 8, Y++, Ee[8]++;
    for (; Y <= 255; )
      p[Y * 2 + 1] = 9, Y++, Ee[9]++;
    for (; Y <= 279; )
      p[Y * 2 + 1] = 7, Y++, Ee[7]++;
    for (; Y <= 287; )
      p[Y * 2 + 1] = 8, Y++, Ee[8]++;
    for (Z(p, m + 1, Ee), Y = 0; Y < E; Y++)
      a[Y * 2 + 1] = 5, a[Y * 2] = F(Y, 5);
    g = new S(p, re, v + 1, m, I), w = new S(a, te, 0, E, I), d = new S(new Array(0), oe, 0, M, k);
  }
  function ce(Y) {
    var Se;
    for (Se = 0; Se < m; Se++)
      Y.dyn_ltree[Se * 2] = 0;
    for (Se = 0; Se < E; Se++)
      Y.dyn_dtree[Se * 2] = 0;
    for (Se = 0; Se < M; Se++)
      Y.bl_tree[Se * 2] = 0;
    Y.dyn_ltree[j * 2] = 1, Y.opt_len = Y.static_len = 0, Y.last_lit = Y.matches = 0;
  }
  function ve(Y) {
    Y.bi_valid > 8 ? fe(Y, Y.bi_buf) : Y.bi_valid > 0 && (Y.pending_buf[Y.pending++] = Y.bi_buf), Y.bi_buf = 0, Y.bi_valid = 0;
  }
  function Be(Y, Se, Ae, je) {
    ve(Y), je && (fe(Y, Ae), fe(Y, ~Ae)), e.arraySet(Y.pending_buf, Y.window, Se, Ae, Y.pending), Y.pending += Ae;
  }
  function Q(Y, Se, Ae, je) {
    var pe = Se * 2, Ee = Ae * 2;
    return Y[pe] < Y[Ee] || Y[pe] === Y[Ee] && je[Se] <= je[Ae];
  }
  function C(Y, Se, Ae) {
    for (var je = Y.heap[Ae], pe = Ae << 1; pe <= Y.heap_len && (pe < Y.heap_len && Q(Se, Y.heap[pe + 1], Y.heap[pe], Y.depth) && pe++, !Q(Se, je, Y.heap[pe], Y.depth)); )
      Y.heap[Ae] = Y.heap[pe], Ae = pe, pe <<= 1;
    Y.heap[Ae] = je;
  }
  function L(Y, Se, Ae) {
    var je, pe, Ee = 0, J, Ie;
    if (Y.last_lit !== 0)
      do
        je = Y.pending_buf[Y.d_buf + Ee * 2] << 8 | Y.pending_buf[Y.d_buf + Ee * 2 + 1], pe = Y.pending_buf[Y.l_buf + Ee], Ee++, je === 0 ? V(Y, pe, Se) : (J = _[pe], V(Y, J + v + 1, Se), Ie = re[J], Ie !== 0 && (pe -= x[J], z(Y, pe, Ie)), je--, J = G(je), V(Y, J, Ae), Ie = te[J], Ie !== 0 && (je -= A[J], z(Y, je, Ie)));
      while (Ee < Y.last_lit);
    V(Y, j, Se);
  }
  function W(Y, Se) {
    var Ae = Se.dyn_tree, je = Se.stat_desc.static_tree, pe = Se.stat_desc.has_stree, Ee = Se.stat_desc.elems, J, Ie, ke = -1, P;
    for (Y.heap_len = 0, Y.heap_max = B, J = 0; J < Ee; J++)
      Ae[J * 2] !== 0 ? (Y.heap[++Y.heap_len] = ke = J, Y.depth[J] = 0) : Ae[J * 2 + 1] = 0;
    for (; Y.heap_len < 2; )
      P = Y.heap[++Y.heap_len] = ke < 2 ? ++ke : 0, Ae[P * 2] = 1, Y.depth[P] = 0, Y.opt_len--, pe && (Y.static_len -= je[P * 2 + 1]);
    for (Se.max_code = ke, J = Y.heap_len >> 1; J >= 1; J--)
      C(Y, Ae, J);
    P = Ee;
    do
      J = Y.heap[
        1
        /*SMALLEST*/
      ], Y.heap[
        1
        /*SMALLEST*/
      ] = Y.heap[Y.heap_len--], C(
        Y,
        Ae,
        1
        /*SMALLEST*/
      ), Ie = Y.heap[
        1
        /*SMALLEST*/
      ], Y.heap[--Y.heap_max] = J, Y.heap[--Y.heap_max] = Ie, Ae[P * 2] = Ae[J * 2] + Ae[Ie * 2], Y.depth[P] = (Y.depth[J] >= Y.depth[Ie] ? Y.depth[J] : Y.depth[Ie]) + 1, Ae[J * 2 + 1] = Ae[Ie * 2 + 1] = P, Y.heap[
        1
        /*SMALLEST*/
      ] = P++, C(
        Y,
        Ae,
        1
        /*SMALLEST*/
      );
    while (Y.heap_len >= 2);
    Y.heap[--Y.heap_max] = Y.heap[
      1
      /*SMALLEST*/
    ], he(Y, Se), Z(Ae, ke, Y.bl_count);
  }
  function de(Y, Se, Ae) {
    var je, pe = -1, Ee, J = Se[0 * 2 + 1], Ie = 0, ke = 7, P = 4;
    for (J === 0 && (ke = 138, P = 3), Se[(Ae + 1) * 2 + 1] = 65535, je = 0; je <= Ae; je++)
      Ee = J, J = Se[(je + 1) * 2 + 1], !(++Ie < ke && Ee === J) && (Ie < P ? Y.bl_tree[Ee * 2] += Ie : Ee !== 0 ? (Ee !== pe && Y.bl_tree[Ee * 2]++, Y.bl_tree[N * 2]++) : Ie <= 10 ? Y.bl_tree[q * 2]++ : Y.bl_tree[D * 2]++, Ie = 0, pe = Ee, J === 0 ? (ke = 138, P = 3) : Ee === J ? (ke = 6, P = 3) : (ke = 7, P = 4));
  }
  function me(Y, Se, Ae) {
    var je, pe = -1, Ee, J = Se[0 * 2 + 1], Ie = 0, ke = 7, P = 4;
    for (J === 0 && (ke = 138, P = 3), je = 0; je <= Ae; je++)
      if (Ee = J, J = Se[(je + 1) * 2 + 1], !(++Ie < ke && Ee === J)) {
        if (Ie < P)
          do
            V(Y, Ee, Y.bl_tree);
          while (--Ie !== 0);
        else
          Ee !== 0 ? (Ee !== pe && (V(Y, Ee, Y.bl_tree), Ie--), V(Y, N, Y.bl_tree), z(Y, Ie - 3, 2)) : Ie <= 10 ? (V(Y, q, Y.bl_tree), z(Y, Ie - 3, 3)) : (V(Y, D, Y.bl_tree), z(Y, Ie - 11, 7));
        Ie = 0, pe = Ee, J === 0 ? (ke = 138, P = 3) : Ee === J ? (ke = 6, P = 3) : (ke = 7, P = 4);
      }
  }
  function Te(Y) {
    var Se;
    for (de(Y, Y.dyn_ltree, Y.l_desc.max_code), de(Y, Y.dyn_dtree, Y.d_desc.max_code), W(Y, Y.bl_desc), Se = M - 1; Se >= 3 && Y.bl_tree[U[Se] * 2 + 1] === 0; Se--)
      ;
    return Y.opt_len += 3 * (Se + 1) + 5 + 5 + 4, Se;
  }
  function Fe(Y, Se, Ae, je) {
    var pe;
    for (z(Y, Se - 257, 5), z(Y, Ae - 1, 5), z(Y, je - 4, 4), pe = 0; pe < je; pe++)
      z(Y, Y.bl_tree[U[pe] * 2 + 1], 3);
    me(Y, Y.dyn_ltree, Se - 1), me(Y, Y.dyn_dtree, Ae - 1);
  }
  function H(Y) {
    var Se = 4093624447, Ae;
    for (Ae = 0; Ae <= 31; Ae++, Se >>>= 1)
      if (Se & 1 && Y.dyn_ltree[Ae * 2] !== 0)
        return n;
    if (Y.dyn_ltree[9 * 2] !== 0 || Y.dyn_ltree[10 * 2] !== 0 || Y.dyn_ltree[13 * 2] !== 0)
      return i;
    for (Ae = 32; Ae < v; Ae++)
      if (Y.dyn_ltree[Ae * 2] !== 0)
        return i;
    return n;
  }
  var ue = !1;
  function se(Y) {
    ue || (K(), ue = !0), Y.l_desc = new R(Y.dyn_ltree, g), Y.d_desc = new R(Y.dyn_dtree, w), Y.bl_desc = new R(Y.bl_tree, d), Y.bi_buf = 0, Y.bi_valid = 0, ce(Y);
  }
  function we(Y, Se, Ae, je) {
    z(Y, (o << 1) + (je ? 1 : 0), 3), Be(Y, Se, Ae, !0);
  }
  function Ce(Y) {
    z(Y, u << 1, 3), V(Y, j, p), ee(Y);
  }
  function ze(Y, Se, Ae, je) {
    var pe, Ee, J = 0;
    Y.level > 0 ? (Y.strm.data_type === s && (Y.strm.data_type = H(Y)), W(Y, Y.l_desc), W(Y, Y.d_desc), J = Te(Y), pe = Y.opt_len + 3 + 7 >>> 3, Ee = Y.static_len + 3 + 7 >>> 3, Ee <= pe && (pe = Ee)) : pe = Ee = Ae + 5, Ae + 4 <= pe && Se !== -1 ? we(Y, Se, Ae, je) : Y.strategy === t || Ee === pe ? (z(Y, (u << 1) + (je ? 1 : 0), 3), L(Y, p, a)) : (z(Y, (c << 1) + (je ? 1 : 0), 3), Fe(Y, Y.l_desc.max_code + 1, Y.d_desc.max_code + 1, J + 1), L(Y, Y.dyn_ltree, Y.dyn_dtree)), ce(Y), je && ve(Y);
  }
  function Le(Y, Se, Ae) {
    return Y.pending_buf[Y.d_buf + Y.last_lit * 2] = Se >>> 8 & 255, Y.pending_buf[Y.d_buf + Y.last_lit * 2 + 1] = Se & 255, Y.pending_buf[Y.l_buf + Y.last_lit] = Ae & 255, Y.last_lit++, Se === 0 ? Y.dyn_ltree[Ae * 2]++ : (Y.matches++, Se--, Y.dyn_ltree[(_[Ae] + v + 1) * 2]++, Y.dyn_dtree[G(Se) * 2]++), Y.last_lit === Y.lit_bufsize - 1;
  }
  return gn._tr_init = se, gn._tr_stored_block = we, gn._tr_flush_block = ze, gn._tr_tally = Le, gn._tr_align = Ce, gn;
}
var fs, Xl;
function Pb() {
  if (Xl)
    return fs;
  Xl = 1;
  function e(t, n, i, s) {
    for (var r = t & 65535 | 0, o = t >>> 16 & 65535 | 0, u = 0; i !== 0; ) {
      u = i > 2e3 ? 2e3 : i, i -= u;
      do
        r = r + n[s++] | 0, o = o + r | 0;
      while (--u);
      r %= 65521, o %= 65521;
    }
    return r | o << 16 | 0;
  }
  return fs = e, fs;
}
var os, Yl;
function Cb() {
  if (Yl)
    return os;
  Yl = 1;
  function e() {
    for (var i, s = [], r = 0; r < 256; r++) {
      i = r;
      for (var o = 0; o < 8; o++)
        i = i & 1 ? 3988292384 ^ i >>> 1 : i >>> 1;
      s[r] = i;
    }
    return s;
  }
  var t = e();
  function n(i, s, r, o) {
    var u = t, c = o + r;
    i ^= -1;
    for (var h = o; h < c; h++)
      i = i >>> 8 ^ u[(i ^ s[h]) & 255];
    return i ^ -1;
  }
  return os = n, os;
}
var ss, Ql;
function c8() {
  return Ql || (Ql = 1, ss = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  }), ss;
}
var ed;
function h8() {
  if (ed)
    return Cr;
  ed = 1;
  var e = bf(), t = u8(), n = Pb(), i = Cb(), s = c8(), r = 0, o = 1, u = 3, c = 4, h = 5, f = 0, b = 1, v = -2, m = -3, E = -5, M = -1, B = 1, I = 2, T = 3, k = 4, j = 0, N = 2, q = 8, D = 9, re = 15, te = 8, oe = 29, U = 256, y = U + 1 + oe, p = 30, a = 19, l = 2 * y + 1, _ = 15, x = 3, A = 258, S = A + x + 1, g = 32, w = 42, d = 69, R = 73, G = 91, fe = 103, z = 113, V = 666, F = 1, ee = 2, he = 3, Z = 4, K = 3;
  function ce(P, Me) {
    return P.msg = s[Me], Me;
  }
  function ve(P) {
    return (P << 1) - (P > 4 ? 9 : 0);
  }
  function Be(P) {
    for (var Me = P.length; --Me >= 0; )
      P[Me] = 0;
  }
  function Q(P) {
    var Me = P.state, be = Me.pending;
    be > P.avail_out && (be = P.avail_out), be !== 0 && (e.arraySet(P.output, Me.pending_buf, Me.pending_out, be, P.next_out), P.next_out += be, Me.pending_out += be, P.total_out += be, P.avail_out -= be, Me.pending -= be, Me.pending === 0 && (Me.pending_out = 0));
  }
  function C(P, Me) {
    t._tr_flush_block(P, P.block_start >= 0 ? P.block_start : -1, P.strstart - P.block_start, Me), P.block_start = P.strstart, Q(P.strm);
  }
  function L(P, Me) {
    P.pending_buf[P.pending++] = Me;
  }
  function W(P, Me) {
    P.pending_buf[P.pending++] = Me >>> 8 & 255, P.pending_buf[P.pending++] = Me & 255;
  }
  function de(P, Me, be, ie) {
    var le = P.avail_in;
    return le > ie && (le = ie), le === 0 ? 0 : (P.avail_in -= le, e.arraySet(Me, P.input, P.next_in, le, be), P.state.wrap === 1 ? P.adler = n(P.adler, Me, le, be) : P.state.wrap === 2 && (P.adler = i(P.adler, Me, le, be)), P.next_in += le, P.total_in += le, le);
  }
  function me(P, Me) {
    var be = P.max_chain_length, ie = P.strstart, le, ge, Ge = P.prev_length, De = P.nice_match, Ne = P.strstart > P.w_size - S ? P.strstart - (P.w_size - S) : 0, rt = P.window, ft = P.w_mask, We = P.prev, at = P.strstart + A, $ = rt[ie + Ge - 1], X = rt[ie + Ge];
    P.prev_length >= P.good_match && (be >>= 2), De > P.lookahead && (De = P.lookahead);
    do
      if (le = Me, !(rt[le + Ge] !== X || rt[le + Ge - 1] !== $ || rt[le] !== rt[ie] || rt[++le] !== rt[ie + 1])) {
        ie += 2, le++;
        do
          ;
        while (rt[++ie] === rt[++le] && rt[++ie] === rt[++le] && rt[++ie] === rt[++le] && rt[++ie] === rt[++le] && rt[++ie] === rt[++le] && rt[++ie] === rt[++le] && rt[++ie] === rt[++le] && rt[++ie] === rt[++le] && ie < at);
        if (ge = A - (at - ie), ie = at - A, ge > Ge) {
          if (P.match_start = Me, Ge = ge, ge >= De)
            break;
          $ = rt[ie + Ge - 1], X = rt[ie + Ge];
        }
      }
    while ((Me = We[Me & ft]) > Ne && --be !== 0);
    return Ge <= P.lookahead ? Ge : P.lookahead;
  }
  function Te(P) {
    var Me = P.w_size, be, ie, le, ge, Ge;
    do {
      if (ge = P.window_size - P.lookahead - P.strstart, P.strstart >= Me + (Me - S)) {
        e.arraySet(P.window, P.window, Me, Me, 0), P.match_start -= Me, P.strstart -= Me, P.block_start -= Me, ie = P.hash_size, be = ie;
        do
          le = P.head[--be], P.head[be] = le >= Me ? le - Me : 0;
        while (--ie);
        ie = Me, be = ie;
        do
          le = P.prev[--be], P.prev[be] = le >= Me ? le - Me : 0;
        while (--ie);
        ge += Me;
      }
      if (P.strm.avail_in === 0)
        break;
      if (ie = de(P.strm, P.window, P.strstart + P.lookahead, ge), P.lookahead += ie, P.lookahead + P.insert >= x)
        for (Ge = P.strstart - P.insert, P.ins_h = P.window[Ge], P.ins_h = (P.ins_h << P.hash_shift ^ P.window[Ge + 1]) & P.hash_mask; P.insert && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[Ge + x - 1]) & P.hash_mask, P.prev[Ge & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = Ge, Ge++, P.insert--, !(P.lookahead + P.insert < x)); )
          ;
    } while (P.lookahead < S && P.strm.avail_in !== 0);
  }
  function Fe(P, Me) {
    var be = 65535;
    for (be > P.pending_buf_size - 5 && (be = P.pending_buf_size - 5); ; ) {
      if (P.lookahead <= 1) {
        if (Te(P), P.lookahead === 0 && Me === r)
          return F;
        if (P.lookahead === 0)
          break;
      }
      P.strstart += P.lookahead, P.lookahead = 0;
      var ie = P.block_start + be;
      if ((P.strstart === 0 || P.strstart >= ie) && (P.lookahead = P.strstart - ie, P.strstart = ie, C(P, !1), P.strm.avail_out === 0) || P.strstart - P.block_start >= P.w_size - S && (C(P, !1), P.strm.avail_out === 0))
        return F;
    }
    return P.insert = 0, Me === c ? (C(P, !0), P.strm.avail_out === 0 ? he : Z) : (P.strstart > P.block_start && (C(P, !1), P.strm.avail_out === 0), F);
  }
  function H(P, Me) {
    for (var be, ie; ; ) {
      if (P.lookahead < S) {
        if (Te(P), P.lookahead < S && Me === r)
          return F;
        if (P.lookahead === 0)
          break;
      }
      if (be = 0, P.lookahead >= x && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + x - 1]) & P.hash_mask, be = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart), be !== 0 && P.strstart - be <= P.w_size - S && (P.match_length = me(P, be)), P.match_length >= x)
        if (ie = t._tr_tally(P, P.strstart - P.match_start, P.match_length - x), P.lookahead -= P.match_length, P.match_length <= P.max_lazy_match && P.lookahead >= x) {
          P.match_length--;
          do
            P.strstart++, P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + x - 1]) & P.hash_mask, be = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart;
          while (--P.match_length !== 0);
          P.strstart++;
        } else
          P.strstart += P.match_length, P.match_length = 0, P.ins_h = P.window[P.strstart], P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + 1]) & P.hash_mask;
      else
        ie = t._tr_tally(P, 0, P.window[P.strstart]), P.lookahead--, P.strstart++;
      if (ie && (C(P, !1), P.strm.avail_out === 0))
        return F;
    }
    return P.insert = P.strstart < x - 1 ? P.strstart : x - 1, Me === c ? (C(P, !0), P.strm.avail_out === 0 ? he : Z) : P.last_lit && (C(P, !1), P.strm.avail_out === 0) ? F : ee;
  }
  function ue(P, Me) {
    for (var be, ie, le; ; ) {
      if (P.lookahead < S) {
        if (Te(P), P.lookahead < S && Me === r)
          return F;
        if (P.lookahead === 0)
          break;
      }
      if (be = 0, P.lookahead >= x && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + x - 1]) & P.hash_mask, be = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart), P.prev_length = P.match_length, P.prev_match = P.match_start, P.match_length = x - 1, be !== 0 && P.prev_length < P.max_lazy_match && P.strstart - be <= P.w_size - S && (P.match_length = me(P, be), P.match_length <= 5 && (P.strategy === B || P.match_length === x && P.strstart - P.match_start > 4096) && (P.match_length = x - 1)), P.prev_length >= x && P.match_length <= P.prev_length) {
        le = P.strstart + P.lookahead - x, ie = t._tr_tally(P, P.strstart - 1 - P.prev_match, P.prev_length - x), P.lookahead -= P.prev_length - 1, P.prev_length -= 2;
        do
          ++P.strstart <= le && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + x - 1]) & P.hash_mask, be = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart);
        while (--P.prev_length !== 0);
        if (P.match_available = 0, P.match_length = x - 1, P.strstart++, ie && (C(P, !1), P.strm.avail_out === 0))
          return F;
      } else if (P.match_available) {
        if (ie = t._tr_tally(P, 0, P.window[P.strstart - 1]), ie && C(P, !1), P.strstart++, P.lookahead--, P.strm.avail_out === 0)
          return F;
      } else
        P.match_available = 1, P.strstart++, P.lookahead--;
    }
    return P.match_available && (ie = t._tr_tally(P, 0, P.window[P.strstart - 1]), P.match_available = 0), P.insert = P.strstart < x - 1 ? P.strstart : x - 1, Me === c ? (C(P, !0), P.strm.avail_out === 0 ? he : Z) : P.last_lit && (C(P, !1), P.strm.avail_out === 0) ? F : ee;
  }
  function se(P, Me) {
    for (var be, ie, le, ge, Ge = P.window; ; ) {
      if (P.lookahead <= A) {
        if (Te(P), P.lookahead <= A && Me === r)
          return F;
        if (P.lookahead === 0)
          break;
      }
      if (P.match_length = 0, P.lookahead >= x && P.strstart > 0 && (le = P.strstart - 1, ie = Ge[le], ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le])) {
        ge = P.strstart + A;
        do
          ;
        while (ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le] && le < ge);
        P.match_length = A - (ge - le), P.match_length > P.lookahead && (P.match_length = P.lookahead);
      }
      if (P.match_length >= x ? (be = t._tr_tally(P, 1, P.match_length - x), P.lookahead -= P.match_length, P.strstart += P.match_length, P.match_length = 0) : (be = t._tr_tally(P, 0, P.window[P.strstart]), P.lookahead--, P.strstart++), be && (C(P, !1), P.strm.avail_out === 0))
        return F;
    }
    return P.insert = 0, Me === c ? (C(P, !0), P.strm.avail_out === 0 ? he : Z) : P.last_lit && (C(P, !1), P.strm.avail_out === 0) ? F : ee;
  }
  function we(P, Me) {
    for (var be; ; ) {
      if (P.lookahead === 0 && (Te(P), P.lookahead === 0)) {
        if (Me === r)
          return F;
        break;
      }
      if (P.match_length = 0, be = t._tr_tally(P, 0, P.window[P.strstart]), P.lookahead--, P.strstart++, be && (C(P, !1), P.strm.avail_out === 0))
        return F;
    }
    return P.insert = 0, Me === c ? (C(P, !0), P.strm.avail_out === 0 ? he : Z) : P.last_lit && (C(P, !1), P.strm.avail_out === 0) ? F : ee;
  }
  function Ce(P, Me, be, ie, le) {
    this.good_length = P, this.max_lazy = Me, this.nice_length = be, this.max_chain = ie, this.func = le;
  }
  var ze;
  ze = [
    /*      good lazy nice chain */
    new Ce(0, 0, 0, 0, Fe),
    /* 0 store only */
    new Ce(4, 4, 8, 4, H),
    /* 1 max speed, no lazy matches */
    new Ce(4, 5, 16, 8, H),
    /* 2 */
    new Ce(4, 6, 32, 32, H),
    /* 3 */
    new Ce(4, 4, 16, 16, ue),
    /* 4 lazy matches */
    new Ce(8, 16, 32, 32, ue),
    /* 5 */
    new Ce(8, 16, 128, 128, ue),
    /* 6 */
    new Ce(8, 32, 128, 256, ue),
    /* 7 */
    new Ce(32, 128, 258, 1024, ue),
    /* 8 */
    new Ce(32, 258, 258, 4096, ue)
    /* 9 max compression */
  ];
  function Le(P) {
    P.window_size = 2 * P.w_size, Be(P.head), P.max_lazy_match = ze[P.level].max_lazy, P.good_match = ze[P.level].good_length, P.nice_match = ze[P.level].nice_length, P.max_chain_length = ze[P.level].max_chain, P.strstart = 0, P.block_start = 0, P.lookahead = 0, P.insert = 0, P.match_length = P.prev_length = x - 1, P.match_available = 0, P.ins_h = 0;
  }
  function Y() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = q, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new e.Buf16(l * 2), this.dyn_dtree = new e.Buf16((2 * p + 1) * 2), this.bl_tree = new e.Buf16((2 * a + 1) * 2), Be(this.dyn_ltree), Be(this.dyn_dtree), Be(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new e.Buf16(_ + 1), this.heap = new e.Buf16(2 * y + 1), Be(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new e.Buf16(2 * y + 1), Be(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
  }
  function Se(P) {
    var Me;
    return !P || !P.state ? ce(P, v) : (P.total_in = P.total_out = 0, P.data_type = N, Me = P.state, Me.pending = 0, Me.pending_out = 0, Me.wrap < 0 && (Me.wrap = -Me.wrap), Me.status = Me.wrap ? w : z, P.adler = Me.wrap === 2 ? 0 : 1, Me.last_flush = r, t._tr_init(Me), f);
  }
  function Ae(P) {
    var Me = Se(P);
    return Me === f && Le(P.state), Me;
  }
  function je(P, Me) {
    return !P || !P.state || P.state.wrap !== 2 ? v : (P.state.gzhead = Me, f);
  }
  function pe(P, Me, be, ie, le, ge) {
    if (!P)
      return v;
    var Ge = 1;
    if (Me === M && (Me = 6), ie < 0 ? (Ge = 0, ie = -ie) : ie > 15 && (Ge = 2, ie -= 16), le < 1 || le > D || be !== q || ie < 8 || ie > 15 || Me < 0 || Me > 9 || ge < 0 || ge > k)
      return ce(P, v);
    ie === 8 && (ie = 9);
    var De = new Y();
    return P.state = De, De.strm = P, De.wrap = Ge, De.gzhead = null, De.w_bits = ie, De.w_size = 1 << De.w_bits, De.w_mask = De.w_size - 1, De.hash_bits = le + 7, De.hash_size = 1 << De.hash_bits, De.hash_mask = De.hash_size - 1, De.hash_shift = ~~((De.hash_bits + x - 1) / x), De.window = new e.Buf8(De.w_size * 2), De.head = new e.Buf16(De.hash_size), De.prev = new e.Buf16(De.w_size), De.lit_bufsize = 1 << le + 6, De.pending_buf_size = De.lit_bufsize * 4, De.pending_buf = new e.Buf8(De.pending_buf_size), De.d_buf = 1 * De.lit_bufsize, De.l_buf = (1 + 2) * De.lit_bufsize, De.level = Me, De.strategy = ge, De.method = be, Ae(P);
  }
  function Ee(P, Me) {
    return pe(P, Me, q, re, te, j);
  }
  function J(P, Me) {
    var be, ie, le, ge;
    if (!P || !P.state || Me > h || Me < 0)
      return P ? ce(P, v) : v;
    if (ie = P.state, !P.output || !P.input && P.avail_in !== 0 || ie.status === V && Me !== c)
      return ce(P, P.avail_out === 0 ? E : v);
    if (ie.strm = P, be = ie.last_flush, ie.last_flush = Me, ie.status === w)
      if (ie.wrap === 2)
        P.adler = 0, L(ie, 31), L(ie, 139), L(ie, 8), ie.gzhead ? (L(
          ie,
          (ie.gzhead.text ? 1 : 0) + (ie.gzhead.hcrc ? 2 : 0) + (ie.gzhead.extra ? 4 : 0) + (ie.gzhead.name ? 8 : 0) + (ie.gzhead.comment ? 16 : 0)
        ), L(ie, ie.gzhead.time & 255), L(ie, ie.gzhead.time >> 8 & 255), L(ie, ie.gzhead.time >> 16 & 255), L(ie, ie.gzhead.time >> 24 & 255), L(ie, ie.level === 9 ? 2 : ie.strategy >= I || ie.level < 2 ? 4 : 0), L(ie, ie.gzhead.os & 255), ie.gzhead.extra && ie.gzhead.extra.length && (L(ie, ie.gzhead.extra.length & 255), L(ie, ie.gzhead.extra.length >> 8 & 255)), ie.gzhead.hcrc && (P.adler = i(P.adler, ie.pending_buf, ie.pending, 0)), ie.gzindex = 0, ie.status = d) : (L(ie, 0), L(ie, 0), L(ie, 0), L(ie, 0), L(ie, 0), L(ie, ie.level === 9 ? 2 : ie.strategy >= I || ie.level < 2 ? 4 : 0), L(ie, K), ie.status = z);
      else {
        var Ge = q + (ie.w_bits - 8 << 4) << 8, De = -1;
        ie.strategy >= I || ie.level < 2 ? De = 0 : ie.level < 6 ? De = 1 : ie.level === 6 ? De = 2 : De = 3, Ge |= De << 6, ie.strstart !== 0 && (Ge |= g), Ge += 31 - Ge % 31, ie.status = z, W(ie, Ge), ie.strstart !== 0 && (W(ie, P.adler >>> 16), W(ie, P.adler & 65535)), P.adler = 1;
      }
    if (ie.status === d)
      if (ie.gzhead.extra) {
        for (le = ie.pending; ie.gzindex < (ie.gzhead.extra.length & 65535) && !(ie.pending === ie.pending_buf_size && (ie.gzhead.hcrc && ie.pending > le && (P.adler = i(P.adler, ie.pending_buf, ie.pending - le, le)), Q(P), le = ie.pending, ie.pending === ie.pending_buf_size)); )
          L(ie, ie.gzhead.extra[ie.gzindex] & 255), ie.gzindex++;
        ie.gzhead.hcrc && ie.pending > le && (P.adler = i(P.adler, ie.pending_buf, ie.pending - le, le)), ie.gzindex === ie.gzhead.extra.length && (ie.gzindex = 0, ie.status = R);
      } else
        ie.status = R;
    if (ie.status === R)
      if (ie.gzhead.name) {
        le = ie.pending;
        do {
          if (ie.pending === ie.pending_buf_size && (ie.gzhead.hcrc && ie.pending > le && (P.adler = i(P.adler, ie.pending_buf, ie.pending - le, le)), Q(P), le = ie.pending, ie.pending === ie.pending_buf_size)) {
            ge = 1;
            break;
          }
          ie.gzindex < ie.gzhead.name.length ? ge = ie.gzhead.name.charCodeAt(ie.gzindex++) & 255 : ge = 0, L(ie, ge);
        } while (ge !== 0);
        ie.gzhead.hcrc && ie.pending > le && (P.adler = i(P.adler, ie.pending_buf, ie.pending - le, le)), ge === 0 && (ie.gzindex = 0, ie.status = G);
      } else
        ie.status = G;
    if (ie.status === G)
      if (ie.gzhead.comment) {
        le = ie.pending;
        do {
          if (ie.pending === ie.pending_buf_size && (ie.gzhead.hcrc && ie.pending > le && (P.adler = i(P.adler, ie.pending_buf, ie.pending - le, le)), Q(P), le = ie.pending, ie.pending === ie.pending_buf_size)) {
            ge = 1;
            break;
          }
          ie.gzindex < ie.gzhead.comment.length ? ge = ie.gzhead.comment.charCodeAt(ie.gzindex++) & 255 : ge = 0, L(ie, ge);
        } while (ge !== 0);
        ie.gzhead.hcrc && ie.pending > le && (P.adler = i(P.adler, ie.pending_buf, ie.pending - le, le)), ge === 0 && (ie.status = fe);
      } else
        ie.status = fe;
    if (ie.status === fe && (ie.gzhead.hcrc ? (ie.pending + 2 > ie.pending_buf_size && Q(P), ie.pending + 2 <= ie.pending_buf_size && (L(ie, P.adler & 255), L(ie, P.adler >> 8 & 255), P.adler = 0, ie.status = z)) : ie.status = z), ie.pending !== 0) {
      if (Q(P), P.avail_out === 0)
        return ie.last_flush = -1, f;
    } else if (P.avail_in === 0 && ve(Me) <= ve(be) && Me !== c)
      return ce(P, E);
    if (ie.status === V && P.avail_in !== 0)
      return ce(P, E);
    if (P.avail_in !== 0 || ie.lookahead !== 0 || Me !== r && ie.status !== V) {
      var Ne = ie.strategy === I ? we(ie, Me) : ie.strategy === T ? se(ie, Me) : ze[ie.level].func(ie, Me);
      if ((Ne === he || Ne === Z) && (ie.status = V), Ne === F || Ne === he)
        return P.avail_out === 0 && (ie.last_flush = -1), f;
      if (Ne === ee && (Me === o ? t._tr_align(ie) : Me !== h && (t._tr_stored_block(ie, 0, 0, !1), Me === u && (Be(ie.head), ie.lookahead === 0 && (ie.strstart = 0, ie.block_start = 0, ie.insert = 0))), Q(P), P.avail_out === 0))
        return ie.last_flush = -1, f;
    }
    return Me !== c ? f : ie.wrap <= 0 ? b : (ie.wrap === 2 ? (L(ie, P.adler & 255), L(ie, P.adler >> 8 & 255), L(ie, P.adler >> 16 & 255), L(ie, P.adler >> 24 & 255), L(ie, P.total_in & 255), L(ie, P.total_in >> 8 & 255), L(ie, P.total_in >> 16 & 255), L(ie, P.total_in >> 24 & 255)) : (W(ie, P.adler >>> 16), W(ie, P.adler & 65535)), Q(P), ie.wrap > 0 && (ie.wrap = -ie.wrap), ie.pending !== 0 ? f : b);
  }
  function Ie(P) {
    var Me;
    return !P || !P.state ? v : (Me = P.state.status, Me !== w && Me !== d && Me !== R && Me !== G && Me !== fe && Me !== z && Me !== V ? ce(P, v) : (P.state = null, Me === z ? ce(P, m) : f));
  }
  function ke(P, Me) {
    var be = Me.length, ie, le, ge, Ge, De, Ne, rt, ft;
    if (!P || !P.state || (ie = P.state, Ge = ie.wrap, Ge === 2 || Ge === 1 && ie.status !== w || ie.lookahead))
      return v;
    for (Ge === 1 && (P.adler = n(P.adler, Me, be, 0)), ie.wrap = 0, be >= ie.w_size && (Ge === 0 && (Be(ie.head), ie.strstart = 0, ie.block_start = 0, ie.insert = 0), ft = new e.Buf8(ie.w_size), e.arraySet(ft, Me, be - ie.w_size, ie.w_size, 0), Me = ft, be = ie.w_size), De = P.avail_in, Ne = P.next_in, rt = P.input, P.avail_in = be, P.next_in = 0, P.input = Me, Te(ie); ie.lookahead >= x; ) {
      le = ie.strstart, ge = ie.lookahead - (x - 1);
      do
        ie.ins_h = (ie.ins_h << ie.hash_shift ^ ie.window[le + x - 1]) & ie.hash_mask, ie.prev[le & ie.w_mask] = ie.head[ie.ins_h], ie.head[ie.ins_h] = le, le++;
      while (--ge);
      ie.strstart = le, ie.lookahead = x - 1, Te(ie);
    }
    return ie.strstart += ie.lookahead, ie.block_start = ie.strstart, ie.insert = ie.lookahead, ie.lookahead = 0, ie.match_length = ie.prev_length = x - 1, ie.match_available = 0, P.next_in = Ne, P.input = rt, P.avail_in = De, ie.wrap = Ge, f;
  }
  return Cr.deflateInit = Ee, Cr.deflateInit2 = pe, Cr.deflateReset = Ae, Cr.deflateResetKeep = Se, Cr.deflateSetHeader = je, Cr.deflate = J, Cr.deflateEnd = Ie, Cr.deflateSetDictionary = ke, Cr.deflateInfo = "pako deflate (from Nodeca project)", Cr;
}
var yr = {}, us, td;
function l8() {
  if (td)
    return us;
  td = 1;
  var e = 30, t = 12;
  return us = function(i, s) {
    var r, o, u, c, h, f, b, v, m, E, M, B, I, T, k, j, N, q, D, re, te, oe, U, y, p;
    r = i.state, o = i.next_in, y = i.input, u = o + (i.avail_in - 5), c = i.next_out, p = i.output, h = c - (s - i.avail_out), f = c + (i.avail_out - 257), b = r.dmax, v = r.wsize, m = r.whave, E = r.wnext, M = r.window, B = r.hold, I = r.bits, T = r.lencode, k = r.distcode, j = (1 << r.lenbits) - 1, N = (1 << r.distbits) - 1;
    e:
      do {
        I < 15 && (B += y[o++] << I, I += 8, B += y[o++] << I, I += 8), q = T[B & j];
        t:
          for (; ; ) {
            if (D = q >>> 24, B >>>= D, I -= D, D = q >>> 16 & 255, D === 0)
              p[c++] = q & 65535;
            else if (D & 16) {
              re = q & 65535, D &= 15, D && (I < D && (B += y[o++] << I, I += 8), re += B & (1 << D) - 1, B >>>= D, I -= D), I < 15 && (B += y[o++] << I, I += 8, B += y[o++] << I, I += 8), q = k[B & N];
              r:
                for (; ; ) {
                  if (D = q >>> 24, B >>>= D, I -= D, D = q >>> 16 & 255, D & 16) {
                    if (te = q & 65535, D &= 15, I < D && (B += y[o++] << I, I += 8, I < D && (B += y[o++] << I, I += 8)), te += B & (1 << D) - 1, te > b) {
                      i.msg = "invalid distance too far back", r.mode = e;
                      break e;
                    }
                    if (B >>>= D, I -= D, D = c - h, te > D) {
                      if (D = te - D, D > m && r.sane) {
                        i.msg = "invalid distance too far back", r.mode = e;
                        break e;
                      }
                      if (oe = 0, U = M, E === 0) {
                        if (oe += v - D, D < re) {
                          re -= D;
                          do
                            p[c++] = M[oe++];
                          while (--D);
                          oe = c - te, U = p;
                        }
                      } else if (E < D) {
                        if (oe += v + E - D, D -= E, D < re) {
                          re -= D;
                          do
                            p[c++] = M[oe++];
                          while (--D);
                          if (oe = 0, E < re) {
                            D = E, re -= D;
                            do
                              p[c++] = M[oe++];
                            while (--D);
                            oe = c - te, U = p;
                          }
                        }
                      } else if (oe += E - D, D < re) {
                        re -= D;
                        do
                          p[c++] = M[oe++];
                        while (--D);
                        oe = c - te, U = p;
                      }
                      for (; re > 2; )
                        p[c++] = U[oe++], p[c++] = U[oe++], p[c++] = U[oe++], re -= 3;
                      re && (p[c++] = U[oe++], re > 1 && (p[c++] = U[oe++]));
                    } else {
                      oe = c - te;
                      do
                        p[c++] = p[oe++], p[c++] = p[oe++], p[c++] = p[oe++], re -= 3;
                      while (re > 2);
                      re && (p[c++] = p[oe++], re > 1 && (p[c++] = p[oe++]));
                    }
                  } else if (D & 64) {
                    i.msg = "invalid distance code", r.mode = e;
                    break e;
                  } else {
                    q = k[(q & 65535) + (B & (1 << D) - 1)];
                    continue r;
                  }
                  break;
                }
            } else if (D & 64)
              if (D & 32) {
                r.mode = t;
                break e;
              } else {
                i.msg = "invalid literal/length code", r.mode = e;
                break e;
              }
            else {
              q = T[(q & 65535) + (B & (1 << D) - 1)];
              continue t;
            }
            break;
          }
      } while (o < u && c < f);
    re = I >> 3, o -= re, I -= re << 3, B &= (1 << I) - 1, i.next_in = o, i.next_out = c, i.avail_in = o < u ? 5 + (u - o) : 5 - (o - u), i.avail_out = c < f ? 257 + (f - c) : 257 - (c - f), r.hold = B, r.bits = I;
  }, us;
}
var cs, rd;
function d8() {
  if (rd)
    return cs;
  rd = 1;
  var e = bf(), t = 15, n = 852, i = 592, s = 0, r = 1, o = 2, u = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ], c = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ], h = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ], f = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  return cs = function(v, m, E, M, B, I, T, k) {
    var j = k.bits, N = 0, q = 0, D = 0, re = 0, te = 0, oe = 0, U = 0, y = 0, p = 0, a = 0, l, _, x, A, S, g = null, w = 0, d, R = new e.Buf16(t + 1), G = new e.Buf16(t + 1), fe = null, z = 0, V, F, ee;
    for (N = 0; N <= t; N++)
      R[N] = 0;
    for (q = 0; q < M; q++)
      R[m[E + q]]++;
    for (te = j, re = t; re >= 1 && R[re] === 0; re--)
      ;
    if (te > re && (te = re), re === 0)
      return B[I++] = 1 << 24 | 64 << 16 | 0, B[I++] = 1 << 24 | 64 << 16 | 0, k.bits = 1, 0;
    for (D = 1; D < re && R[D] === 0; D++)
      ;
    for (te < D && (te = D), y = 1, N = 1; N <= t; N++)
      if (y <<= 1, y -= R[N], y < 0)
        return -1;
    if (y > 0 && (v === s || re !== 1))
      return -1;
    for (G[1] = 0, N = 1; N < t; N++)
      G[N + 1] = G[N] + R[N];
    for (q = 0; q < M; q++)
      m[E + q] !== 0 && (T[G[m[E + q]]++] = q);
    if (v === s ? (g = fe = T, d = 19) : v === r ? (g = u, w -= 257, fe = c, z -= 257, d = 256) : (g = h, fe = f, d = -1), a = 0, q = 0, N = D, S = I, oe = te, U = 0, x = -1, p = 1 << te, A = p - 1, v === r && p > n || v === o && p > i)
      return 1;
    for (; ; ) {
      V = N - U, T[q] < d ? (F = 0, ee = T[q]) : T[q] > d ? (F = fe[z + T[q]], ee = g[w + T[q]]) : (F = 32 + 64, ee = 0), l = 1 << N - U, _ = 1 << oe, D = _;
      do
        _ -= l, B[S + (a >> U) + _] = V << 24 | F << 16 | ee | 0;
      while (_ !== 0);
      for (l = 1 << N - 1; a & l; )
        l >>= 1;
      if (l !== 0 ? (a &= l - 1, a += l) : a = 0, q++, --R[N] === 0) {
        if (N === re)
          break;
        N = m[E + T[q]];
      }
      if (N > te && (a & A) !== x) {
        for (U === 0 && (U = te), S += D, oe = N - U, y = 1 << oe; oe + U < re && (y -= R[oe + U], !(y <= 0)); )
          oe++, y <<= 1;
        if (p += 1 << oe, v === r && p > n || v === o && p > i)
          return 1;
        x = a & A, B[x] = te << 24 | oe << 16 | S - I | 0;
      }
    }
    return a !== 0 && (B[S + a] = N - U << 24 | 64 << 16 | 0), k.bits = te, 0;
  }, cs;
}
var nd;
function p8() {
  if (nd)
    return yr;
  nd = 1;
  var e = bf(), t = Pb(), n = Cb(), i = l8(), s = d8(), r = 0, o = 1, u = 2, c = 4, h = 5, f = 6, b = 0, v = 1, m = 2, E = -2, M = -3, B = -4, I = -5, T = 8, k = 1, j = 2, N = 3, q = 4, D = 5, re = 6, te = 7, oe = 8, U = 9, y = 10, p = 11, a = 12, l = 13, _ = 14, x = 15, A = 16, S = 17, g = 18, w = 19, d = 20, R = 21, G = 22, fe = 23, z = 24, V = 25, F = 26, ee = 27, he = 28, Z = 29, K = 30, ce = 31, ve = 32, Be = 852, Q = 592, C = 15, L = C;
  function W(pe) {
    return (pe >>> 24 & 255) + (pe >>> 8 & 65280) + ((pe & 65280) << 8) + ((pe & 255) << 24);
  }
  function de() {
    this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new e.Buf16(320), this.work = new e.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
  }
  function me(pe) {
    var Ee;
    return !pe || !pe.state ? E : (Ee = pe.state, pe.total_in = pe.total_out = Ee.total = 0, pe.msg = "", Ee.wrap && (pe.adler = Ee.wrap & 1), Ee.mode = k, Ee.last = 0, Ee.havedict = 0, Ee.dmax = 32768, Ee.head = null, Ee.hold = 0, Ee.bits = 0, Ee.lencode = Ee.lendyn = new e.Buf32(Be), Ee.distcode = Ee.distdyn = new e.Buf32(Q), Ee.sane = 1, Ee.back = -1, b);
  }
  function Te(pe) {
    var Ee;
    return !pe || !pe.state ? E : (Ee = pe.state, Ee.wsize = 0, Ee.whave = 0, Ee.wnext = 0, me(pe));
  }
  function Fe(pe, Ee) {
    var J, Ie;
    return !pe || !pe.state || (Ie = pe.state, Ee < 0 ? (J = 0, Ee = -Ee) : (J = (Ee >> 4) + 1, Ee < 48 && (Ee &= 15)), Ee && (Ee < 8 || Ee > 15)) ? E : (Ie.window !== null && Ie.wbits !== Ee && (Ie.window = null), Ie.wrap = J, Ie.wbits = Ee, Te(pe));
  }
  function H(pe, Ee) {
    var J, Ie;
    return pe ? (Ie = new de(), pe.state = Ie, Ie.window = null, J = Fe(pe, Ee), J !== b && (pe.state = null), J) : E;
  }
  function ue(pe) {
    return H(pe, L);
  }
  var se = !0, we, Ce;
  function ze(pe) {
    if (se) {
      var Ee;
      for (we = new e.Buf32(512), Ce = new e.Buf32(32), Ee = 0; Ee < 144; )
        pe.lens[Ee++] = 8;
      for (; Ee < 256; )
        pe.lens[Ee++] = 9;
      for (; Ee < 280; )
        pe.lens[Ee++] = 7;
      for (; Ee < 288; )
        pe.lens[Ee++] = 8;
      for (s(o, pe.lens, 0, 288, we, 0, pe.work, { bits: 9 }), Ee = 0; Ee < 32; )
        pe.lens[Ee++] = 5;
      s(u, pe.lens, 0, 32, Ce, 0, pe.work, { bits: 5 }), se = !1;
    }
    pe.lencode = we, pe.lenbits = 9, pe.distcode = Ce, pe.distbits = 5;
  }
  function Le(pe, Ee, J, Ie) {
    var ke, P = pe.state;
    return P.window === null && (P.wsize = 1 << P.wbits, P.wnext = 0, P.whave = 0, P.window = new e.Buf8(P.wsize)), Ie >= P.wsize ? (e.arraySet(P.window, Ee, J - P.wsize, P.wsize, 0), P.wnext = 0, P.whave = P.wsize) : (ke = P.wsize - P.wnext, ke > Ie && (ke = Ie), e.arraySet(P.window, Ee, J - Ie, ke, P.wnext), Ie -= ke, Ie ? (e.arraySet(P.window, Ee, J - Ie, Ie, 0), P.wnext = Ie, P.whave = P.wsize) : (P.wnext += ke, P.wnext === P.wsize && (P.wnext = 0), P.whave < P.wsize && (P.whave += ke))), 0;
  }
  function Y(pe, Ee) {
    var J, Ie, ke, P, Me, be, ie, le, ge, Ge, De, Ne, rt, ft, We = 0, at, $, X, ne, O, ae, _e, xe, Re = new e.Buf8(4), qe, He, $e = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!pe || !pe.state || !pe.output || !pe.input && pe.avail_in !== 0)
      return E;
    J = pe.state, J.mode === a && (J.mode = l), Me = pe.next_out, ke = pe.output, ie = pe.avail_out, P = pe.next_in, Ie = pe.input, be = pe.avail_in, le = J.hold, ge = J.bits, Ge = be, De = ie, xe = b;
    e:
      for (; ; )
        switch (J.mode) {
          case k:
            if (J.wrap === 0) {
              J.mode = l;
              break;
            }
            for (; ge < 16; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            if (J.wrap & 2 && le === 35615) {
              J.check = 0, Re[0] = le & 255, Re[1] = le >>> 8 & 255, J.check = n(J.check, Re, 2, 0), le = 0, ge = 0, J.mode = j;
              break;
            }
            if (J.flags = 0, J.head && (J.head.done = !1), !(J.wrap & 1) || /* check if zlib header allowed */
            (((le & 255) << 8) + (le >> 8)) % 31) {
              pe.msg = "incorrect header check", J.mode = K;
              break;
            }
            if ((le & 15) !== T) {
              pe.msg = "unknown compression method", J.mode = K;
              break;
            }
            if (le >>>= 4, ge -= 4, _e = (le & 15) + 8, J.wbits === 0)
              J.wbits = _e;
            else if (_e > J.wbits) {
              pe.msg = "invalid window size", J.mode = K;
              break;
            }
            J.dmax = 1 << _e, pe.adler = J.check = 1, J.mode = le & 512 ? y : a, le = 0, ge = 0;
            break;
          case j:
            for (; ge < 16; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            if (J.flags = le, (J.flags & 255) !== T) {
              pe.msg = "unknown compression method", J.mode = K;
              break;
            }
            if (J.flags & 57344) {
              pe.msg = "unknown header flags set", J.mode = K;
              break;
            }
            J.head && (J.head.text = le >> 8 & 1), J.flags & 512 && (Re[0] = le & 255, Re[1] = le >>> 8 & 255, J.check = n(J.check, Re, 2, 0)), le = 0, ge = 0, J.mode = N;
          case N:
            for (; ge < 32; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            J.head && (J.head.time = le), J.flags & 512 && (Re[0] = le & 255, Re[1] = le >>> 8 & 255, Re[2] = le >>> 16 & 255, Re[3] = le >>> 24 & 255, J.check = n(J.check, Re, 4, 0)), le = 0, ge = 0, J.mode = q;
          case q:
            for (; ge < 16; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            J.head && (J.head.xflags = le & 255, J.head.os = le >> 8), J.flags & 512 && (Re[0] = le & 255, Re[1] = le >>> 8 & 255, J.check = n(J.check, Re, 2, 0)), le = 0, ge = 0, J.mode = D;
          case D:
            if (J.flags & 1024) {
              for (; ge < 16; ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              J.length = le, J.head && (J.head.extra_len = le), J.flags & 512 && (Re[0] = le & 255, Re[1] = le >>> 8 & 255, J.check = n(J.check, Re, 2, 0)), le = 0, ge = 0;
            } else
              J.head && (J.head.extra = null);
            J.mode = re;
          case re:
            if (J.flags & 1024 && (Ne = J.length, Ne > be && (Ne = be), Ne && (J.head && (_e = J.head.extra_len - J.length, J.head.extra || (J.head.extra = new Array(J.head.extra_len)), e.arraySet(
              J.head.extra,
              Ie,
              P,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              Ne,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              _e
            )), J.flags & 512 && (J.check = n(J.check, Ie, Ne, P)), be -= Ne, P += Ne, J.length -= Ne), J.length))
              break e;
            J.length = 0, J.mode = te;
          case te:
            if (J.flags & 2048) {
              if (be === 0)
                break e;
              Ne = 0;
              do
                _e = Ie[P + Ne++], J.head && _e && J.length < 65536 && (J.head.name += String.fromCharCode(_e));
              while (_e && Ne < be);
              if (J.flags & 512 && (J.check = n(J.check, Ie, Ne, P)), be -= Ne, P += Ne, _e)
                break e;
            } else
              J.head && (J.head.name = null);
            J.length = 0, J.mode = oe;
          case oe:
            if (J.flags & 4096) {
              if (be === 0)
                break e;
              Ne = 0;
              do
                _e = Ie[P + Ne++], J.head && _e && J.length < 65536 && (J.head.comment += String.fromCharCode(_e));
              while (_e && Ne < be);
              if (J.flags & 512 && (J.check = n(J.check, Ie, Ne, P)), be -= Ne, P += Ne, _e)
                break e;
            } else
              J.head && (J.head.comment = null);
            J.mode = U;
          case U:
            if (J.flags & 512) {
              for (; ge < 16; ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              if (le !== (J.check & 65535)) {
                pe.msg = "header crc mismatch", J.mode = K;
                break;
              }
              le = 0, ge = 0;
            }
            J.head && (J.head.hcrc = J.flags >> 9 & 1, J.head.done = !0), pe.adler = J.check = 0, J.mode = a;
            break;
          case y:
            for (; ge < 32; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            pe.adler = J.check = W(le), le = 0, ge = 0, J.mode = p;
          case p:
            if (J.havedict === 0)
              return pe.next_out = Me, pe.avail_out = ie, pe.next_in = P, pe.avail_in = be, J.hold = le, J.bits = ge, m;
            pe.adler = J.check = 1, J.mode = a;
          case a:
            if (Ee === h || Ee === f)
              break e;
          case l:
            if (J.last) {
              le >>>= ge & 7, ge -= ge & 7, J.mode = ee;
              break;
            }
            for (; ge < 3; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            switch (J.last = le & 1, le >>>= 1, ge -= 1, le & 3) {
              case 0:
                J.mode = _;
                break;
              case 1:
                if (ze(J), J.mode = d, Ee === f) {
                  le >>>= 2, ge -= 2;
                  break e;
                }
                break;
              case 2:
                J.mode = S;
                break;
              case 3:
                pe.msg = "invalid block type", J.mode = K;
            }
            le >>>= 2, ge -= 2;
            break;
          case _:
            for (le >>>= ge & 7, ge -= ge & 7; ge < 32; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            if ((le & 65535) !== (le >>> 16 ^ 65535)) {
              pe.msg = "invalid stored block lengths", J.mode = K;
              break;
            }
            if (J.length = le & 65535, le = 0, ge = 0, J.mode = x, Ee === f)
              break e;
          case x:
            J.mode = A;
          case A:
            if (Ne = J.length, Ne) {
              if (Ne > be && (Ne = be), Ne > ie && (Ne = ie), Ne === 0)
                break e;
              e.arraySet(ke, Ie, P, Ne, Me), be -= Ne, P += Ne, ie -= Ne, Me += Ne, J.length -= Ne;
              break;
            }
            J.mode = a;
            break;
          case S:
            for (; ge < 14; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            if (J.nlen = (le & 31) + 257, le >>>= 5, ge -= 5, J.ndist = (le & 31) + 1, le >>>= 5, ge -= 5, J.ncode = (le & 15) + 4, le >>>= 4, ge -= 4, J.nlen > 286 || J.ndist > 30) {
              pe.msg = "too many length or distance symbols", J.mode = K;
              break;
            }
            J.have = 0, J.mode = g;
          case g:
            for (; J.have < J.ncode; ) {
              for (; ge < 3; ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              J.lens[$e[J.have++]] = le & 7, le >>>= 3, ge -= 3;
            }
            for (; J.have < 19; )
              J.lens[$e[J.have++]] = 0;
            if (J.lencode = J.lendyn, J.lenbits = 7, qe = { bits: J.lenbits }, xe = s(r, J.lens, 0, 19, J.lencode, 0, J.work, qe), J.lenbits = qe.bits, xe) {
              pe.msg = "invalid code lengths set", J.mode = K;
              break;
            }
            J.have = 0, J.mode = w;
          case w:
            for (; J.have < J.nlen + J.ndist; ) {
              for (; We = J.lencode[le & (1 << J.lenbits) - 1], at = We >>> 24, $ = We >>> 16 & 255, X = We & 65535, !(at <= ge); ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              if (X < 16)
                le >>>= at, ge -= at, J.lens[J.have++] = X;
              else {
                if (X === 16) {
                  for (He = at + 2; ge < He; ) {
                    if (be === 0)
                      break e;
                    be--, le += Ie[P++] << ge, ge += 8;
                  }
                  if (le >>>= at, ge -= at, J.have === 0) {
                    pe.msg = "invalid bit length repeat", J.mode = K;
                    break;
                  }
                  _e = J.lens[J.have - 1], Ne = 3 + (le & 3), le >>>= 2, ge -= 2;
                } else if (X === 17) {
                  for (He = at + 3; ge < He; ) {
                    if (be === 0)
                      break e;
                    be--, le += Ie[P++] << ge, ge += 8;
                  }
                  le >>>= at, ge -= at, _e = 0, Ne = 3 + (le & 7), le >>>= 3, ge -= 3;
                } else {
                  for (He = at + 7; ge < He; ) {
                    if (be === 0)
                      break e;
                    be--, le += Ie[P++] << ge, ge += 8;
                  }
                  le >>>= at, ge -= at, _e = 0, Ne = 11 + (le & 127), le >>>= 7, ge -= 7;
                }
                if (J.have + Ne > J.nlen + J.ndist) {
                  pe.msg = "invalid bit length repeat", J.mode = K;
                  break;
                }
                for (; Ne--; )
                  J.lens[J.have++] = _e;
              }
            }
            if (J.mode === K)
              break;
            if (J.lens[256] === 0) {
              pe.msg = "invalid code -- missing end-of-block", J.mode = K;
              break;
            }
            if (J.lenbits = 9, qe = { bits: J.lenbits }, xe = s(o, J.lens, 0, J.nlen, J.lencode, 0, J.work, qe), J.lenbits = qe.bits, xe) {
              pe.msg = "invalid literal/lengths set", J.mode = K;
              break;
            }
            if (J.distbits = 6, J.distcode = J.distdyn, qe = { bits: J.distbits }, xe = s(u, J.lens, J.nlen, J.ndist, J.distcode, 0, J.work, qe), J.distbits = qe.bits, xe) {
              pe.msg = "invalid distances set", J.mode = K;
              break;
            }
            if (J.mode = d, Ee === f)
              break e;
          case d:
            J.mode = R;
          case R:
            if (be >= 6 && ie >= 258) {
              pe.next_out = Me, pe.avail_out = ie, pe.next_in = P, pe.avail_in = be, J.hold = le, J.bits = ge, i(pe, De), Me = pe.next_out, ke = pe.output, ie = pe.avail_out, P = pe.next_in, Ie = pe.input, be = pe.avail_in, le = J.hold, ge = J.bits, J.mode === a && (J.back = -1);
              break;
            }
            for (J.back = 0; We = J.lencode[le & (1 << J.lenbits) - 1], at = We >>> 24, $ = We >>> 16 & 255, X = We & 65535, !(at <= ge); ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            if ($ && !($ & 240)) {
              for (ne = at, O = $, ae = X; We = J.lencode[ae + ((le & (1 << ne + O) - 1) >> ne)], at = We >>> 24, $ = We >>> 16 & 255, X = We & 65535, !(ne + at <= ge); ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              le >>>= ne, ge -= ne, J.back += ne;
            }
            if (le >>>= at, ge -= at, J.back += at, J.length = X, $ === 0) {
              J.mode = F;
              break;
            }
            if ($ & 32) {
              J.back = -1, J.mode = a;
              break;
            }
            if ($ & 64) {
              pe.msg = "invalid literal/length code", J.mode = K;
              break;
            }
            J.extra = $ & 15, J.mode = G;
          case G:
            if (J.extra) {
              for (He = J.extra; ge < He; ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              J.length += le & (1 << J.extra) - 1, le >>>= J.extra, ge -= J.extra, J.back += J.extra;
            }
            J.was = J.length, J.mode = fe;
          case fe:
            for (; We = J.distcode[le & (1 << J.distbits) - 1], at = We >>> 24, $ = We >>> 16 & 255, X = We & 65535, !(at <= ge); ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            if (!($ & 240)) {
              for (ne = at, O = $, ae = X; We = J.distcode[ae + ((le & (1 << ne + O) - 1) >> ne)], at = We >>> 24, $ = We >>> 16 & 255, X = We & 65535, !(ne + at <= ge); ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              le >>>= ne, ge -= ne, J.back += ne;
            }
            if (le >>>= at, ge -= at, J.back += at, $ & 64) {
              pe.msg = "invalid distance code", J.mode = K;
              break;
            }
            J.offset = X, J.extra = $ & 15, J.mode = z;
          case z:
            if (J.extra) {
              for (He = J.extra; ge < He; ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              J.offset += le & (1 << J.extra) - 1, le >>>= J.extra, ge -= J.extra, J.back += J.extra;
            }
            if (J.offset > J.dmax) {
              pe.msg = "invalid distance too far back", J.mode = K;
              break;
            }
            J.mode = V;
          case V:
            if (ie === 0)
              break e;
            if (Ne = De - ie, J.offset > Ne) {
              if (Ne = J.offset - Ne, Ne > J.whave && J.sane) {
                pe.msg = "invalid distance too far back", J.mode = K;
                break;
              }
              Ne > J.wnext ? (Ne -= J.wnext, rt = J.wsize - Ne) : rt = J.wnext - Ne, Ne > J.length && (Ne = J.length), ft = J.window;
            } else
              ft = ke, rt = Me - J.offset, Ne = J.length;
            Ne > ie && (Ne = ie), ie -= Ne, J.length -= Ne;
            do
              ke[Me++] = ft[rt++];
            while (--Ne);
            J.length === 0 && (J.mode = R);
            break;
          case F:
            if (ie === 0)
              break e;
            ke[Me++] = J.length, ie--, J.mode = R;
            break;
          case ee:
            if (J.wrap) {
              for (; ge < 32; ) {
                if (be === 0)
                  break e;
                be--, le |= Ie[P++] << ge, ge += 8;
              }
              if (De -= ie, pe.total_out += De, J.total += De, De && (pe.adler = J.check = /*UPDATE(state.check, put - _out, _out);*/
              J.flags ? n(J.check, ke, De, Me - De) : t(J.check, ke, De, Me - De)), De = ie, (J.flags ? le : W(le)) !== J.check) {
                pe.msg = "incorrect data check", J.mode = K;
                break;
              }
              le = 0, ge = 0;
            }
            J.mode = he;
          case he:
            if (J.wrap && J.flags) {
              for (; ge < 32; ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              if (le !== (J.total & 4294967295)) {
                pe.msg = "incorrect length check", J.mode = K;
                break;
              }
              le = 0, ge = 0;
            }
            J.mode = Z;
          case Z:
            xe = v;
            break e;
          case K:
            xe = M;
            break e;
          case ce:
            return B;
          case ve:
          default:
            return E;
        }
    return pe.next_out = Me, pe.avail_out = ie, pe.next_in = P, pe.avail_in = be, J.hold = le, J.bits = ge, (J.wsize || De !== pe.avail_out && J.mode < K && (J.mode < ee || Ee !== c)) && Le(pe, pe.output, pe.next_out, De - pe.avail_out), Ge -= pe.avail_in, De -= pe.avail_out, pe.total_in += Ge, pe.total_out += De, J.total += De, J.wrap && De && (pe.adler = J.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    J.flags ? n(J.check, ke, De, pe.next_out - De) : t(J.check, ke, De, pe.next_out - De)), pe.data_type = J.bits + (J.last ? 64 : 0) + (J.mode === a ? 128 : 0) + (J.mode === d || J.mode === x ? 256 : 0), (Ge === 0 && De === 0 || Ee === c) && xe === b && (xe = I), xe;
  }
  function Se(pe) {
    if (!pe || !pe.state)
      return E;
    var Ee = pe.state;
    return Ee.window && (Ee.window = null), pe.state = null, b;
  }
  function Ae(pe, Ee) {
    var J;
    return !pe || !pe.state || (J = pe.state, !(J.wrap & 2)) ? E : (J.head = Ee, Ee.done = !1, b);
  }
  function je(pe, Ee) {
    var J = Ee.length, Ie, ke, P;
    return !pe || !pe.state || (Ie = pe.state, Ie.wrap !== 0 && Ie.mode !== p) ? E : Ie.mode === p && (ke = 1, ke = t(ke, Ee, J, 0), ke !== Ie.check) ? M : (P = Le(pe, Ee, J, J), P ? (Ie.mode = ce, B) : (Ie.havedict = 1, b));
  }
  return yr.inflateReset = Te, yr.inflateReset2 = Fe, yr.inflateResetKeep = me, yr.inflateInit = ue, yr.inflateInit2 = H, yr.inflate = Y, yr.inflateEnd = Se, yr.inflateGetHeader = Ae, yr.inflateSetDictionary = je, yr.inflateInfo = "pako inflate (from Nodeca project)", yr;
}
var hs, id;
function v8() {
  return id || (id = 1, hs = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  }), hs;
}
var ad;
function b8() {
  return ad || (ad = 1, function(e) {
    var t = Sa(), n = s8(), i = h8(), s = p8(), r = v8();
    for (var o in r)
      e[o] = r[o];
    e.NONE = 0, e.DEFLATE = 1, e.INFLATE = 2, e.GZIP = 3, e.GUNZIP = 4, e.DEFLATERAW = 5, e.INFLATERAW = 6, e.UNZIP = 7;
    var u = 31, c = 139;
    function h(f) {
      if (typeof f != "number" || f < e.DEFLATE || f > e.UNZIP)
        throw new TypeError("Bad argument");
      this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = f, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0;
    }
    h.prototype.close = function() {
      if (this.write_in_progress) {
        this.pending_close = !0;
        return;
      }
      this.pending_close = !1, t(this.init_done, "close before init"), t(this.mode <= e.UNZIP), this.mode === e.DEFLATE || this.mode === e.GZIP || this.mode === e.DEFLATERAW ? i.deflateEnd(this.strm) : (this.mode === e.INFLATE || this.mode === e.GUNZIP || this.mode === e.INFLATERAW || this.mode === e.UNZIP) && s.inflateEnd(this.strm), this.mode = e.NONE, this.dictionary = null;
    }, h.prototype.write = function(f, b, v, m, E, M, B) {
      return this._write(!0, f, b, v, m, E, M, B);
    }, h.prototype.writeSync = function(f, b, v, m, E, M, B) {
      return this._write(!1, f, b, v, m, E, M, B);
    }, h.prototype._write = function(f, b, v, m, E, M, B, I) {
      if (t.equal(arguments.length, 8), t(this.init_done, "write before init"), t(this.mode !== e.NONE, "already finalized"), t.equal(!1, this.write_in_progress, "write already in progress"), t.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, t.equal(!1, b === void 0, "must provide flush value"), this.write_in_progress = !0, b !== e.Z_NO_FLUSH && b !== e.Z_PARTIAL_FLUSH && b !== e.Z_SYNC_FLUSH && b !== e.Z_FULL_FLUSH && b !== e.Z_FINISH && b !== e.Z_BLOCK)
        throw new Error("Invalid flush value");
      if (v == null && (v = Buffer.alloc(0), E = 0, m = 0), this.strm.avail_in = E, this.strm.input = v, this.strm.next_in = m, this.strm.avail_out = I, this.strm.output = M, this.strm.next_out = B, this.flush = b, !f)
        return this._process(), this._checkError() ? this._afterSync() : void 0;
      var T = this;
      return process.nextTick(function() {
        T._process(), T._after();
      }), this;
    }, h.prototype._afterSync = function() {
      var f = this.strm.avail_out, b = this.strm.avail_in;
      return this.write_in_progress = !1, [b, f];
    }, h.prototype._process = function() {
      var f = null;
      switch (this.mode) {
        case e.DEFLATE:
        case e.GZIP:
        case e.DEFLATERAW:
          this.err = i.deflate(this.strm, this.flush);
          break;
        case e.UNZIP:
          switch (this.strm.avail_in > 0 && (f = this.strm.next_in), this.gzip_id_bytes_read) {
            case 0:
              if (f === null)
                break;
              if (this.strm.input[f] === u) {
                if (this.gzip_id_bytes_read = 1, f++, this.strm.avail_in === 1)
                  break;
              } else {
                this.mode = e.INFLATE;
                break;
              }
            case 1:
              if (f === null)
                break;
              this.strm.input[f] === c ? (this.gzip_id_bytes_read = 2, this.mode = e.GUNZIP) : this.mode = e.INFLATE;
              break;
            default:
              throw new Error("invalid number of gzip magic number bytes read");
          }
        case e.INFLATE:
        case e.GUNZIP:
        case e.INFLATERAW:
          for (this.err = s.inflate(
            this.strm,
            this.flush
            // If data was encoded with dictionary
          ), this.err === e.Z_NEED_DICT && this.dictionary && (this.err = s.inflateSetDictionary(this.strm, this.dictionary), this.err === e.Z_OK ? this.err = s.inflate(this.strm, this.flush) : this.err === e.Z_DATA_ERROR && (this.err = e.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === e.GUNZIP && this.err === e.Z_STREAM_END && this.strm.next_in[0] !== 0; )
            this.reset(), this.err = s.inflate(this.strm, this.flush);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
    }, h.prototype._checkError = function() {
      switch (this.err) {
        case e.Z_OK:
        case e.Z_BUF_ERROR:
          if (this.strm.avail_out !== 0 && this.flush === e.Z_FINISH)
            return this._error("unexpected end of file"), !1;
          break;
        case e.Z_STREAM_END:
          break;
        case e.Z_NEED_DICT:
          return this.dictionary == null ? this._error("Missing dictionary") : this._error("Bad dictionary"), !1;
        default:
          return this._error("Zlib error"), !1;
      }
      return !0;
    }, h.prototype._after = function() {
      if (this._checkError()) {
        var f = this.strm.avail_out, b = this.strm.avail_in;
        this.write_in_progress = !1, this.callback(b, f), this.pending_close && this.close();
      }
    }, h.prototype._error = function(f) {
      this.strm.msg && (f = this.strm.msg), this.onerror(
        f,
        this.err
        // no hope of rescue.
      ), this.write_in_progress = !1, this.pending_close && this.close();
    }, h.prototype.init = function(f, b, v, m, E) {
      t(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])"), t(f >= 8 && f <= 15, "invalid windowBits"), t(b >= -1 && b <= 9, "invalid compression level"), t(v >= 1 && v <= 9, "invalid memlevel"), t(m === e.Z_FILTERED || m === e.Z_HUFFMAN_ONLY || m === e.Z_RLE || m === e.Z_FIXED || m === e.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(b, f, v, m, E), this._setDictionary();
    }, h.prototype.params = function() {
      throw new Error("deflateParams Not supported");
    }, h.prototype.reset = function() {
      this._reset(), this._setDictionary();
    }, h.prototype._init = function(f, b, v, m, E) {
      switch (this.level = f, this.windowBits = b, this.memLevel = v, this.strategy = m, this.flush = e.Z_NO_FLUSH, this.err = e.Z_OK, (this.mode === e.GZIP || this.mode === e.GUNZIP) && (this.windowBits += 16), this.mode === e.UNZIP && (this.windowBits += 32), (this.mode === e.DEFLATERAW || this.mode === e.INFLATERAW) && (this.windowBits = -1 * this.windowBits), this.strm = new n(), this.mode) {
        case e.DEFLATE:
        case e.GZIP:
        case e.DEFLATERAW:
          this.err = i.deflateInit2(this.strm, this.level, e.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
          break;
        case e.INFLATE:
        case e.GUNZIP:
        case e.INFLATERAW:
        case e.UNZIP:
          this.err = s.inflateInit2(this.strm, this.windowBits);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      this.err !== e.Z_OK && this._error("Init error"), this.dictionary = E, this.write_in_progress = !1, this.init_done = !0;
    }, h.prototype._setDictionary = function() {
      if (this.dictionary != null) {
        switch (this.err = e.Z_OK, this.mode) {
          case e.DEFLATE:
          case e.DEFLATERAW:
            this.err = i.deflateSetDictionary(this.strm, this.dictionary);
            break;
        }
        this.err !== e.Z_OK && this._error("Failed to set dictionary");
      }
    }, h.prototype._reset = function() {
      switch (this.err = e.Z_OK, this.mode) {
        case e.DEFLATE:
        case e.DEFLATERAW:
        case e.GZIP:
          this.err = i.deflateReset(this.strm);
          break;
        case e.INFLATE:
        case e.INFLATERAW:
        case e.GUNZIP:
          this.err = s.inflateReset(this.strm);
          break;
      }
      this.err !== e.Z_OK && this._error("Failed to reset stream");
    }, e.Zlib = h;
  }(jo)), jo;
}
var fd;
function y8() {
  return fd || (fd = 1, function(e) {
    var t = dr.Buffer, n = Sb().Transform, i = b8(), s = nn(), r = Sa().ok, o = dr.kMaxLength, u = "Cannot create final Buffer. It would be larger than 0x" + o.toString(16) + " bytes";
    i.Z_MIN_WINDOWBITS = 8, i.Z_MAX_WINDOWBITS = 15, i.Z_DEFAULT_WINDOWBITS = 15, i.Z_MIN_CHUNK = 64, i.Z_MAX_CHUNK = 1 / 0, i.Z_DEFAULT_CHUNK = 16 * 1024, i.Z_MIN_MEMLEVEL = 1, i.Z_MAX_MEMLEVEL = 9, i.Z_DEFAULT_MEMLEVEL = 8, i.Z_MIN_LEVEL = -1, i.Z_MAX_LEVEL = 9, i.Z_DEFAULT_LEVEL = i.Z_DEFAULT_COMPRESSION;
    for (var c = Object.keys(i), h = 0; h < c.length; h++) {
      var f = c[h];
      f.match(/^Z/) && Object.defineProperty(e, f, {
        enumerable: !0,
        value: i[f],
        writable: !1
      });
    }
    for (var b = {
      Z_OK: i.Z_OK,
      Z_STREAM_END: i.Z_STREAM_END,
      Z_NEED_DICT: i.Z_NEED_DICT,
      Z_ERRNO: i.Z_ERRNO,
      Z_STREAM_ERROR: i.Z_STREAM_ERROR,
      Z_DATA_ERROR: i.Z_DATA_ERROR,
      Z_MEM_ERROR: i.Z_MEM_ERROR,
      Z_BUF_ERROR: i.Z_BUF_ERROR,
      Z_VERSION_ERROR: i.Z_VERSION_ERROR
    }, v = Object.keys(b), m = 0; m < v.length; m++) {
      var E = v[m];
      b[b[E]] = E;
    }
    Object.defineProperty(e, "codes", {
      enumerable: !0,
      value: Object.freeze(b),
      writable: !1
    }), e.Deflate = I, e.Inflate = T, e.Gzip = k, e.Gunzip = j, e.DeflateRaw = N, e.InflateRaw = q, e.Unzip = D, e.createDeflate = function(y) {
      return new I(y);
    }, e.createInflate = function(y) {
      return new T(y);
    }, e.createDeflateRaw = function(y) {
      return new N(y);
    }, e.createInflateRaw = function(y) {
      return new q(y);
    }, e.createGzip = function(y) {
      return new k(y);
    }, e.createGunzip = function(y) {
      return new j(y);
    }, e.createUnzip = function(y) {
      return new D(y);
    }, e.deflate = function(y, p, a) {
      return typeof p == "function" && (a = p, p = {}), M(new I(p), y, a);
    }, e.deflateSync = function(y, p) {
      return B(new I(p), y);
    }, e.gzip = function(y, p, a) {
      return typeof p == "function" && (a = p, p = {}), M(new k(p), y, a);
    }, e.gzipSync = function(y, p) {
      return B(new k(p), y);
    }, e.deflateRaw = function(y, p, a) {
      return typeof p == "function" && (a = p, p = {}), M(new N(p), y, a);
    }, e.deflateRawSync = function(y, p) {
      return B(new N(p), y);
    }, e.unzip = function(y, p, a) {
      return typeof p == "function" && (a = p, p = {}), M(new D(p), y, a);
    }, e.unzipSync = function(y, p) {
      return B(new D(p), y);
    }, e.inflate = function(y, p, a) {
      return typeof p == "function" && (a = p, p = {}), M(new T(p), y, a);
    }, e.inflateSync = function(y, p) {
      return B(new T(p), y);
    }, e.gunzip = function(y, p, a) {
      return typeof p == "function" && (a = p, p = {}), M(new j(p), y, a);
    }, e.gunzipSync = function(y, p) {
      return B(new j(p), y);
    }, e.inflateRaw = function(y, p, a) {
      return typeof p == "function" && (a = p, p = {}), M(new q(p), y, a);
    }, e.inflateRawSync = function(y, p) {
      return B(new q(p), y);
    };
    function M(y, p, a) {
      var l = [], _ = 0;
      y.on("error", A), y.on("end", S), y.end(p), x();
      function x() {
        for (var g; (g = y.read()) !== null; )
          l.push(g), _ += g.length;
        y.once("readable", x);
      }
      function A(g) {
        y.removeListener("end", S), y.removeListener("readable", x), a(g);
      }
      function S() {
        var g, w = null;
        _ >= o ? w = new RangeError(u) : g = t.concat(l, _), l = [], y.close(), a(w, g);
      }
    }
    function B(y, p) {
      if (typeof p == "string" && (p = t.from(p)), !t.isBuffer(p))
        throw new TypeError("Not a string or buffer");
      var a = y._finishFlushFlag;
      return y._processChunk(p, a);
    }
    function I(y) {
      if (!(this instanceof I))
        return new I(y);
      te.call(this, y, i.DEFLATE);
    }
    function T(y) {
      if (!(this instanceof T))
        return new T(y);
      te.call(this, y, i.INFLATE);
    }
    function k(y) {
      if (!(this instanceof k))
        return new k(y);
      te.call(this, y, i.GZIP);
    }
    function j(y) {
      if (!(this instanceof j))
        return new j(y);
      te.call(this, y, i.GUNZIP);
    }
    function N(y) {
      if (!(this instanceof N))
        return new N(y);
      te.call(this, y, i.DEFLATERAW);
    }
    function q(y) {
      if (!(this instanceof q))
        return new q(y);
      te.call(this, y, i.INFLATERAW);
    }
    function D(y) {
      if (!(this instanceof D))
        return new D(y);
      te.call(this, y, i.UNZIP);
    }
    function re(y) {
      return y === i.Z_NO_FLUSH || y === i.Z_PARTIAL_FLUSH || y === i.Z_SYNC_FLUSH || y === i.Z_FULL_FLUSH || y === i.Z_FINISH || y === i.Z_BLOCK;
    }
    function te(y, p) {
      var a = this;
      if (this._opts = y = y || {}, this._chunkSize = y.chunkSize || e.Z_DEFAULT_CHUNK, n.call(this, y), y.flush && !re(y.flush))
        throw new Error("Invalid flush flag: " + y.flush);
      if (y.finishFlush && !re(y.finishFlush))
        throw new Error("Invalid flush flag: " + y.finishFlush);
      if (this._flushFlag = y.flush || i.Z_NO_FLUSH, this._finishFlushFlag = typeof y.finishFlush < "u" ? y.finishFlush : i.Z_FINISH, y.chunkSize && (y.chunkSize < e.Z_MIN_CHUNK || y.chunkSize > e.Z_MAX_CHUNK))
        throw new Error("Invalid chunk size: " + y.chunkSize);
      if (y.windowBits && (y.windowBits < e.Z_MIN_WINDOWBITS || y.windowBits > e.Z_MAX_WINDOWBITS))
        throw new Error("Invalid windowBits: " + y.windowBits);
      if (y.level && (y.level < e.Z_MIN_LEVEL || y.level > e.Z_MAX_LEVEL))
        throw new Error("Invalid compression level: " + y.level);
      if (y.memLevel && (y.memLevel < e.Z_MIN_MEMLEVEL || y.memLevel > e.Z_MAX_MEMLEVEL))
        throw new Error("Invalid memLevel: " + y.memLevel);
      if (y.strategy && y.strategy != e.Z_FILTERED && y.strategy != e.Z_HUFFMAN_ONLY && y.strategy != e.Z_RLE && y.strategy != e.Z_FIXED && y.strategy != e.Z_DEFAULT_STRATEGY)
        throw new Error("Invalid strategy: " + y.strategy);
      if (y.dictionary && !t.isBuffer(y.dictionary))
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      this._handle = new i.Zlib(p);
      var l = this;
      this._hadError = !1, this._handle.onerror = function(A, S) {
        oe(l), l._hadError = !0;
        var g = new Error(A);
        g.errno = S, g.code = e.codes[S], l.emit("error", g);
      };
      var _ = e.Z_DEFAULT_COMPRESSION;
      typeof y.level == "number" && (_ = y.level);
      var x = e.Z_DEFAULT_STRATEGY;
      typeof y.strategy == "number" && (x = y.strategy), this._handle.init(y.windowBits || e.Z_DEFAULT_WINDOWBITS, _, y.memLevel || e.Z_DEFAULT_MEMLEVEL, x, y.dictionary), this._buffer = t.allocUnsafe(this._chunkSize), this._offset = 0, this._level = _, this._strategy = x, this.once("end", this.close), Object.defineProperty(this, "_closed", {
        get: function() {
          return !a._handle;
        },
        configurable: !0,
        enumerable: !0
      });
    }
    s.inherits(te, n), te.prototype.params = function(y, p, a) {
      if (y < e.Z_MIN_LEVEL || y > e.Z_MAX_LEVEL)
        throw new RangeError("Invalid compression level: " + y);
      if (p != e.Z_FILTERED && p != e.Z_HUFFMAN_ONLY && p != e.Z_RLE && p != e.Z_FIXED && p != e.Z_DEFAULT_STRATEGY)
        throw new TypeError("Invalid strategy: " + p);
      if (this._level !== y || this._strategy !== p) {
        var l = this;
        this.flush(i.Z_SYNC_FLUSH, function() {
          r(l._handle, "zlib binding closed"), l._handle.params(y, p), l._hadError || (l._level = y, l._strategy = p, a && a());
        });
      } else
        process.nextTick(a);
    }, te.prototype.reset = function() {
      return r(this._handle, "zlib binding closed"), this._handle.reset();
    }, te.prototype._flush = function(y) {
      this._transform(t.alloc(0), "", y);
    }, te.prototype.flush = function(y, p) {
      var a = this, l = this._writableState;
      (typeof y == "function" || y === void 0 && !p) && (p = y, y = i.Z_FULL_FLUSH), l.ended ? p && process.nextTick(p) : l.ending ? p && this.once("end", p) : l.needDrain ? p && this.once("drain", function() {
        return a.flush(y, p);
      }) : (this._flushFlag = y, this.write(t.alloc(0), "", p));
    }, te.prototype.close = function(y) {
      oe(this, y), process.nextTick(U, this);
    };
    function oe(y, p) {
      p && process.nextTick(p), y._handle && (y._handle.close(), y._handle = null);
    }
    function U(y) {
      y.emit("close");
    }
    te.prototype._transform = function(y, p, a) {
      var l, _ = this._writableState, x = _.ending || _.ended, A = x && (!y || _.length === y.length);
      if (y !== null && !t.isBuffer(y))
        return a(new Error("invalid input"));
      if (!this._handle)
        return a(new Error("zlib binding closed"));
      A ? l = this._finishFlushFlag : (l = this._flushFlag, y.length >= _.length && (this._flushFlag = this._opts.flush || i.Z_NO_FLUSH)), this._processChunk(y, l, a);
    }, te.prototype._processChunk = function(y, p, a) {
      var l = y && y.length, _ = this._chunkSize - this._offset, x = 0, A = this, S = typeof a == "function";
      if (!S) {
        var g = [], w = 0, d;
        this.on("error", function(V) {
          d = V;
        }), r(this._handle, "zlib binding closed");
        do
          var R = this._handle.writeSync(
            p,
            y,
            // in
            x,
            // in_off
            l,
            // in_len
            this._buffer,
            // out
            this._offset,
            //out_off
            _
          );
        while (!this._hadError && z(R[0], R[1]));
        if (this._hadError)
          throw d;
        if (w >= o)
          throw oe(this), new RangeError(u);
        var G = t.concat(g, w);
        return oe(this), G;
      }
      r(this._handle, "zlib binding closed");
      var fe = this._handle.write(
        p,
        y,
        // in
        x,
        // in_off
        l,
        // in_len
        this._buffer,
        // out
        this._offset,
        //out_off
        _
      );
      fe.buffer = y, fe.callback = z;
      function z(V, F) {
        if (this && (this.buffer = null, this.callback = null), !A._hadError) {
          var ee = _ - F;
          if (r(ee >= 0, "have should not go down"), ee > 0) {
            var he = A._buffer.slice(A._offset, A._offset + ee);
            A._offset += ee, S ? A.push(he) : (g.push(he), w += he.length);
          }
          if ((F === 0 || A._offset >= A._chunkSize) && (_ = A._chunkSize, A._offset = 0, A._buffer = t.allocUnsafe(A._chunkSize)), F === 0) {
            if (x += l - V, l = V, !S)
              return !0;
            var Z = A._handle.write(p, y, x, l, A._buffer, A._offset, A._chunkSize);
            Z.callback = z, Z.buffer = y;
            return;
          }
          if (!S)
            return !1;
          a();
        }
      }
    }, s.inherits(I, te), s.inherits(T, te), s.inherits(k, te), s.inherits(j, te), s.inherits(N, te), s.inherits(q, te), s.inherits(D, te);
  }(Lo)), Lo;
}
Object.defineProperty(In, "__esModule", { value: !0 });
In.InvalidStatusCodeError = In.InvalidCertError = void 0;
const Nb = Object.freeze({
  redirect: !0,
  expectStatusCode: 200,
  headers: {},
  full: !1,
  keepAlive: !0,
  cors: !1,
  referrer: !1,
  sslAllowSelfSigned: !1,
  _redirectCount: 0
});
class bc extends Error {
  constructor(t, n) {
    super(t), this.fingerprint256 = n;
  }
}
In.InvalidCertError = bc;
class s0 extends Error {
  constructor(t) {
    super(`Request Failed. Status Code: ${t}`), this.statusCode = t;
  }
}
In.InvalidStatusCodeError = s0;
function Lb(e, t) {
  if (!t || t === "text" || t === "json")
    try {
      let n = new TextDecoder("utf8", { fatal: !0 }).decode(e);
      if (t === "text")
        return n;
      try {
        return JSON.parse(n);
      } catch (i) {
        if (t === "json")
          throw i;
        return n;
      }
    } catch (n) {
      if (t === "text" || t === "json")
        throw n;
    }
  return e;
}
let od = {};
function yc(e, t) {
  var v;
  let n = { ...Nb, ...t };
  const i = Eb(), s = X4(), r = y8(), { promisify: o } = nn(), { resolve: u } = f0(), c = !!/^https/.test(e);
  let h = {
    method: n.method || "GET",
    headers: { "Accept-Encoding": "gzip, deflate, br" }
  };
  const f = (m) => m.replace(/:| /g, "").toLowerCase();
  if (n.keepAlive) {
    const m = {
      keepAlive: !0,
      keepAliveMsecs: 3e4,
      maxFreeSockets: 1024,
      maxCachedSessions: 1024
    }, E = [
      c,
      c && ((v = n.sslPinnedCertificates) == null ? void 0 : v.map((M) => f(M)).sort())
    ].join();
    h.agent = od[E] || (od[E] = new (c ? s : i).Agent(m));
  }
  n.type === "json" && (h.headers["Content-Type"] = "application/json"), n.data && (n.method || (h.method = "POST"), h.body = n.type === "json" ? JSON.stringify(n.data) : n.data), h.headers = { ...h.headers, ...n.headers }, n.sslAllowSelfSigned && (h.rejectUnauthorized = !1);
  const b = async (m) => {
    const E = m.statusCode;
    if (n.redirect && 300 <= E && E < 400 && m.headers.location) {
      if (n._redirectCount == 10)
        throw new Error("Request failed. Too much redirects.");
      return n._redirectCount += 1, await yc(u(e, m.headers.location), n);
    }
    if (n.expectStatusCode && E !== n.expectStatusCode)
      throw m.resume(), new s0(E);
    let M = [];
    for await (const k of m)
      M.push(k);
    let B = Buffer.concat(M);
    const I = m.headers["content-encoding"];
    I === "br" && (B = await o(r.brotliDecompress)(B)), (I === "gzip" || I === "deflate") && (B = await o(r.unzip)(B));
    const T = Lb(B, n.type);
    return n.full ? { headers: m.headers, status: E, body: T } : T;
  };
  return new Promise((m, E) => {
    var k;
    const M = async (j) => {
      if (j && j.code === "DEPTH_ZERO_SELF_SIGNED_CERT")
        try {
          await yc(e, { ...n, sslAllowSelfSigned: !0, sslPinnedCertificates: [] });
        } catch (N) {
          N && N.fingerprint256 && (j = new bc(`Self-signed SSL certificate: ${N.fingerprint256}`, N.fingerprint256));
        }
      E(j);
    }, B = (c ? s : i).request(e, h, (j) => {
      j.on("error", M), (async () => {
        try {
          m(await b(j));
        } catch (N) {
          E(N);
        }
      })();
    });
    B.on("error", M);
    const I = (k = n.sslPinnedCertificates) == null ? void 0 : k.map((j) => f(j)), T = (j) => {
      var q;
      const N = f(((q = j.getPeerCertificate()) == null ? void 0 : q.fingerprint256) || "");
      if (!(!N && j.isSessionReused()) && !I.includes(N))
        return B.emit("error", new bc(`Invalid SSL certificate: ${N} Expected: ${I}`, N)), B.abort();
    };
    n.sslPinnedCertificates && B.on("socket", (j) => {
      j.listeners("secureConnect").map((q) => (q.name || "").replace("bound ", "")).includes("mfetchSecureConnect") || j.on("secureConnect", T.bind(null, j));
    }), n.keepAlive && B.setNoDelay(!0), h.body && B.write(h.body), B.end();
  });
}
const g8 = new Set(["Accept", "Accept-Language", "Content-Language", "Content-Type"].map((e) => e.toLowerCase())), m8 = new Set([
  "Accept-Charset",
  "Accept-Encoding",
  "Access-Control-Request-Headers",
  "Access-Control-Request-Method",
  "Connection",
  "Content-Length",
  "Cookie",
  "Cookie2",
  "Date",
  "DNT",
  "Expect",
  "Host",
  "Keep-Alive",
  "Origin",
  "Referer",
  "TE",
  "Trailer",
  "Transfer-Encoding",
  "Upgrade",
  "Via"
].map((e) => e.toLowerCase()));
async function _8(e, t) {
  let n = { ...Nb, ...t };
  const i = new Headers();
  n.type === "json" && i.set("Content-Type", "application/json");
  let s = new URL(e);
  if (s.username) {
    const c = btoa(`${s.username}:${s.password}`);
    i.set("Authorization", `Basic ${c}`), s.username = "", s.password = "";
  }
  e = "" + s;
  for (let c in n.headers) {
    const h = c.toLowerCase();
    (g8.has(h) || n.cors && !m8.has(h)) && i.set(c, n.headers[c]);
  }
  let r = { headers: i, redirect: n.redirect ? "follow" : "manual" };
  n.referrer || (r.referrerPolicy = "no-referrer"), n.cors && (r.mode = "cors"), n.data && (n.method || (r.method = "POST"), r.body = n.type === "json" ? JSON.stringify(n.data) : n.data);
  const o = await fetch(e, r);
  if (n.expectStatusCode && o.status !== n.expectStatusCode)
    throw new s0(o.status);
  const u = Lb(new Uint8Array(await o.arrayBuffer()), n.type);
  return n.full ? { headers: Object.fromEntries(o.headers.entries()), status: o.status, body: u } : u;
}
const w8 = !!(typeof process == "object" && process.versions && process.versions.node && process.versions.v8);
function x8(e, t) {
  return (w8 ? yc : _8)(e, t);
}
In.default = x8;
Object.defineProperty(ni, "__esModule", { value: !0 });
ni.getProvider = ni.fetchFromProvider = void 0;
const E8 = In, S8 = async (e, t) => (await (0, E8.default)(e, {
  headers: {
    "content-type": "application/json"
  },
  type: "json",
  data: {
    method: t.method,
    params: t.params,
    jsonrpc: "2.0",
    id: 1
  }
})).result;
ni.fetchFromProvider = S8;
const A8 = (e) => {
  var t;
  if (typeof e == "string")
    return e;
  if (((t = e == null ? void 0 : e.connection) == null ? void 0 : t.url) !== void 0)
    return e.connection.url;
  throw new Error("Must provide valid provider URL or Web3Provider");
};
ni.getProvider = A8;
(function(e) {
  var t = Ze && Ze.__createBinding || (Object.create ? function(s, r, o, u) {
    u === void 0 && (u = o);
    var c = Object.getOwnPropertyDescriptor(r, o);
    (!c || ("get" in c ? !r.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
      return r[o];
    } }), Object.defineProperty(s, u, c);
  } : function(s, r, o, u) {
    u === void 0 && (u = o), s[u] = r[o];
  }), n = Ze && Ze.__exportStar || function(s, r) {
    for (var o in s)
      o !== "default" && !Object.prototype.hasOwnProperty.call(r, o) && t(r, s, o);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.toAscii = e.stripHexPrefix = e.padToEven = e.isHexString = e.isHexPrefixed = e.getKeys = e.getBinarySize = e.fromUtf8 = e.fromAscii = e.arrayContainsArray = void 0, n(Wa, e), n(nf, e), n(Xc, e), n($i, e), n(ff, e), n(ar, e), n(Cn, e), n(Qc, e), n(db, e), n(uf, e);
  var i = kt;
  Object.defineProperty(e, "arrayContainsArray", { enumerable: !0, get: function() {
    return i.arrayContainsArray;
  } }), Object.defineProperty(e, "fromAscii", { enumerable: !0, get: function() {
    return i.fromAscii;
  } }), Object.defineProperty(e, "fromUtf8", { enumerable: !0, get: function() {
    return i.fromUtf8;
  } }), Object.defineProperty(e, "getBinarySize", { enumerable: !0, get: function() {
    return i.getBinarySize;
  } }), Object.defineProperty(e, "getKeys", { enumerable: !0, get: function() {
    return i.getKeys;
  } }), Object.defineProperty(e, "isHexPrefixed", { enumerable: !0, get: function() {
    return i.isHexPrefixed;
  } }), Object.defineProperty(e, "isHexString", { enumerable: !0, get: function() {
    return i.isHexString;
  } }), Object.defineProperty(e, "padToEven", { enumerable: !0, get: function() {
    return i.padToEven;
  } }), Object.defineProperty(e, "stripHexPrefix", { enumerable: !0, get: function() {
    return i.stripHexPrefix;
  } }), Object.defineProperty(e, "toAscii", { enumerable: !0, get: function() {
    return i.toAscii;
  } }), n(cf, e), n(ni, e);
})(qi);
var Vt = {}, kb = function(t) {
  if (typeof t != "string")
    throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof t + ", while checking isHexPrefixed.");
  return t.slice(0, 2) === "0x";
}, M8 = kb, R8 = function(t) {
  return typeof t != "string" ? t : M8(t) ? t.slice(2) : t;
}, B8 = kb, jb = R8;
function yf(e) {
  var t = e;
  if (typeof t != "string")
    throw new Error("[ethjs-util] while padding to even, value must be string, is currently " + typeof t + ", while padToEven.");
  return t.length % 2 && (t = "0" + t), t;
}
function qb(e) {
  var t = e.toString(16);
  return "0x" + t;
}
function I8(e) {
  var t = qb(e);
  return new Buffer(yf(t.slice(2)), "hex");
}
function T8(e) {
  if (typeof e != "string")
    throw new Error("[ethjs-util] while getting binary size, method getBinarySize requires input 'str' to be type String, got '" + typeof e + "'.");
  return Buffer.byteLength(e, "utf8");
}
function O8(e, t, n) {
  if (Array.isArray(e) !== !0)
    throw new Error("[ethjs-util] method arrayContainsArray requires input 'superset' to be an array got type '" + typeof e + "'");
  if (Array.isArray(t) !== !0)
    throw new Error("[ethjs-util] method arrayContainsArray requires input 'subset' to be an array got type '" + typeof t + "'");
  return t[!!n && "some" || "every"](function(i) {
    return e.indexOf(i) >= 0;
  });
}
function P8(e) {
  var t = new Buffer(yf(jb(e).replace(/^0+|0+$/g, "")), "hex");
  return t.toString("utf8");
}
function C8(e) {
  var t = "", n = 0, i = e.length;
  for (e.substring(0, 2) === "0x" && (n = 2); n < i; n += 2) {
    var s = parseInt(e.substr(n, 2), 16);
    t += String.fromCharCode(s);
  }
  return t;
}
function N8(e) {
  var t = new Buffer(e, "utf8");
  return "0x" + yf(t.toString("hex")).replace(/^0+|0+$/g, "");
}
function L8(e) {
  for (var t = "", n = 0; n < e.length; n++) {
    var i = e.charCodeAt(n), s = i.toString(16);
    t += s.length < 2 ? "0" + s : s;
  }
  return "0x" + t;
}
function k8(e, t, n) {
  if (!Array.isArray(e))
    throw new Error("[ethjs-util] method getKeys expecting type Array as 'params' input, got '" + typeof e + "'");
  if (typeof t != "string")
    throw new Error("[ethjs-util] method getKeys expecting type String for input 'key' got '" + typeof t + "'.");
  for (var i = [], s = 0; s < e.length; s++) {
    var r = e[s][t];
    if (n && !r)
      r = "";
    else if (typeof r != "string")
      throw new Error("invalid abi");
    i.push(r);
  }
  return i;
}
function j8(e, t) {
  return !(typeof e != "string" || !e.match(/^0x[0-9A-Fa-f]*$/) || t && e.length !== 2 + 2 * t);
}
var u0 = {
  arrayContainsArray: O8,
  intToBuffer: I8,
  getBinarySize: T8,
  isHexPrefixed: B8,
  stripHexPrefix: jb,
  padToEven: yf,
  intToHex: qb,
  fromAscii: L8,
  fromUtf8: N8,
  toAscii: C8,
  toUtf8: P8,
  getKeys: k8,
  isHexString: j8
};
Object.defineProperty(Vt, "__esModule", { value: !0 });
Vt.numberToBuffer = Vt.normalize = Vt.recoverPublicKey = Vt.concatSig = Vt.legacyToBuffer = Vt.isNullish = Vt.padWithZeroes = void 0;
const Sr = qi, gc = u0;
function mc(e, t) {
  if (e !== "" && !/^[a-f0-9]+$/iu.test(e))
    throw new Error(`Expected an unprefixed hex string. Received: ${e}`);
  if (t < 0)
    throw new Error(`Expected a non-negative integer target length. Received: ${t}`);
  return String.prototype.padStart.call(e, t, "0");
}
Vt.padWithZeroes = mc;
function q8(e) {
  return e == null;
}
Vt.isNullish = q8;
function D8(e) {
  return typeof e == "string" && !(0, gc.isHexString)(e) ? Buffer.from(e) : (0, Sr.toBuffer)(e);
}
Vt.legacyToBuffer = D8;
function $8(e, t, n) {
  const i = (0, Sr.fromSigned)(t), s = (0, Sr.fromSigned)(n), r = (0, Sr.bufferToInt)(e), o = mc((0, Sr.toUnsigned)(i).toString("hex"), 64), u = mc((0, Sr.toUnsigned)(s).toString("hex"), 64), c = (0, gc.stripHexPrefix)((0, gc.intToHex)(r));
  return (0, Sr.addHexPrefix)(o.concat(u, c));
}
Vt.concatSig = $8;
function U8(e, t) {
  const n = (0, Sr.fromRpcSig)(t);
  return (0, Sr.ecrecover)(e, n.v, n.r, n.s);
}
Vt.recoverPublicKey = U8;
function F8(e) {
  if (e) {
    if (typeof e == "number") {
      if (e < 0)
        return "0x";
      const t = (0, Sr.toBuffer)(e);
      e = (0, Sr.bufferToHex)(t);
    }
    if (typeof e != "string") {
      let t = "eth-sig-util.normalize() requires hex string or integer input.";
      throw t += ` received ${typeof e}: ${e}`, new Error(t);
    }
    return (0, Sr.addHexPrefix)(e.toLowerCase());
  }
}
Vt.normalize = F8;
function H8(e) {
  const t = e.toString(16), n = t.length % 2 ? "0" : "";
  return Buffer.from(n + t, "hex");
}
Vt.numberToBuffer = H8;
Object.defineProperty(ln, "__esModule", { value: !0 });
ln.extractPublicKey = ln.recoverPersonalSignature = ln.personalSign = void 0;
const Gn = qi, Gr = Vt;
function z8({ privateKey: e, data: t }) {
  if ((0, Gr.isNullish)(t))
    throw new Error("Missing data parameter");
  if ((0, Gr.isNullish)(e))
    throw new Error("Missing privateKey parameter");
  const n = (0, Gr.legacyToBuffer)(t), i = (0, Gn.hashPersonalMessage)(n), s = (0, Gn.ecsign)(i, e);
  return (0, Gr.concatSig)((0, Gn.toBuffer)(s.v), s.r, s.s);
}
ln.personalSign = z8;
function V8({ data: e, signature: t }) {
  if ((0, Gr.isNullish)(e))
    throw new Error("Missing data parameter");
  if ((0, Gr.isNullish)(t))
    throw new Error("Missing signature parameter");
  const n = Db(e, t), i = (0, Gn.publicToAddress)(n);
  return (0, Gn.bufferToHex)(i);
}
ln.recoverPersonalSignature = V8;
function K8({ data: e, signature: t }) {
  if ((0, Gr.isNullish)(e))
    throw new Error("Missing data parameter");
  if ((0, Gr.isNullish)(t))
    throw new Error("Missing signature parameter");
  return `0x${Db(e, t).toString("hex")}`;
}
ln.extractPublicKey = K8;
function Db(e, t) {
  const n = (0, Gn.hashPersonalMessage)((0, Gr.legacyToBuffer)(e));
  return (0, Gr.recoverPublicKey)(n, t);
}
var $b = {}, dn = {}, c0 = { exports: {} };
c0.exports;
(function(e) {
  (function(t, n) {
    function i(U, y) {
      if (!U)
        throw new Error(y || "Assertion failed");
    }
    function s(U, y) {
      U.super_ = y;
      var p = function() {
      };
      p.prototype = y.prototype, U.prototype = new p(), U.prototype.constructor = U;
    }
    function r(U, y, p) {
      if (r.isBN(U))
        return U;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, U !== null && ((y === "le" || y === "be") && (p = y, y = 10), this._init(U || 0, y || 10, p || "be"));
    }
    typeof t == "object" ? t.exports = r : n.BN = r, r.BN = r, r.wordSize = 26;
    var o;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = dr.Buffer;
    } catch {
    }
    r.isBN = function(y) {
      return y instanceof r ? !0 : y !== null && typeof y == "object" && y.constructor.wordSize === r.wordSize && Array.isArray(y.words);
    }, r.max = function(y, p) {
      return y.cmp(p) > 0 ? y : p;
    }, r.min = function(y, p) {
      return y.cmp(p) < 0 ? y : p;
    }, r.prototype._init = function(y, p, a) {
      if (typeof y == "number")
        return this._initNumber(y, p, a);
      if (typeof y == "object")
        return this._initArray(y, p, a);
      p === "hex" && (p = 16), i(p === (p | 0) && p >= 2 && p <= 36), y = y.toString().replace(/\s+/g, "");
      var l = 0;
      y[0] === "-" && (l++, this.negative = 1), l < y.length && (p === 16 ? this._parseHex(y, l, a) : (this._parseBase(y, p, l), a === "le" && this._initArray(this.toArray(), p, a)));
    }, r.prototype._initNumber = function(y, p, a) {
      y < 0 && (this.negative = 1, y = -y), y < 67108864 ? (this.words = [y & 67108863], this.length = 1) : y < 4503599627370496 ? (this.words = [
        y & 67108863,
        y / 67108864 & 67108863
      ], this.length = 2) : (i(y < 9007199254740992), this.words = [
        y & 67108863,
        y / 67108864 & 67108863,
        1
      ], this.length = 3), a === "le" && this._initArray(this.toArray(), p, a);
    }, r.prototype._initArray = function(y, p, a) {
      if (i(typeof y.length == "number"), y.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(y.length / 3), this.words = new Array(this.length);
      for (var l = 0; l < this.length; l++)
        this.words[l] = 0;
      var _, x, A = 0;
      if (a === "be")
        for (l = y.length - 1, _ = 0; l >= 0; l -= 3)
          x = y[l] | y[l - 1] << 8 | y[l - 2] << 16, this.words[_] |= x << A & 67108863, this.words[_ + 1] = x >>> 26 - A & 67108863, A += 24, A >= 26 && (A -= 26, _++);
      else if (a === "le")
        for (l = 0, _ = 0; l < y.length; l += 3)
          x = y[l] | y[l + 1] << 8 | y[l + 2] << 16, this.words[_] |= x << A & 67108863, this.words[_ + 1] = x >>> 26 - A & 67108863, A += 24, A >= 26 && (A -= 26, _++);
      return this.strip();
    };
    function u(U, y) {
      var p = U.charCodeAt(y);
      return p >= 65 && p <= 70 ? p - 55 : p >= 97 && p <= 102 ? p - 87 : p - 48 & 15;
    }
    function c(U, y, p) {
      var a = u(U, p);
      return p - 1 >= y && (a |= u(U, p - 1) << 4), a;
    }
    r.prototype._parseHex = function(y, p, a) {
      this.length = Math.ceil((y.length - p) / 6), this.words = new Array(this.length);
      for (var l = 0; l < this.length; l++)
        this.words[l] = 0;
      var _ = 0, x = 0, A;
      if (a === "be")
        for (l = y.length - 1; l >= p; l -= 2)
          A = c(y, p, l) << _, this.words[x] |= A & 67108863, _ >= 18 ? (_ -= 18, x += 1, this.words[x] |= A >>> 26) : _ += 8;
      else {
        var S = y.length - p;
        for (l = S % 2 === 0 ? p + 1 : p; l < y.length; l += 2)
          A = c(y, p, l) << _, this.words[x] |= A & 67108863, _ >= 18 ? (_ -= 18, x += 1, this.words[x] |= A >>> 26) : _ += 8;
      }
      this.strip();
    };
    function h(U, y, p, a) {
      for (var l = 0, _ = Math.min(U.length, p), x = y; x < _; x++) {
        var A = U.charCodeAt(x) - 48;
        l *= a, A >= 49 ? l += A - 49 + 10 : A >= 17 ? l += A - 17 + 10 : l += A;
      }
      return l;
    }
    r.prototype._parseBase = function(y, p, a) {
      this.words = [0], this.length = 1;
      for (var l = 0, _ = 1; _ <= 67108863; _ *= p)
        l++;
      l--, _ = _ / p | 0;
      for (var x = y.length - a, A = x % l, S = Math.min(x, x - A) + a, g = 0, w = a; w < S; w += l)
        g = h(y, w, w + l, p), this.imuln(_), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      if (A !== 0) {
        var d = 1;
        for (g = h(y, w, y.length, p), w = 0; w < A; w++)
          d *= p;
        this.imuln(d), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      }
      this.strip();
    }, r.prototype.copy = function(y) {
      y.words = new Array(this.length);
      for (var p = 0; p < this.length; p++)
        y.words[p] = this.words[p];
      y.length = this.length, y.negative = this.negative, y.red = this.red;
    }, r.prototype.clone = function() {
      var y = new r(null);
      return this.copy(y), y;
    }, r.prototype._expand = function(y) {
      for (; this.length < y; )
        this.words[this.length++] = 0;
      return this;
    }, r.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, r.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, r.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var f = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], b = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], v = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    r.prototype.toString = function(y, p) {
      y = y || 10, p = p | 0 || 1;
      var a;
      if (y === 16 || y === "hex") {
        a = "";
        for (var l = 0, _ = 0, x = 0; x < this.length; x++) {
          var A = this.words[x], S = ((A << l | _) & 16777215).toString(16);
          _ = A >>> 24 - l & 16777215, _ !== 0 || x !== this.length - 1 ? a = f[6 - S.length] + S + a : a = S + a, l += 2, l >= 26 && (l -= 26, x--);
        }
        for (_ !== 0 && (a = _.toString(16) + a); a.length % p !== 0; )
          a = "0" + a;
        return this.negative !== 0 && (a = "-" + a), a;
      }
      if (y === (y | 0) && y >= 2 && y <= 36) {
        var g = b[y], w = v[y];
        a = "";
        var d = this.clone();
        for (d.negative = 0; !d.isZero(); ) {
          var R = d.modn(w).toString(y);
          d = d.idivn(w), d.isZero() ? a = R + a : a = f[g - R.length] + R + a;
        }
        for (this.isZero() && (a = "0" + a); a.length % p !== 0; )
          a = "0" + a;
        return this.negative !== 0 && (a = "-" + a), a;
      }
      i(!1, "Base should be between 2 and 36");
    }, r.prototype.toNumber = function() {
      var y = this.words[0];
      return this.length === 2 ? y += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? y += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -y : y;
    }, r.prototype.toJSON = function() {
      return this.toString(16);
    }, r.prototype.toBuffer = function(y, p) {
      return i(typeof o < "u"), this.toArrayLike(o, y, p);
    }, r.prototype.toArray = function(y, p) {
      return this.toArrayLike(Array, y, p);
    }, r.prototype.toArrayLike = function(y, p, a) {
      var l = this.byteLength(), _ = a || Math.max(1, l);
      i(l <= _, "byte array longer than desired length"), i(_ > 0, "Requested array length <= 0"), this.strip();
      var x = p === "le", A = new y(_), S, g, w = this.clone();
      if (x) {
        for (g = 0; !w.isZero(); g++)
          S = w.andln(255), w.iushrn(8), A[g] = S;
        for (; g < _; g++)
          A[g] = 0;
      } else {
        for (g = 0; g < _ - l; g++)
          A[g] = 0;
        for (g = 0; !w.isZero(); g++)
          S = w.andln(255), w.iushrn(8), A[_ - g - 1] = S;
      }
      return A;
    }, Math.clz32 ? r.prototype._countBits = function(y) {
      return 32 - Math.clz32(y);
    } : r.prototype._countBits = function(y) {
      var p = y, a = 0;
      return p >= 4096 && (a += 13, p >>>= 13), p >= 64 && (a += 7, p >>>= 7), p >= 8 && (a += 4, p >>>= 4), p >= 2 && (a += 2, p >>>= 2), a + p;
    }, r.prototype._zeroBits = function(y) {
      if (y === 0)
        return 26;
      var p = y, a = 0;
      return p & 8191 || (a += 13, p >>>= 13), p & 127 || (a += 7, p >>>= 7), p & 15 || (a += 4, p >>>= 4), p & 3 || (a += 2, p >>>= 2), p & 1 || a++, a;
    }, r.prototype.bitLength = function() {
      var y = this.words[this.length - 1], p = this._countBits(y);
      return (this.length - 1) * 26 + p;
    };
    function m(U) {
      for (var y = new Array(U.bitLength()), p = 0; p < y.length; p++) {
        var a = p / 26 | 0, l = p % 26;
        y[p] = (U.words[a] & 1 << l) >>> l;
      }
      return y;
    }
    r.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var y = 0, p = 0; p < this.length; p++) {
        var a = this._zeroBits(this.words[p]);
        if (y += a, a !== 26)
          break;
      }
      return y;
    }, r.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, r.prototype.toTwos = function(y) {
      return this.negative !== 0 ? this.abs().inotn(y).iaddn(1) : this.clone();
    }, r.prototype.fromTwos = function(y) {
      return this.testn(y - 1) ? this.notn(y).iaddn(1).ineg() : this.clone();
    }, r.prototype.isNeg = function() {
      return this.negative !== 0;
    }, r.prototype.neg = function() {
      return this.clone().ineg();
    }, r.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, r.prototype.iuor = function(y) {
      for (; this.length < y.length; )
        this.words[this.length++] = 0;
      for (var p = 0; p < y.length; p++)
        this.words[p] = this.words[p] | y.words[p];
      return this.strip();
    }, r.prototype.ior = function(y) {
      return i((this.negative | y.negative) === 0), this.iuor(y);
    }, r.prototype.or = function(y) {
      return this.length > y.length ? this.clone().ior(y) : y.clone().ior(this);
    }, r.prototype.uor = function(y) {
      return this.length > y.length ? this.clone().iuor(y) : y.clone().iuor(this);
    }, r.prototype.iuand = function(y) {
      var p;
      this.length > y.length ? p = y : p = this;
      for (var a = 0; a < p.length; a++)
        this.words[a] = this.words[a] & y.words[a];
      return this.length = p.length, this.strip();
    }, r.prototype.iand = function(y) {
      return i((this.negative | y.negative) === 0), this.iuand(y);
    }, r.prototype.and = function(y) {
      return this.length > y.length ? this.clone().iand(y) : y.clone().iand(this);
    }, r.prototype.uand = function(y) {
      return this.length > y.length ? this.clone().iuand(y) : y.clone().iuand(this);
    }, r.prototype.iuxor = function(y) {
      var p, a;
      this.length > y.length ? (p = this, a = y) : (p = y, a = this);
      for (var l = 0; l < a.length; l++)
        this.words[l] = p.words[l] ^ a.words[l];
      if (this !== p)
        for (; l < p.length; l++)
          this.words[l] = p.words[l];
      return this.length = p.length, this.strip();
    }, r.prototype.ixor = function(y) {
      return i((this.negative | y.negative) === 0), this.iuxor(y);
    }, r.prototype.xor = function(y) {
      return this.length > y.length ? this.clone().ixor(y) : y.clone().ixor(this);
    }, r.prototype.uxor = function(y) {
      return this.length > y.length ? this.clone().iuxor(y) : y.clone().iuxor(this);
    }, r.prototype.inotn = function(y) {
      i(typeof y == "number" && y >= 0);
      var p = Math.ceil(y / 26) | 0, a = y % 26;
      this._expand(p), a > 0 && p--;
      for (var l = 0; l < p; l++)
        this.words[l] = ~this.words[l] & 67108863;
      return a > 0 && (this.words[l] = ~this.words[l] & 67108863 >> 26 - a), this.strip();
    }, r.prototype.notn = function(y) {
      return this.clone().inotn(y);
    }, r.prototype.setn = function(y, p) {
      i(typeof y == "number" && y >= 0);
      var a = y / 26 | 0, l = y % 26;
      return this._expand(a + 1), p ? this.words[a] = this.words[a] | 1 << l : this.words[a] = this.words[a] & ~(1 << l), this.strip();
    }, r.prototype.iadd = function(y) {
      var p;
      if (this.negative !== 0 && y.negative === 0)
        return this.negative = 0, p = this.isub(y), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && y.negative !== 0)
        return y.negative = 0, p = this.isub(y), y.negative = 1, p._normSign();
      var a, l;
      this.length > y.length ? (a = this, l = y) : (a = y, l = this);
      for (var _ = 0, x = 0; x < l.length; x++)
        p = (a.words[x] | 0) + (l.words[x] | 0) + _, this.words[x] = p & 67108863, _ = p >>> 26;
      for (; _ !== 0 && x < a.length; x++)
        p = (a.words[x] | 0) + _, this.words[x] = p & 67108863, _ = p >>> 26;
      if (this.length = a.length, _ !== 0)
        this.words[this.length] = _, this.length++;
      else if (a !== this)
        for (; x < a.length; x++)
          this.words[x] = a.words[x];
      return this;
    }, r.prototype.add = function(y) {
      var p;
      return y.negative !== 0 && this.negative === 0 ? (y.negative = 0, p = this.sub(y), y.negative ^= 1, p) : y.negative === 0 && this.negative !== 0 ? (this.negative = 0, p = y.sub(this), this.negative = 1, p) : this.length > y.length ? this.clone().iadd(y) : y.clone().iadd(this);
    }, r.prototype.isub = function(y) {
      if (y.negative !== 0) {
        y.negative = 0;
        var p = this.iadd(y);
        return y.negative = 1, p._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(y), this.negative = 1, this._normSign();
      var a = this.cmp(y);
      if (a === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var l, _;
      a > 0 ? (l = this, _ = y) : (l = y, _ = this);
      for (var x = 0, A = 0; A < _.length; A++)
        p = (l.words[A] | 0) - (_.words[A] | 0) + x, x = p >> 26, this.words[A] = p & 67108863;
      for (; x !== 0 && A < l.length; A++)
        p = (l.words[A] | 0) + x, x = p >> 26, this.words[A] = p & 67108863;
      if (x === 0 && A < l.length && l !== this)
        for (; A < l.length; A++)
          this.words[A] = l.words[A];
      return this.length = Math.max(this.length, A), l !== this && (this.negative = 1), this.strip();
    }, r.prototype.sub = function(y) {
      return this.clone().isub(y);
    };
    function E(U, y, p) {
      p.negative = y.negative ^ U.negative;
      var a = U.length + y.length | 0;
      p.length = a, a = a - 1 | 0;
      var l = U.words[0] | 0, _ = y.words[0] | 0, x = l * _, A = x & 67108863, S = x / 67108864 | 0;
      p.words[0] = A;
      for (var g = 1; g < a; g++) {
        for (var w = S >>> 26, d = S & 67108863, R = Math.min(g, y.length - 1), G = Math.max(0, g - U.length + 1); G <= R; G++) {
          var fe = g - G | 0;
          l = U.words[fe] | 0, _ = y.words[G] | 0, x = l * _ + d, w += x / 67108864 | 0, d = x & 67108863;
        }
        p.words[g] = d | 0, S = w | 0;
      }
      return S !== 0 ? p.words[g] = S | 0 : p.length--, p.strip();
    }
    var M = function(y, p, a) {
      var l = y.words, _ = p.words, x = a.words, A = 0, S, g, w, d = l[0] | 0, R = d & 8191, G = d >>> 13, fe = l[1] | 0, z = fe & 8191, V = fe >>> 13, F = l[2] | 0, ee = F & 8191, he = F >>> 13, Z = l[3] | 0, K = Z & 8191, ce = Z >>> 13, ve = l[4] | 0, Be = ve & 8191, Q = ve >>> 13, C = l[5] | 0, L = C & 8191, W = C >>> 13, de = l[6] | 0, me = de & 8191, Te = de >>> 13, Fe = l[7] | 0, H = Fe & 8191, ue = Fe >>> 13, se = l[8] | 0, we = se & 8191, Ce = se >>> 13, ze = l[9] | 0, Le = ze & 8191, Y = ze >>> 13, Se = _[0] | 0, Ae = Se & 8191, je = Se >>> 13, pe = _[1] | 0, Ee = pe & 8191, J = pe >>> 13, Ie = _[2] | 0, ke = Ie & 8191, P = Ie >>> 13, Me = _[3] | 0, be = Me & 8191, ie = Me >>> 13, le = _[4] | 0, ge = le & 8191, Ge = le >>> 13, De = _[5] | 0, Ne = De & 8191, rt = De >>> 13, ft = _[6] | 0, We = ft & 8191, at = ft >>> 13, $ = _[7] | 0, X = $ & 8191, ne = $ >>> 13, O = _[8] | 0, ae = O & 8191, _e = O >>> 13, xe = _[9] | 0, Re = xe & 8191, qe = xe >>> 13;
      a.negative = y.negative ^ p.negative, a.length = 19, S = Math.imul(R, Ae), g = Math.imul(R, je), g = g + Math.imul(G, Ae) | 0, w = Math.imul(G, je);
      var He = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (w + (g >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, S = Math.imul(z, Ae), g = Math.imul(z, je), g = g + Math.imul(V, Ae) | 0, w = Math.imul(V, je), S = S + Math.imul(R, Ee) | 0, g = g + Math.imul(R, J) | 0, g = g + Math.imul(G, Ee) | 0, w = w + Math.imul(G, J) | 0;
      var $e = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (w + (g >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, S = Math.imul(ee, Ae), g = Math.imul(ee, je), g = g + Math.imul(he, Ae) | 0, w = Math.imul(he, je), S = S + Math.imul(z, Ee) | 0, g = g + Math.imul(z, J) | 0, g = g + Math.imul(V, Ee) | 0, w = w + Math.imul(V, J) | 0, S = S + Math.imul(R, ke) | 0, g = g + Math.imul(R, P) | 0, g = g + Math.imul(G, ke) | 0, w = w + Math.imul(G, P) | 0;
      var vt = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (w + (g >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, S = Math.imul(K, Ae), g = Math.imul(K, je), g = g + Math.imul(ce, Ae) | 0, w = Math.imul(ce, je), S = S + Math.imul(ee, Ee) | 0, g = g + Math.imul(ee, J) | 0, g = g + Math.imul(he, Ee) | 0, w = w + Math.imul(he, J) | 0, S = S + Math.imul(z, ke) | 0, g = g + Math.imul(z, P) | 0, g = g + Math.imul(V, ke) | 0, w = w + Math.imul(V, P) | 0, S = S + Math.imul(R, be) | 0, g = g + Math.imul(R, ie) | 0, g = g + Math.imul(G, be) | 0, w = w + Math.imul(G, ie) | 0;
      var Qe = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (w + (g >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, S = Math.imul(Be, Ae), g = Math.imul(Be, je), g = g + Math.imul(Q, Ae) | 0, w = Math.imul(Q, je), S = S + Math.imul(K, Ee) | 0, g = g + Math.imul(K, J) | 0, g = g + Math.imul(ce, Ee) | 0, w = w + Math.imul(ce, J) | 0, S = S + Math.imul(ee, ke) | 0, g = g + Math.imul(ee, P) | 0, g = g + Math.imul(he, ke) | 0, w = w + Math.imul(he, P) | 0, S = S + Math.imul(z, be) | 0, g = g + Math.imul(z, ie) | 0, g = g + Math.imul(V, be) | 0, w = w + Math.imul(V, ie) | 0, S = S + Math.imul(R, ge) | 0, g = g + Math.imul(R, Ge) | 0, g = g + Math.imul(G, ge) | 0, w = w + Math.imul(G, Ge) | 0;
      var ot = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (w + (g >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, S = Math.imul(L, Ae), g = Math.imul(L, je), g = g + Math.imul(W, Ae) | 0, w = Math.imul(W, je), S = S + Math.imul(Be, Ee) | 0, g = g + Math.imul(Be, J) | 0, g = g + Math.imul(Q, Ee) | 0, w = w + Math.imul(Q, J) | 0, S = S + Math.imul(K, ke) | 0, g = g + Math.imul(K, P) | 0, g = g + Math.imul(ce, ke) | 0, w = w + Math.imul(ce, P) | 0, S = S + Math.imul(ee, be) | 0, g = g + Math.imul(ee, ie) | 0, g = g + Math.imul(he, be) | 0, w = w + Math.imul(he, ie) | 0, S = S + Math.imul(z, ge) | 0, g = g + Math.imul(z, Ge) | 0, g = g + Math.imul(V, ge) | 0, w = w + Math.imul(V, Ge) | 0, S = S + Math.imul(R, Ne) | 0, g = g + Math.imul(R, rt) | 0, g = g + Math.imul(G, Ne) | 0, w = w + Math.imul(G, rt) | 0;
      var st = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (w + (g >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, S = Math.imul(me, Ae), g = Math.imul(me, je), g = g + Math.imul(Te, Ae) | 0, w = Math.imul(Te, je), S = S + Math.imul(L, Ee) | 0, g = g + Math.imul(L, J) | 0, g = g + Math.imul(W, Ee) | 0, w = w + Math.imul(W, J) | 0, S = S + Math.imul(Be, ke) | 0, g = g + Math.imul(Be, P) | 0, g = g + Math.imul(Q, ke) | 0, w = w + Math.imul(Q, P) | 0, S = S + Math.imul(K, be) | 0, g = g + Math.imul(K, ie) | 0, g = g + Math.imul(ce, be) | 0, w = w + Math.imul(ce, ie) | 0, S = S + Math.imul(ee, ge) | 0, g = g + Math.imul(ee, Ge) | 0, g = g + Math.imul(he, ge) | 0, w = w + Math.imul(he, Ge) | 0, S = S + Math.imul(z, Ne) | 0, g = g + Math.imul(z, rt) | 0, g = g + Math.imul(V, Ne) | 0, w = w + Math.imul(V, rt) | 0, S = S + Math.imul(R, We) | 0, g = g + Math.imul(R, at) | 0, g = g + Math.imul(G, We) | 0, w = w + Math.imul(G, at) | 0;
      var dt = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (w + (g >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, S = Math.imul(H, Ae), g = Math.imul(H, je), g = g + Math.imul(ue, Ae) | 0, w = Math.imul(ue, je), S = S + Math.imul(me, Ee) | 0, g = g + Math.imul(me, J) | 0, g = g + Math.imul(Te, Ee) | 0, w = w + Math.imul(Te, J) | 0, S = S + Math.imul(L, ke) | 0, g = g + Math.imul(L, P) | 0, g = g + Math.imul(W, ke) | 0, w = w + Math.imul(W, P) | 0, S = S + Math.imul(Be, be) | 0, g = g + Math.imul(Be, ie) | 0, g = g + Math.imul(Q, be) | 0, w = w + Math.imul(Q, ie) | 0, S = S + Math.imul(K, ge) | 0, g = g + Math.imul(K, Ge) | 0, g = g + Math.imul(ce, ge) | 0, w = w + Math.imul(ce, Ge) | 0, S = S + Math.imul(ee, Ne) | 0, g = g + Math.imul(ee, rt) | 0, g = g + Math.imul(he, Ne) | 0, w = w + Math.imul(he, rt) | 0, S = S + Math.imul(z, We) | 0, g = g + Math.imul(z, at) | 0, g = g + Math.imul(V, We) | 0, w = w + Math.imul(V, at) | 0, S = S + Math.imul(R, X) | 0, g = g + Math.imul(R, ne) | 0, g = g + Math.imul(G, X) | 0, w = w + Math.imul(G, ne) | 0;
      var lt = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (w + (g >>> 13) | 0) + (lt >>> 26) | 0, lt &= 67108863, S = Math.imul(we, Ae), g = Math.imul(we, je), g = g + Math.imul(Ce, Ae) | 0, w = Math.imul(Ce, je), S = S + Math.imul(H, Ee) | 0, g = g + Math.imul(H, J) | 0, g = g + Math.imul(ue, Ee) | 0, w = w + Math.imul(ue, J) | 0, S = S + Math.imul(me, ke) | 0, g = g + Math.imul(me, P) | 0, g = g + Math.imul(Te, ke) | 0, w = w + Math.imul(Te, P) | 0, S = S + Math.imul(L, be) | 0, g = g + Math.imul(L, ie) | 0, g = g + Math.imul(W, be) | 0, w = w + Math.imul(W, ie) | 0, S = S + Math.imul(Be, ge) | 0, g = g + Math.imul(Be, Ge) | 0, g = g + Math.imul(Q, ge) | 0, w = w + Math.imul(Q, Ge) | 0, S = S + Math.imul(K, Ne) | 0, g = g + Math.imul(K, rt) | 0, g = g + Math.imul(ce, Ne) | 0, w = w + Math.imul(ce, rt) | 0, S = S + Math.imul(ee, We) | 0, g = g + Math.imul(ee, at) | 0, g = g + Math.imul(he, We) | 0, w = w + Math.imul(he, at) | 0, S = S + Math.imul(z, X) | 0, g = g + Math.imul(z, ne) | 0, g = g + Math.imul(V, X) | 0, w = w + Math.imul(V, ne) | 0, S = S + Math.imul(R, ae) | 0, g = g + Math.imul(R, _e) | 0, g = g + Math.imul(G, ae) | 0, w = w + Math.imul(G, _e) | 0;
      var ut = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (w + (g >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, S = Math.imul(Le, Ae), g = Math.imul(Le, je), g = g + Math.imul(Y, Ae) | 0, w = Math.imul(Y, je), S = S + Math.imul(we, Ee) | 0, g = g + Math.imul(we, J) | 0, g = g + Math.imul(Ce, Ee) | 0, w = w + Math.imul(Ce, J) | 0, S = S + Math.imul(H, ke) | 0, g = g + Math.imul(H, P) | 0, g = g + Math.imul(ue, ke) | 0, w = w + Math.imul(ue, P) | 0, S = S + Math.imul(me, be) | 0, g = g + Math.imul(me, ie) | 0, g = g + Math.imul(Te, be) | 0, w = w + Math.imul(Te, ie) | 0, S = S + Math.imul(L, ge) | 0, g = g + Math.imul(L, Ge) | 0, g = g + Math.imul(W, ge) | 0, w = w + Math.imul(W, Ge) | 0, S = S + Math.imul(Be, Ne) | 0, g = g + Math.imul(Be, rt) | 0, g = g + Math.imul(Q, Ne) | 0, w = w + Math.imul(Q, rt) | 0, S = S + Math.imul(K, We) | 0, g = g + Math.imul(K, at) | 0, g = g + Math.imul(ce, We) | 0, w = w + Math.imul(ce, at) | 0, S = S + Math.imul(ee, X) | 0, g = g + Math.imul(ee, ne) | 0, g = g + Math.imul(he, X) | 0, w = w + Math.imul(he, ne) | 0, S = S + Math.imul(z, ae) | 0, g = g + Math.imul(z, _e) | 0, g = g + Math.imul(V, ae) | 0, w = w + Math.imul(V, _e) | 0, S = S + Math.imul(R, Re) | 0, g = g + Math.imul(R, qe) | 0, g = g + Math.imul(G, Re) | 0, w = w + Math.imul(G, qe) | 0;
      var ht = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (w + (g >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, S = Math.imul(Le, Ee), g = Math.imul(Le, J), g = g + Math.imul(Y, Ee) | 0, w = Math.imul(Y, J), S = S + Math.imul(we, ke) | 0, g = g + Math.imul(we, P) | 0, g = g + Math.imul(Ce, ke) | 0, w = w + Math.imul(Ce, P) | 0, S = S + Math.imul(H, be) | 0, g = g + Math.imul(H, ie) | 0, g = g + Math.imul(ue, be) | 0, w = w + Math.imul(ue, ie) | 0, S = S + Math.imul(me, ge) | 0, g = g + Math.imul(me, Ge) | 0, g = g + Math.imul(Te, ge) | 0, w = w + Math.imul(Te, Ge) | 0, S = S + Math.imul(L, Ne) | 0, g = g + Math.imul(L, rt) | 0, g = g + Math.imul(W, Ne) | 0, w = w + Math.imul(W, rt) | 0, S = S + Math.imul(Be, We) | 0, g = g + Math.imul(Be, at) | 0, g = g + Math.imul(Q, We) | 0, w = w + Math.imul(Q, at) | 0, S = S + Math.imul(K, X) | 0, g = g + Math.imul(K, ne) | 0, g = g + Math.imul(ce, X) | 0, w = w + Math.imul(ce, ne) | 0, S = S + Math.imul(ee, ae) | 0, g = g + Math.imul(ee, _e) | 0, g = g + Math.imul(he, ae) | 0, w = w + Math.imul(he, _e) | 0, S = S + Math.imul(z, Re) | 0, g = g + Math.imul(z, qe) | 0, g = g + Math.imul(V, Re) | 0, w = w + Math.imul(V, qe) | 0;
      var ct = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (w + (g >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, S = Math.imul(Le, ke), g = Math.imul(Le, P), g = g + Math.imul(Y, ke) | 0, w = Math.imul(Y, P), S = S + Math.imul(we, be) | 0, g = g + Math.imul(we, ie) | 0, g = g + Math.imul(Ce, be) | 0, w = w + Math.imul(Ce, ie) | 0, S = S + Math.imul(H, ge) | 0, g = g + Math.imul(H, Ge) | 0, g = g + Math.imul(ue, ge) | 0, w = w + Math.imul(ue, Ge) | 0, S = S + Math.imul(me, Ne) | 0, g = g + Math.imul(me, rt) | 0, g = g + Math.imul(Te, Ne) | 0, w = w + Math.imul(Te, rt) | 0, S = S + Math.imul(L, We) | 0, g = g + Math.imul(L, at) | 0, g = g + Math.imul(W, We) | 0, w = w + Math.imul(W, at) | 0, S = S + Math.imul(Be, X) | 0, g = g + Math.imul(Be, ne) | 0, g = g + Math.imul(Q, X) | 0, w = w + Math.imul(Q, ne) | 0, S = S + Math.imul(K, ae) | 0, g = g + Math.imul(K, _e) | 0, g = g + Math.imul(ce, ae) | 0, w = w + Math.imul(ce, _e) | 0, S = S + Math.imul(ee, Re) | 0, g = g + Math.imul(ee, qe) | 0, g = g + Math.imul(he, Re) | 0, w = w + Math.imul(he, qe) | 0;
      var et = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (w + (g >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, S = Math.imul(Le, be), g = Math.imul(Le, ie), g = g + Math.imul(Y, be) | 0, w = Math.imul(Y, ie), S = S + Math.imul(we, ge) | 0, g = g + Math.imul(we, Ge) | 0, g = g + Math.imul(Ce, ge) | 0, w = w + Math.imul(Ce, Ge) | 0, S = S + Math.imul(H, Ne) | 0, g = g + Math.imul(H, rt) | 0, g = g + Math.imul(ue, Ne) | 0, w = w + Math.imul(ue, rt) | 0, S = S + Math.imul(me, We) | 0, g = g + Math.imul(me, at) | 0, g = g + Math.imul(Te, We) | 0, w = w + Math.imul(Te, at) | 0, S = S + Math.imul(L, X) | 0, g = g + Math.imul(L, ne) | 0, g = g + Math.imul(W, X) | 0, w = w + Math.imul(W, ne) | 0, S = S + Math.imul(Be, ae) | 0, g = g + Math.imul(Be, _e) | 0, g = g + Math.imul(Q, ae) | 0, w = w + Math.imul(Q, _e) | 0, S = S + Math.imul(K, Re) | 0, g = g + Math.imul(K, qe) | 0, g = g + Math.imul(ce, Re) | 0, w = w + Math.imul(ce, qe) | 0;
      var it = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (w + (g >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, S = Math.imul(Le, ge), g = Math.imul(Le, Ge), g = g + Math.imul(Y, ge) | 0, w = Math.imul(Y, Ge), S = S + Math.imul(we, Ne) | 0, g = g + Math.imul(we, rt) | 0, g = g + Math.imul(Ce, Ne) | 0, w = w + Math.imul(Ce, rt) | 0, S = S + Math.imul(H, We) | 0, g = g + Math.imul(H, at) | 0, g = g + Math.imul(ue, We) | 0, w = w + Math.imul(ue, at) | 0, S = S + Math.imul(me, X) | 0, g = g + Math.imul(me, ne) | 0, g = g + Math.imul(Te, X) | 0, w = w + Math.imul(Te, ne) | 0, S = S + Math.imul(L, ae) | 0, g = g + Math.imul(L, _e) | 0, g = g + Math.imul(W, ae) | 0, w = w + Math.imul(W, _e) | 0, S = S + Math.imul(Be, Re) | 0, g = g + Math.imul(Be, qe) | 0, g = g + Math.imul(Q, Re) | 0, w = w + Math.imul(Q, qe) | 0;
      var Ye = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (w + (g >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, S = Math.imul(Le, Ne), g = Math.imul(Le, rt), g = g + Math.imul(Y, Ne) | 0, w = Math.imul(Y, rt), S = S + Math.imul(we, We) | 0, g = g + Math.imul(we, at) | 0, g = g + Math.imul(Ce, We) | 0, w = w + Math.imul(Ce, at) | 0, S = S + Math.imul(H, X) | 0, g = g + Math.imul(H, ne) | 0, g = g + Math.imul(ue, X) | 0, w = w + Math.imul(ue, ne) | 0, S = S + Math.imul(me, ae) | 0, g = g + Math.imul(me, _e) | 0, g = g + Math.imul(Te, ae) | 0, w = w + Math.imul(Te, _e) | 0, S = S + Math.imul(L, Re) | 0, g = g + Math.imul(L, qe) | 0, g = g + Math.imul(W, Re) | 0, w = w + Math.imul(W, qe) | 0;
      var tt = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (w + (g >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, S = Math.imul(Le, We), g = Math.imul(Le, at), g = g + Math.imul(Y, We) | 0, w = Math.imul(Y, at), S = S + Math.imul(we, X) | 0, g = g + Math.imul(we, ne) | 0, g = g + Math.imul(Ce, X) | 0, w = w + Math.imul(Ce, ne) | 0, S = S + Math.imul(H, ae) | 0, g = g + Math.imul(H, _e) | 0, g = g + Math.imul(ue, ae) | 0, w = w + Math.imul(ue, _e) | 0, S = S + Math.imul(me, Re) | 0, g = g + Math.imul(me, qe) | 0, g = g + Math.imul(Te, Re) | 0, w = w + Math.imul(Te, qe) | 0;
      var nt = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (w + (g >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, S = Math.imul(Le, X), g = Math.imul(Le, ne), g = g + Math.imul(Y, X) | 0, w = Math.imul(Y, ne), S = S + Math.imul(we, ae) | 0, g = g + Math.imul(we, _e) | 0, g = g + Math.imul(Ce, ae) | 0, w = w + Math.imul(Ce, _e) | 0, S = S + Math.imul(H, Re) | 0, g = g + Math.imul(H, qe) | 0, g = g + Math.imul(ue, Re) | 0, w = w + Math.imul(ue, qe) | 0;
      var Xe = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (w + (g >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, S = Math.imul(Le, ae), g = Math.imul(Le, _e), g = g + Math.imul(Y, ae) | 0, w = Math.imul(Y, _e), S = S + Math.imul(we, Re) | 0, g = g + Math.imul(we, qe) | 0, g = g + Math.imul(Ce, Re) | 0, w = w + Math.imul(Ce, qe) | 0;
      var Oe = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (w + (g >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, S = Math.imul(Le, Re), g = Math.imul(Le, qe), g = g + Math.imul(Y, Re) | 0, w = Math.imul(Y, qe);
      var Pe = (A + S | 0) + ((g & 8191) << 13) | 0;
      return A = (w + (g >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, x[0] = He, x[1] = $e, x[2] = vt, x[3] = Qe, x[4] = ot, x[5] = st, x[6] = dt, x[7] = lt, x[8] = ut, x[9] = ht, x[10] = ct, x[11] = et, x[12] = it, x[13] = Ye, x[14] = tt, x[15] = nt, x[16] = Xe, x[17] = Oe, x[18] = Pe, A !== 0 && (x[19] = A, a.length++), a;
    };
    Math.imul || (M = E);
    function B(U, y, p) {
      p.negative = y.negative ^ U.negative, p.length = U.length + y.length;
      for (var a = 0, l = 0, _ = 0; _ < p.length - 1; _++) {
        var x = l;
        l = 0;
        for (var A = a & 67108863, S = Math.min(_, y.length - 1), g = Math.max(0, _ - U.length + 1); g <= S; g++) {
          var w = _ - g, d = U.words[w] | 0, R = y.words[g] | 0, G = d * R, fe = G & 67108863;
          x = x + (G / 67108864 | 0) | 0, fe = fe + A | 0, A = fe & 67108863, x = x + (fe >>> 26) | 0, l += x >>> 26, x &= 67108863;
        }
        p.words[_] = A, a = x, x = l;
      }
      return a !== 0 ? p.words[_] = a : p.length--, p.strip();
    }
    function I(U, y, p) {
      var a = new T();
      return a.mulp(U, y, p);
    }
    r.prototype.mulTo = function(y, p) {
      var a, l = this.length + y.length;
      return this.length === 10 && y.length === 10 ? a = M(this, y, p) : l < 63 ? a = E(this, y, p) : l < 1024 ? a = B(this, y, p) : a = I(this, y, p), a;
    };
    function T(U, y) {
      this.x = U, this.y = y;
    }
    T.prototype.makeRBT = function(y) {
      for (var p = new Array(y), a = r.prototype._countBits(y) - 1, l = 0; l < y; l++)
        p[l] = this.revBin(l, a, y);
      return p;
    }, T.prototype.revBin = function(y, p, a) {
      if (y === 0 || y === a - 1)
        return y;
      for (var l = 0, _ = 0; _ < p; _++)
        l |= (y & 1) << p - _ - 1, y >>= 1;
      return l;
    }, T.prototype.permute = function(y, p, a, l, _, x) {
      for (var A = 0; A < x; A++)
        l[A] = p[y[A]], _[A] = a[y[A]];
    }, T.prototype.transform = function(y, p, a, l, _, x) {
      this.permute(x, y, p, a, l, _);
      for (var A = 1; A < _; A <<= 1)
        for (var S = A << 1, g = Math.cos(2 * Math.PI / S), w = Math.sin(2 * Math.PI / S), d = 0; d < _; d += S)
          for (var R = g, G = w, fe = 0; fe < A; fe++) {
            var z = a[d + fe], V = l[d + fe], F = a[d + fe + A], ee = l[d + fe + A], he = R * F - G * ee;
            ee = R * ee + G * F, F = he, a[d + fe] = z + F, l[d + fe] = V + ee, a[d + fe + A] = z - F, l[d + fe + A] = V - ee, fe !== S && (he = g * R - w * G, G = g * G + w * R, R = he);
          }
    }, T.prototype.guessLen13b = function(y, p) {
      var a = Math.max(p, y) | 1, l = a & 1, _ = 0;
      for (a = a / 2 | 0; a; a = a >>> 1)
        _++;
      return 1 << _ + 1 + l;
    }, T.prototype.conjugate = function(y, p, a) {
      if (!(a <= 1))
        for (var l = 0; l < a / 2; l++) {
          var _ = y[l];
          y[l] = y[a - l - 1], y[a - l - 1] = _, _ = p[l], p[l] = -p[a - l - 1], p[a - l - 1] = -_;
        }
    }, T.prototype.normalize13b = function(y, p) {
      for (var a = 0, l = 0; l < p / 2; l++) {
        var _ = Math.round(y[2 * l + 1] / p) * 8192 + Math.round(y[2 * l] / p) + a;
        y[l] = _ & 67108863, _ < 67108864 ? a = 0 : a = _ / 67108864 | 0;
      }
      return y;
    }, T.prototype.convert13b = function(y, p, a, l) {
      for (var _ = 0, x = 0; x < p; x++)
        _ = _ + (y[x] | 0), a[2 * x] = _ & 8191, _ = _ >>> 13, a[2 * x + 1] = _ & 8191, _ = _ >>> 13;
      for (x = 2 * p; x < l; ++x)
        a[x] = 0;
      i(_ === 0), i((_ & -8192) === 0);
    }, T.prototype.stub = function(y) {
      for (var p = new Array(y), a = 0; a < y; a++)
        p[a] = 0;
      return p;
    }, T.prototype.mulp = function(y, p, a) {
      var l = 2 * this.guessLen13b(y.length, p.length), _ = this.makeRBT(l), x = this.stub(l), A = new Array(l), S = new Array(l), g = new Array(l), w = new Array(l), d = new Array(l), R = new Array(l), G = a.words;
      G.length = l, this.convert13b(y.words, y.length, A, l), this.convert13b(p.words, p.length, w, l), this.transform(A, x, S, g, l, _), this.transform(w, x, d, R, l, _);
      for (var fe = 0; fe < l; fe++) {
        var z = S[fe] * d[fe] - g[fe] * R[fe];
        g[fe] = S[fe] * R[fe] + g[fe] * d[fe], S[fe] = z;
      }
      return this.conjugate(S, g, l), this.transform(S, g, G, x, l, _), this.conjugate(G, x, l), this.normalize13b(G, l), a.negative = y.negative ^ p.negative, a.length = y.length + p.length, a.strip();
    }, r.prototype.mul = function(y) {
      var p = new r(null);
      return p.words = new Array(this.length + y.length), this.mulTo(y, p);
    }, r.prototype.mulf = function(y) {
      var p = new r(null);
      return p.words = new Array(this.length + y.length), I(this, y, p);
    }, r.prototype.imul = function(y) {
      return this.clone().mulTo(y, this);
    }, r.prototype.imuln = function(y) {
      i(typeof y == "number"), i(y < 67108864);
      for (var p = 0, a = 0; a < this.length; a++) {
        var l = (this.words[a] | 0) * y, _ = (l & 67108863) + (p & 67108863);
        p >>= 26, p += l / 67108864 | 0, p += _ >>> 26, this.words[a] = _ & 67108863;
      }
      return p !== 0 && (this.words[a] = p, this.length++), this;
    }, r.prototype.muln = function(y) {
      return this.clone().imuln(y);
    }, r.prototype.sqr = function() {
      return this.mul(this);
    }, r.prototype.isqr = function() {
      return this.imul(this.clone());
    }, r.prototype.pow = function(y) {
      var p = m(y);
      if (p.length === 0)
        return new r(1);
      for (var a = this, l = 0; l < p.length && p[l] === 0; l++, a = a.sqr())
        ;
      if (++l < p.length)
        for (var _ = a.sqr(); l < p.length; l++, _ = _.sqr())
          p[l] !== 0 && (a = a.mul(_));
      return a;
    }, r.prototype.iushln = function(y) {
      i(typeof y == "number" && y >= 0);
      var p = y % 26, a = (y - p) / 26, l = 67108863 >>> 26 - p << 26 - p, _;
      if (p !== 0) {
        var x = 0;
        for (_ = 0; _ < this.length; _++) {
          var A = this.words[_] & l, S = (this.words[_] | 0) - A << p;
          this.words[_] = S | x, x = A >>> 26 - p;
        }
        x && (this.words[_] = x, this.length++);
      }
      if (a !== 0) {
        for (_ = this.length - 1; _ >= 0; _--)
          this.words[_ + a] = this.words[_];
        for (_ = 0; _ < a; _++)
          this.words[_] = 0;
        this.length += a;
      }
      return this.strip();
    }, r.prototype.ishln = function(y) {
      return i(this.negative === 0), this.iushln(y);
    }, r.prototype.iushrn = function(y, p, a) {
      i(typeof y == "number" && y >= 0);
      var l;
      p ? l = (p - p % 26) / 26 : l = 0;
      var _ = y % 26, x = Math.min((y - _) / 26, this.length), A = 67108863 ^ 67108863 >>> _ << _, S = a;
      if (l -= x, l = Math.max(0, l), S) {
        for (var g = 0; g < x; g++)
          S.words[g] = this.words[g];
        S.length = x;
      }
      if (x !== 0)
        if (this.length > x)
          for (this.length -= x, g = 0; g < this.length; g++)
            this.words[g] = this.words[g + x];
        else
          this.words[0] = 0, this.length = 1;
      var w = 0;
      for (g = this.length - 1; g >= 0 && (w !== 0 || g >= l); g--) {
        var d = this.words[g] | 0;
        this.words[g] = w << 26 - _ | d >>> _, w = d & A;
      }
      return S && w !== 0 && (S.words[S.length++] = w), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, r.prototype.ishrn = function(y, p, a) {
      return i(this.negative === 0), this.iushrn(y, p, a);
    }, r.prototype.shln = function(y) {
      return this.clone().ishln(y);
    }, r.prototype.ushln = function(y) {
      return this.clone().iushln(y);
    }, r.prototype.shrn = function(y) {
      return this.clone().ishrn(y);
    }, r.prototype.ushrn = function(y) {
      return this.clone().iushrn(y);
    }, r.prototype.testn = function(y) {
      i(typeof y == "number" && y >= 0);
      var p = y % 26, a = (y - p) / 26, l = 1 << p;
      if (this.length <= a)
        return !1;
      var _ = this.words[a];
      return !!(_ & l);
    }, r.prototype.imaskn = function(y) {
      i(typeof y == "number" && y >= 0);
      var p = y % 26, a = (y - p) / 26;
      if (i(this.negative === 0, "imaskn works only with positive numbers"), this.length <= a)
        return this;
      if (p !== 0 && a++, this.length = Math.min(a, this.length), p !== 0) {
        var l = 67108863 ^ 67108863 >>> p << p;
        this.words[this.length - 1] &= l;
      }
      return this.strip();
    }, r.prototype.maskn = function(y) {
      return this.clone().imaskn(y);
    }, r.prototype.iaddn = function(y) {
      return i(typeof y == "number"), i(y < 67108864), y < 0 ? this.isubn(-y) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < y ? (this.words[0] = y - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(y), this.negative = 1, this) : this._iaddn(y);
    }, r.prototype._iaddn = function(y) {
      this.words[0] += y;
      for (var p = 0; p < this.length && this.words[p] >= 67108864; p++)
        this.words[p] -= 67108864, p === this.length - 1 ? this.words[p + 1] = 1 : this.words[p + 1]++;
      return this.length = Math.max(this.length, p + 1), this;
    }, r.prototype.isubn = function(y) {
      if (i(typeof y == "number"), i(y < 67108864), y < 0)
        return this.iaddn(-y);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(y), this.negative = 1, this;
      if (this.words[0] -= y, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var p = 0; p < this.length && this.words[p] < 0; p++)
          this.words[p] += 67108864, this.words[p + 1] -= 1;
      return this.strip();
    }, r.prototype.addn = function(y) {
      return this.clone().iaddn(y);
    }, r.prototype.subn = function(y) {
      return this.clone().isubn(y);
    }, r.prototype.iabs = function() {
      return this.negative = 0, this;
    }, r.prototype.abs = function() {
      return this.clone().iabs();
    }, r.prototype._ishlnsubmul = function(y, p, a) {
      var l = y.length + a, _;
      this._expand(l);
      var x, A = 0;
      for (_ = 0; _ < y.length; _++) {
        x = (this.words[_ + a] | 0) + A;
        var S = (y.words[_] | 0) * p;
        x -= S & 67108863, A = (x >> 26) - (S / 67108864 | 0), this.words[_ + a] = x & 67108863;
      }
      for (; _ < this.length - a; _++)
        x = (this.words[_ + a] | 0) + A, A = x >> 26, this.words[_ + a] = x & 67108863;
      if (A === 0)
        return this.strip();
      for (i(A === -1), A = 0, _ = 0; _ < this.length; _++)
        x = -(this.words[_] | 0) + A, A = x >> 26, this.words[_] = x & 67108863;
      return this.negative = 1, this.strip();
    }, r.prototype._wordDiv = function(y, p) {
      var a = this.length - y.length, l = this.clone(), _ = y, x = _.words[_.length - 1] | 0, A = this._countBits(x);
      a = 26 - A, a !== 0 && (_ = _.ushln(a), l.iushln(a), x = _.words[_.length - 1] | 0);
      var S = l.length - _.length, g;
      if (p !== "mod") {
        g = new r(null), g.length = S + 1, g.words = new Array(g.length);
        for (var w = 0; w < g.length; w++)
          g.words[w] = 0;
      }
      var d = l.clone()._ishlnsubmul(_, 1, S);
      d.negative === 0 && (l = d, g && (g.words[S] = 1));
      for (var R = S - 1; R >= 0; R--) {
        var G = (l.words[_.length + R] | 0) * 67108864 + (l.words[_.length + R - 1] | 0);
        for (G = Math.min(G / x | 0, 67108863), l._ishlnsubmul(_, G, R); l.negative !== 0; )
          G--, l.negative = 0, l._ishlnsubmul(_, 1, R), l.isZero() || (l.negative ^= 1);
        g && (g.words[R] = G);
      }
      return g && g.strip(), l.strip(), p !== "div" && a !== 0 && l.iushrn(a), {
        div: g || null,
        mod: l
      };
    }, r.prototype.divmod = function(y, p, a) {
      if (i(!y.isZero()), this.isZero())
        return {
          div: new r(0),
          mod: new r(0)
        };
      var l, _, x;
      return this.negative !== 0 && y.negative === 0 ? (x = this.neg().divmod(y, p), p !== "mod" && (l = x.div.neg()), p !== "div" && (_ = x.mod.neg(), a && _.negative !== 0 && _.iadd(y)), {
        div: l,
        mod: _
      }) : this.negative === 0 && y.negative !== 0 ? (x = this.divmod(y.neg(), p), p !== "mod" && (l = x.div.neg()), {
        div: l,
        mod: x.mod
      }) : this.negative & y.negative ? (x = this.neg().divmod(y.neg(), p), p !== "div" && (_ = x.mod.neg(), a && _.negative !== 0 && _.isub(y)), {
        div: x.div,
        mod: _
      }) : y.length > this.length || this.cmp(y) < 0 ? {
        div: new r(0),
        mod: this
      } : y.length === 1 ? p === "div" ? {
        div: this.divn(y.words[0]),
        mod: null
      } : p === "mod" ? {
        div: null,
        mod: new r(this.modn(y.words[0]))
      } : {
        div: this.divn(y.words[0]),
        mod: new r(this.modn(y.words[0]))
      } : this._wordDiv(y, p);
    }, r.prototype.div = function(y) {
      return this.divmod(y, "div", !1).div;
    }, r.prototype.mod = function(y) {
      return this.divmod(y, "mod", !1).mod;
    }, r.prototype.umod = function(y) {
      return this.divmod(y, "mod", !0).mod;
    }, r.prototype.divRound = function(y) {
      var p = this.divmod(y);
      if (p.mod.isZero())
        return p.div;
      var a = p.div.negative !== 0 ? p.mod.isub(y) : p.mod, l = y.ushrn(1), _ = y.andln(1), x = a.cmp(l);
      return x < 0 || _ === 1 && x === 0 ? p.div : p.div.negative !== 0 ? p.div.isubn(1) : p.div.iaddn(1);
    }, r.prototype.modn = function(y) {
      i(y <= 67108863);
      for (var p = (1 << 26) % y, a = 0, l = this.length - 1; l >= 0; l--)
        a = (p * a + (this.words[l] | 0)) % y;
      return a;
    }, r.prototype.idivn = function(y) {
      i(y <= 67108863);
      for (var p = 0, a = this.length - 1; a >= 0; a--) {
        var l = (this.words[a] | 0) + p * 67108864;
        this.words[a] = l / y | 0, p = l % y;
      }
      return this.strip();
    }, r.prototype.divn = function(y) {
      return this.clone().idivn(y);
    }, r.prototype.egcd = function(y) {
      i(y.negative === 0), i(!y.isZero());
      var p = this, a = y.clone();
      p.negative !== 0 ? p = p.umod(y) : p = p.clone();
      for (var l = new r(1), _ = new r(0), x = new r(0), A = new r(1), S = 0; p.isEven() && a.isEven(); )
        p.iushrn(1), a.iushrn(1), ++S;
      for (var g = a.clone(), w = p.clone(); !p.isZero(); ) {
        for (var d = 0, R = 1; !(p.words[0] & R) && d < 26; ++d, R <<= 1)
          ;
        if (d > 0)
          for (p.iushrn(d); d-- > 0; )
            (l.isOdd() || _.isOdd()) && (l.iadd(g), _.isub(w)), l.iushrn(1), _.iushrn(1);
        for (var G = 0, fe = 1; !(a.words[0] & fe) && G < 26; ++G, fe <<= 1)
          ;
        if (G > 0)
          for (a.iushrn(G); G-- > 0; )
            (x.isOdd() || A.isOdd()) && (x.iadd(g), A.isub(w)), x.iushrn(1), A.iushrn(1);
        p.cmp(a) >= 0 ? (p.isub(a), l.isub(x), _.isub(A)) : (a.isub(p), x.isub(l), A.isub(_));
      }
      return {
        a: x,
        b: A,
        gcd: a.iushln(S)
      };
    }, r.prototype._invmp = function(y) {
      i(y.negative === 0), i(!y.isZero());
      var p = this, a = y.clone();
      p.negative !== 0 ? p = p.umod(y) : p = p.clone();
      for (var l = new r(1), _ = new r(0), x = a.clone(); p.cmpn(1) > 0 && a.cmpn(1) > 0; ) {
        for (var A = 0, S = 1; !(p.words[0] & S) && A < 26; ++A, S <<= 1)
          ;
        if (A > 0)
          for (p.iushrn(A); A-- > 0; )
            l.isOdd() && l.iadd(x), l.iushrn(1);
        for (var g = 0, w = 1; !(a.words[0] & w) && g < 26; ++g, w <<= 1)
          ;
        if (g > 0)
          for (a.iushrn(g); g-- > 0; )
            _.isOdd() && _.iadd(x), _.iushrn(1);
        p.cmp(a) >= 0 ? (p.isub(a), l.isub(_)) : (a.isub(p), _.isub(l));
      }
      var d;
      return p.cmpn(1) === 0 ? d = l : d = _, d.cmpn(0) < 0 && d.iadd(y), d;
    }, r.prototype.gcd = function(y) {
      if (this.isZero())
        return y.abs();
      if (y.isZero())
        return this.abs();
      var p = this.clone(), a = y.clone();
      p.negative = 0, a.negative = 0;
      for (var l = 0; p.isEven() && a.isEven(); l++)
        p.iushrn(1), a.iushrn(1);
      do {
        for (; p.isEven(); )
          p.iushrn(1);
        for (; a.isEven(); )
          a.iushrn(1);
        var _ = p.cmp(a);
        if (_ < 0) {
          var x = p;
          p = a, a = x;
        } else if (_ === 0 || a.cmpn(1) === 0)
          break;
        p.isub(a);
      } while (!0);
      return a.iushln(l);
    }, r.prototype.invm = function(y) {
      return this.egcd(y).a.umod(y);
    }, r.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, r.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, r.prototype.andln = function(y) {
      return this.words[0] & y;
    }, r.prototype.bincn = function(y) {
      i(typeof y == "number");
      var p = y % 26, a = (y - p) / 26, l = 1 << p;
      if (this.length <= a)
        return this._expand(a + 1), this.words[a] |= l, this;
      for (var _ = l, x = a; _ !== 0 && x < this.length; x++) {
        var A = this.words[x] | 0;
        A += _, _ = A >>> 26, A &= 67108863, this.words[x] = A;
      }
      return _ !== 0 && (this.words[x] = _, this.length++), this;
    }, r.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, r.prototype.cmpn = function(y) {
      var p = y < 0;
      if (this.negative !== 0 && !p)
        return -1;
      if (this.negative === 0 && p)
        return 1;
      this.strip();
      var a;
      if (this.length > 1)
        a = 1;
      else {
        p && (y = -y), i(y <= 67108863, "Number is too big");
        var l = this.words[0] | 0;
        a = l === y ? 0 : l < y ? -1 : 1;
      }
      return this.negative !== 0 ? -a | 0 : a;
    }, r.prototype.cmp = function(y) {
      if (this.negative !== 0 && y.negative === 0)
        return -1;
      if (this.negative === 0 && y.negative !== 0)
        return 1;
      var p = this.ucmp(y);
      return this.negative !== 0 ? -p | 0 : p;
    }, r.prototype.ucmp = function(y) {
      if (this.length > y.length)
        return 1;
      if (this.length < y.length)
        return -1;
      for (var p = 0, a = this.length - 1; a >= 0; a--) {
        var l = this.words[a] | 0, _ = y.words[a] | 0;
        if (l !== _) {
          l < _ ? p = -1 : l > _ && (p = 1);
          break;
        }
      }
      return p;
    }, r.prototype.gtn = function(y) {
      return this.cmpn(y) === 1;
    }, r.prototype.gt = function(y) {
      return this.cmp(y) === 1;
    }, r.prototype.gten = function(y) {
      return this.cmpn(y) >= 0;
    }, r.prototype.gte = function(y) {
      return this.cmp(y) >= 0;
    }, r.prototype.ltn = function(y) {
      return this.cmpn(y) === -1;
    }, r.prototype.lt = function(y) {
      return this.cmp(y) === -1;
    }, r.prototype.lten = function(y) {
      return this.cmpn(y) <= 0;
    }, r.prototype.lte = function(y) {
      return this.cmp(y) <= 0;
    }, r.prototype.eqn = function(y) {
      return this.cmpn(y) === 0;
    }, r.prototype.eq = function(y) {
      return this.cmp(y) === 0;
    }, r.red = function(y) {
      return new te(y);
    }, r.prototype.toRed = function(y) {
      return i(!this.red, "Already a number in reduction context"), i(this.negative === 0, "red works only with positives"), y.convertTo(this)._forceRed(y);
    }, r.prototype.fromRed = function() {
      return i(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, r.prototype._forceRed = function(y) {
      return this.red = y, this;
    }, r.prototype.forceRed = function(y) {
      return i(!this.red, "Already a number in reduction context"), this._forceRed(y);
    }, r.prototype.redAdd = function(y) {
      return i(this.red, "redAdd works only with red numbers"), this.red.add(this, y);
    }, r.prototype.redIAdd = function(y) {
      return i(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, y);
    }, r.prototype.redSub = function(y) {
      return i(this.red, "redSub works only with red numbers"), this.red.sub(this, y);
    }, r.prototype.redISub = function(y) {
      return i(this.red, "redISub works only with red numbers"), this.red.isub(this, y);
    }, r.prototype.redShl = function(y) {
      return i(this.red, "redShl works only with red numbers"), this.red.shl(this, y);
    }, r.prototype.redMul = function(y) {
      return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, y), this.red.mul(this, y);
    }, r.prototype.redIMul = function(y) {
      return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, y), this.red.imul(this, y);
    }, r.prototype.redSqr = function() {
      return i(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, r.prototype.redISqr = function() {
      return i(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, r.prototype.redSqrt = function() {
      return i(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, r.prototype.redInvm = function() {
      return i(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, r.prototype.redNeg = function() {
      return i(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, r.prototype.redPow = function(y) {
      return i(this.red && !y.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, y);
    };
    var k = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function j(U, y) {
      this.name = U, this.p = new r(y, 16), this.n = this.p.bitLength(), this.k = new r(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    j.prototype._tmp = function() {
      var y = new r(null);
      return y.words = new Array(Math.ceil(this.n / 13)), y;
    }, j.prototype.ireduce = function(y) {
      var p = y, a;
      do
        this.split(p, this.tmp), p = this.imulK(p), p = p.iadd(this.tmp), a = p.bitLength();
      while (a > this.n);
      var l = a < this.n ? -1 : p.ucmp(this.p);
      return l === 0 ? (p.words[0] = 0, p.length = 1) : l > 0 ? p.isub(this.p) : p.strip !== void 0 ? p.strip() : p._strip(), p;
    }, j.prototype.split = function(y, p) {
      y.iushrn(this.n, 0, p);
    }, j.prototype.imulK = function(y) {
      return y.imul(this.k);
    };
    function N() {
      j.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    s(N, j), N.prototype.split = function(y, p) {
      for (var a = 4194303, l = Math.min(y.length, 9), _ = 0; _ < l; _++)
        p.words[_] = y.words[_];
      if (p.length = l, y.length <= 9) {
        y.words[0] = 0, y.length = 1;
        return;
      }
      var x = y.words[9];
      for (p.words[p.length++] = x & a, _ = 10; _ < y.length; _++) {
        var A = y.words[_] | 0;
        y.words[_ - 10] = (A & a) << 4 | x >>> 22, x = A;
      }
      x >>>= 22, y.words[_ - 10] = x, x === 0 && y.length > 10 ? y.length -= 10 : y.length -= 9;
    }, N.prototype.imulK = function(y) {
      y.words[y.length] = 0, y.words[y.length + 1] = 0, y.length += 2;
      for (var p = 0, a = 0; a < y.length; a++) {
        var l = y.words[a] | 0;
        p += l * 977, y.words[a] = p & 67108863, p = l * 64 + (p / 67108864 | 0);
      }
      return y.words[y.length - 1] === 0 && (y.length--, y.words[y.length - 1] === 0 && y.length--), y;
    };
    function q() {
      j.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    s(q, j);
    function D() {
      j.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    s(D, j);
    function re() {
      j.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    s(re, j), re.prototype.imulK = function(y) {
      for (var p = 0, a = 0; a < y.length; a++) {
        var l = (y.words[a] | 0) * 19 + p, _ = l & 67108863;
        l >>>= 26, y.words[a] = _, p = l;
      }
      return p !== 0 && (y.words[y.length++] = p), y;
    }, r._prime = function(y) {
      if (k[y])
        return k[y];
      var p;
      if (y === "k256")
        p = new N();
      else if (y === "p224")
        p = new q();
      else if (y === "p192")
        p = new D();
      else if (y === "p25519")
        p = new re();
      else
        throw new Error("Unknown prime " + y);
      return k[y] = p, p;
    };
    function te(U) {
      if (typeof U == "string") {
        var y = r._prime(U);
        this.m = y.p, this.prime = y;
      } else
        i(U.gtn(1), "modulus must be greater than 1"), this.m = U, this.prime = null;
    }
    te.prototype._verify1 = function(y) {
      i(y.negative === 0, "red works only with positives"), i(y.red, "red works only with red numbers");
    }, te.prototype._verify2 = function(y, p) {
      i((y.negative | p.negative) === 0, "red works only with positives"), i(
        y.red && y.red === p.red,
        "red works only with red numbers"
      );
    }, te.prototype.imod = function(y) {
      return this.prime ? this.prime.ireduce(y)._forceRed(this) : y.umod(this.m)._forceRed(this);
    }, te.prototype.neg = function(y) {
      return y.isZero() ? y.clone() : this.m.sub(y)._forceRed(this);
    }, te.prototype.add = function(y, p) {
      this._verify2(y, p);
      var a = y.add(p);
      return a.cmp(this.m) >= 0 && a.isub(this.m), a._forceRed(this);
    }, te.prototype.iadd = function(y, p) {
      this._verify2(y, p);
      var a = y.iadd(p);
      return a.cmp(this.m) >= 0 && a.isub(this.m), a;
    }, te.prototype.sub = function(y, p) {
      this._verify2(y, p);
      var a = y.sub(p);
      return a.cmpn(0) < 0 && a.iadd(this.m), a._forceRed(this);
    }, te.prototype.isub = function(y, p) {
      this._verify2(y, p);
      var a = y.isub(p);
      return a.cmpn(0) < 0 && a.iadd(this.m), a;
    }, te.prototype.shl = function(y, p) {
      return this._verify1(y), this.imod(y.ushln(p));
    }, te.prototype.imul = function(y, p) {
      return this._verify2(y, p), this.imod(y.imul(p));
    }, te.prototype.mul = function(y, p) {
      return this._verify2(y, p), this.imod(y.mul(p));
    }, te.prototype.isqr = function(y) {
      return this.imul(y, y.clone());
    }, te.prototype.sqr = function(y) {
      return this.mul(y, y);
    }, te.prototype.sqrt = function(y) {
      if (y.isZero())
        return y.clone();
      var p = this.m.andln(3);
      if (i(p % 2 === 1), p === 3) {
        var a = this.m.add(new r(1)).iushrn(2);
        return this.pow(y, a);
      }
      for (var l = this.m.subn(1), _ = 0; !l.isZero() && l.andln(1) === 0; )
        _++, l.iushrn(1);
      i(!l.isZero());
      var x = new r(1).toRed(this), A = x.redNeg(), S = this.m.subn(1).iushrn(1), g = this.m.bitLength();
      for (g = new r(2 * g * g).toRed(this); this.pow(g, S).cmp(A) !== 0; )
        g.redIAdd(A);
      for (var w = this.pow(g, l), d = this.pow(y, l.addn(1).iushrn(1)), R = this.pow(y, l), G = _; R.cmp(x) !== 0; ) {
        for (var fe = R, z = 0; fe.cmp(x) !== 0; z++)
          fe = fe.redSqr();
        i(z < G);
        var V = this.pow(w, new r(1).iushln(G - z - 1));
        d = d.redMul(V), w = V.redSqr(), R = R.redMul(w), G = z;
      }
      return d;
    }, te.prototype.invm = function(y) {
      var p = y._invmp(this.m);
      return p.negative !== 0 ? (p.negative = 0, this.imod(p).redNeg()) : this.imod(p);
    }, te.prototype.pow = function(y, p) {
      if (p.isZero())
        return new r(1).toRed(this);
      if (p.cmpn(1) === 0)
        return y.clone();
      var a = 4, l = new Array(1 << a);
      l[0] = new r(1).toRed(this), l[1] = y;
      for (var _ = 2; _ < l.length; _++)
        l[_] = this.mul(l[_ - 1], y);
      var x = l[0], A = 0, S = 0, g = p.bitLength() % 26;
      for (g === 0 && (g = 26), _ = p.length - 1; _ >= 0; _--) {
        for (var w = p.words[_], d = g - 1; d >= 0; d--) {
          var R = w >> d & 1;
          if (x !== l[0] && (x = this.sqr(x)), R === 0 && A === 0) {
            S = 0;
            continue;
          }
          A <<= 1, A |= R, S++, !(S !== a && (_ !== 0 || d !== 0)) && (x = this.mul(x, l[A]), S = 0, A = 0);
        }
        g = 26;
      }
      return x;
    }, te.prototype.convertTo = function(y) {
      var p = y.umod(this.m);
      return p === y ? p.clone() : p;
    }, te.prototype.convertFrom = function(y) {
      var p = y.clone();
      return p.red = null, p;
    }, r.mont = function(y) {
      return new oe(y);
    };
    function oe(U) {
      te.call(this, U), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new r(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    s(oe, te), oe.prototype.convertTo = function(y) {
      return this.imod(y.ushln(this.shift));
    }, oe.prototype.convertFrom = function(y) {
      var p = this.imod(y.mul(this.rinv));
      return p.red = null, p;
    }, oe.prototype.imul = function(y, p) {
      if (y.isZero() || p.isZero())
        return y.words[0] = 0, y.length = 1, y;
      var a = y.imul(p), l = a.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), _ = a.isub(l).iushrn(this.shift), x = _;
      return _.cmp(this.m) >= 0 ? x = _.isub(this.m) : _.cmpn(0) < 0 && (x = _.iadd(this.m)), x._forceRed(this);
    }, oe.prototype.mul = function(y, p) {
      if (y.isZero() || p.isZero())
        return new r(0)._forceRed(this);
      var a = y.mul(p), l = a.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), _ = a.isub(l).iushrn(this.shift), x = _;
      return _.cmp(this.m) >= 0 ? x = _.isub(this.m) : _.cmpn(0) < 0 && (x = _.iadd(this.m)), x._forceRed(this);
    }, oe.prototype.invm = function(y) {
      var p = this.imod(y._invmp(this.m).mul(this.r2));
      return p._forceRed(this);
    };
  })(e, Ze);
})(c0);
var Wt = c0.exports, Z8 = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(dn, "__esModule", { value: !0 });
dn.rawEncode = dn.parseNumber = dn.solidityPack = void 0;
const cn = qi, hn = Z8(Wt), G8 = u0, Ub = Vt;
function W8(e, t) {
  if (e.length !== t.length)
    throw new Error("Number of types are not matching the values");
  const n = [];
  for (let i = 0; i < e.length; i++) {
    const s = Hb(e[i]), r = t[i];
    n.push(Fb(s, r, null));
  }
  return Buffer.concat(n);
}
dn.solidityPack = W8;
function Aa(e) {
  return e.endsWith("]");
}
function gf(e) {
  const t = e.match(/(.*)\[(.*?)\]$/u);
  return t ? t[2] === "" ? "dynamic" : parseInt(t[2], 10) : null;
}
function Wn(e) {
  const t = /^\D+(\d+)$/u.exec(e);
  if (t === null)
    throw new Error(`Invalid parseTypeN input "${e}".`);
  return parseInt(t[1], 10);
}
function un(e) {
  const t = typeof e;
  if (t === "string")
    return (0, cn.isHexPrefixed)(e) ? new hn.default((0, G8.stripHexPrefix)(e), 16) : new hn.default(e, 10);
  if (t === "number")
    return new hn.default(e);
  if (e && Object.prototype.hasOwnProperty.call(e, "toArray") || hn.default.isBN(e))
    return e;
  throw new Error("Argument is not a number");
}
dn.parseNumber = un;
function Fb(e, t, n) {
  if (Aa(e)) {
    const i = e.replace(/\[.*?\]/u, "");
    if (!Aa(i)) {
      const r = gf(e);
      if (r !== "dynamic" && r !== 0 && r !== null && t.length > r)
        throw new Error(`Elements exceed array size: ${r}`);
    }
    const s = t.map((r) => Fb(i, r, 256));
    return Buffer.concat(s);
  } else {
    if (e === "bytes")
      return t;
    if (e === "string")
      return Buffer.from(t, "utf8");
    if (e === "bool") {
      n = n || 8;
      const i = Array(n / 4).join("0");
      return Buffer.from(t ? `${i}1` : `${i}0`, "hex");
    } else if (e === "address") {
      let i = 20;
      return n && (i = n / 8), (0, cn.setLengthLeft)((0, cn.toBuffer)(t), i);
    } else if (e.startsWith("bytes")) {
      const i = Wn(e);
      if (i < 1 || i > 32)
        throw new Error(`Invalid bytes<N> width: ${i}`);
      return typeof t == "number" && (t = (0, Ub.normalize)(t)), (0, cn.setLengthRight)((0, cn.toBuffer)(t), i);
    } else if (e.startsWith("uint")) {
      const i = Wn(e);
      if (i % 8 || i < 8 || i > 256)
        throw new Error(`Invalid uint<N> width: ${i}`);
      const s = un(t);
      if (s.bitLength() > i)
        throw new Error(`Supplied uint exceeds width: ${i} vs ${s.bitLength()}`);
      return n = n || i, s.toArrayLike(Buffer, "be", n / 8);
    } else if (e.startsWith("int")) {
      const i = Wn(e);
      if (i % 8 || i < 8 || i > 256)
        throw new Error(`Invalid int<N> width: ${i}`);
      const s = un(t);
      if (s.bitLength() > i)
        throw new Error(`Supplied int exceeds width: ${i} vs ${s.bitLength()}`);
      return n = n || i, s.toTwos(i).toArrayLike(Buffer, "be", n / 8);
    }
  }
  throw new Error(`Unsupported or invalid type: ${JSON.stringify(e)}`);
}
function Hb(e) {
  return e.startsWith("int[") ? `int256${e.slice(3)}` : e === "int" ? "int256" : e.startsWith("uint[") ? `uint256${e.slice(4)}` : e === "uint" ? "uint256" : e.startsWith("fixed[") ? `fixed128x128${e.slice(5)}` : e === "fixed" ? "fixed128x128" : e.startsWith("ufixed[") ? `ufixed128x128${e.slice(6)}` : e === "ufixed" ? "ufixed128x128" : e;
}
function J8(e, t) {
  const n = [], i = [];
  let s = 0;
  e.forEach((r) => {
    if (Aa(r)) {
      const o = gf(r);
      o !== "dynamic" && o !== null ? s += 32 * o : s += 32;
    } else
      s += 32;
  });
  for (let r = 0; r < e.length; r++) {
    const o = Hb(e[r]), u = t[r], c = Hr(o, u);
    X8(o) ? (n.push(Hr("uint256", s)), i.push(c), s += c.length) : n.push(c);
  }
  return Buffer.concat(n.concat(i));
}
dn.rawEncode = J8;
function Hr(e, t) {
  if (e === "address")
    return Hr("uint160", un(t));
  if (e === "bool")
    return Hr("uint8", t ? 1 : 0);
  if (e === "string")
    return Hr("bytes", Buffer.from(t, "utf8"));
  if (Aa(e)) {
    if (typeof t.length > "u")
      throw new Error("Not an array?");
    const n = gf(e);
    if (n !== "dynamic" && n !== 0 && n !== null && t.length > n)
      throw new Error(`Elements exceed array size: ${n}`);
    const i = [];
    e = e.slice(0, e.lastIndexOf("[")), typeof t == "string" && (t = JSON.parse(t));
    for (const s in t)
      Object.prototype.hasOwnProperty.call(t, s) && i.push(Hr(e, t[s]));
    if (n === "dynamic") {
      const s = Hr("uint256", t.length);
      i.unshift(s);
    }
    return Buffer.concat(i);
  } else if (e === "bytes") {
    t = Buffer.from(t);
    let n = Buffer.concat([Hr("uint256", t.length), t]);
    return t.length % 32 !== 0 && (n = Buffer.concat([n, (0, cn.zeros)(32 - t.length % 32)])), n;
  } else if (e.startsWith("bytes")) {
    const n = Wn(e);
    if (n < 1 || n > 32)
      throw new Error(`Invalid bytes<N> width: ${n}`);
    const i = typeof t == "number" ? (0, Ub.normalize)(t) : t;
    return (0, cn.setLengthRight)((0, cn.toBuffer)(i), 32);
  } else if (e.startsWith("uint")) {
    const n = Wn(e);
    if (n % 8 || n < 8 || n > 256)
      throw new Error(`Invalid uint<N> width: ${n}`);
    const i = un(t);
    if (i.bitLength() > n)
      throw new Error(`Supplied uint exceeds width: ${n} vs ${i.bitLength()}`);
    if (i.isNeg())
      throw new Error("Supplied uint is negative");
    return i.toArrayLike(Buffer, "be", 32);
  } else if (e.startsWith("int")) {
    const n = Wn(e);
    if (n % 8 || n < 8 || n > 256)
      throw new Error(`Invalid int<N> width: ${n}`);
    const i = un(t);
    if (i.bitLength() > n)
      throw new Error(`Supplied int exceeds width: ${n} vs ${i.bitLength()}`);
    return i.toTwos(256).toArrayLike(Buffer, "be", 32);
  } else if (e.startsWith("ufixed")) {
    const n = sd(e), i = un(t);
    if (i.isNeg())
      throw new Error("Supplied ufixed is negative");
    return Hr("uint256", i.mul(new hn.default(2).pow(new hn.default(n[1]))));
  } else if (e.startsWith("fixed")) {
    const n = sd(e);
    return Hr("int256", un(t).mul(new hn.default(2).pow(new hn.default(n[1]))));
  }
  throw new Error(`Unsupported or invalid type: ${JSON.stringify(e)}`);
}
function X8(e) {
  return e === "string" || e === "bytes" || gf(e) === "dynamic";
}
function sd(e) {
  const t = /^\D+(\d+)x(\d+)$/u.exec(e);
  if (t === null || t.length < 1)
    throw new Error(`Invalid parseTypeNxM input "${e}".`);
  return [parseInt(t[1], 10), parseInt(t[2], 10)];
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.recoverTypedSignature = e.signTypedData = e.typedSignatureHash = e.TypedDataUtils = e.TYPED_MESSAGE_SCHEMA = e.SignTypedDataVersion = void 0;
  const t = qi, n = Rr, i = u0, s = dn, r = Vt;
  var o;
  (function(N) {
    N.V1 = "V1", N.V3 = "V3", N.V4 = "V4";
  })(o = e.SignTypedDataVersion || (e.SignTypedDataVersion = {})), e.TYPED_MESSAGE_SCHEMA = {
    type: "object",
    properties: {
      types: {
        type: "object",
        additionalProperties: {
          type: "array",
          items: {
            type: "object",
            properties: {
              name: { type: "string" },
              type: { type: "string" }
            },
            required: ["name", "type"]
          }
        }
      },
      primaryType: { type: "string" },
      domain: { type: "object" },
      message: { type: "object" }
    },
    required: ["types", "primaryType", "domain", "message"]
  };
  function u(N, q) {
    if (Object.keys(o).includes(N)) {
      if (q && !q.includes(N))
        throw new Error(`SignTypedDataVersion not allowed: '${N}'. Allowed versions are: ${q.join(", ")}`);
    } else
      throw new Error(`Invalid version: '${N}'`);
  }
  function c(N, q, D, re, te) {
    if (u(te, [o.V3, o.V4]), N[D] !== void 0)
      return [
        "bytes32",
        // TODO: return Buffer, remove string from return type
        te === o.V4 && re == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : (0, t.arrToBufArr)((0, n.keccak256)(h(D, re, N, te)))
      ];
    if (re === void 0)
      throw new Error(`missing value for field ${q} of type ${D}`);
    if (D === "bytes") {
      if (typeof re == "number")
        re = (0, r.numberToBuffer)(re);
      else if ((0, i.isHexString)(re)) {
        const oe = re.length % 2 ? "0" : "";
        re = Buffer.from(oe + re.slice(2), "hex");
      } else
        re = Buffer.from(re, "utf8");
      return ["bytes32", (0, t.arrToBufArr)((0, n.keccak256)(re))];
    }
    if (D === "string")
      return typeof re == "number" ? re = (0, r.numberToBuffer)(re) : re = Buffer.from(re ?? "", "utf8"), ["bytes32", (0, t.arrToBufArr)((0, n.keccak256)(re))];
    if (D.endsWith("]")) {
      if (te === o.V3)
        throw new Error("Arrays are unimplemented in encodeData; use V4 extension");
      const oe = D.slice(0, D.lastIndexOf("[")), U = re.map((y) => c(N, q, oe, y, te));
      return [
        "bytes32",
        (0, t.arrToBufArr)((0, n.keccak256)((0, s.rawEncode)(U.map(([y]) => y), U.map(([, y]) => y))))
      ];
    }
    return [D, re];
  }
  function h(N, q, D, re) {
    u(re, [o.V3, o.V4]);
    const te = ["bytes32"], oe = [m(N, D)];
    for (const U of D[N]) {
      if (re === o.V3 && q[U.name] === void 0)
        continue;
      const [y, p] = c(D, U.name, U.type, q[U.name], re);
      te.push(y), oe.push(p);
    }
    return (0, s.rawEncode)(te, oe);
  }
  function f(N, q) {
    let D = "";
    const re = b(N, q);
    re.delete(N);
    const te = [N, ...Array.from(re).sort()];
    for (const oe of te) {
      if (!q[oe])
        throw new Error(`No type definition specified: ${oe}`);
      D += `${oe}(${q[oe].map(({ name: y, type: p }) => `${p} ${y}`).join(",")})`;
    }
    return D;
  }
  function b(N, q, D = /* @__PURE__ */ new Set()) {
    if (typeof N != "string")
      throw new Error(`Invalid findTypeDependencies input ${JSON.stringify(N)}`);
    if ([N] = N.match(/^\w*/u), D.has(N) || q[N] === void 0)
      return D;
    D.add(N);
    for (const te of q[N])
      b(te.type, q, D);
    return D;
  }
  function v(N, q, D, re) {
    u(re, [o.V3, o.V4]);
    const te = h(N, q, D, re), oe = (0, n.keccak256)(te);
    return (0, t.arrToBufArr)(oe);
  }
  function m(N, q) {
    const D = Buffer.from(f(N, q), "utf-8");
    return (0, t.arrToBufArr)((0, n.keccak256)(D));
  }
  function E(N) {
    const q = {};
    for (const D in e.TYPED_MESSAGE_SCHEMA.properties)
      N[D] && (q[D] = N[D]);
    return "types" in q && (q.types = Object.assign({ EIP712Domain: [] }, q.types)), q;
  }
  function M(N, q) {
    u(q, [o.V3, o.V4]);
    const D = E(N), { domain: re } = D, te = { EIP712Domain: D.types.EIP712Domain };
    return v("EIP712Domain", re, te, q);
  }
  function B(N, q) {
    u(q, [o.V3, o.V4]);
    const D = E(N), re = [Buffer.from("1901", "hex")];
    return re.push(M(N, q)), D.primaryType !== "EIP712Domain" && re.push(v(
      // TODO: Validate that this is a string, so this type cast can be removed.
      D.primaryType,
      D.message,
      D.types,
      q
    )), (0, t.arrToBufArr)((0, n.keccak256)(Buffer.concat(re)));
  }
  e.TypedDataUtils = {
    encodeData: h,
    encodeType: f,
    findTypeDependencies: b,
    hashStruct: v,
    hashType: m,
    sanitizeData: E,
    eip712Hash: B,
    eip712DomainHash: M
  };
  function I(N) {
    const q = T(N);
    return (0, t.bufferToHex)(q);
  }
  e.typedSignatureHash = I;
  function T(N) {
    const q = new Error("Expect argument to be non-empty array");
    if (typeof N != "object" || !("length" in N) || !N.length)
      throw q;
    const D = N.map(function(oe) {
      return oe.type !== "bytes" ? oe.value : (0, r.legacyToBuffer)(oe.value);
    }), re = N.map(function(oe) {
      return oe.type;
    }), te = N.map(function(oe) {
      if (!oe.name)
        throw q;
      return `${oe.type} ${oe.name}`;
    });
    return (0, t.arrToBufArr)((0, n.keccak256)((0, s.solidityPack)(["bytes32", "bytes32"], [
      (0, n.keccak256)((0, s.solidityPack)(new Array(N.length).fill("string"), te)),
      (0, n.keccak256)((0, s.solidityPack)(re, D))
    ])));
  }
  function k({ privateKey: N, data: q, version: D }) {
    if (u(D), (0, r.isNullish)(q))
      throw new Error("Missing data parameter");
    if ((0, r.isNullish)(N))
      throw new Error("Missing private key parameter");
    const re = D === o.V1 ? T(q) : e.TypedDataUtils.eip712Hash(q, D), te = (0, t.ecsign)(re, N);
    return (0, r.concatSig)((0, t.toBuffer)(te.v), te.r, te.s);
  }
  e.signTypedData = k;
  function j({ data: N, signature: q, version: D }) {
    if (u(D), (0, r.isNullish)(N))
      throw new Error("Missing data parameter");
    if ((0, r.isNullish)(q))
      throw new Error("Missing signature parameter");
    const re = D === o.V1 ? T(N) : e.TypedDataUtils.eip712Hash(N, D), te = (0, r.recoverPublicKey)(re, q), oe = (0, t.publicToAddress)(te);
    return (0, t.bufferToHex)(oe);
  }
  e.recoverTypedSignature = j;
})($b);
var Mr = {}, zb = { exports: {} }, wt = {}, aa = { exports: {} }, ud;
function ci() {
  if (ud)
    return aa.exports;
  ud = 1;
  var e = 65536, t = 4294967295;
  function n() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var i = At().Buffer, s = Ze.crypto || Ze.msCrypto;
  s && s.getRandomValues ? aa.exports = r : aa.exports = n;
  function r(o, u) {
    if (o > t)
      throw new RangeError("requested too many random bytes");
    var c = i.allocUnsafe(o);
    if (o > 0)
      if (o > e)
        for (var h = 0; h < o; h += e)
          s.getRandomValues(c.slice(h, h + e));
      else
        s.getRandomValues(c);
    return typeof u == "function" ? process.nextTick(function() {
      u(null, c);
    }) : c;
  }
  return aa.exports;
}
var ls, cd;
function Vb() {
  if (cd)
    return ls;
  cd = 1;
  var e = At().Buffer, t = pf().Transform, n = mt();
  function i(r, o) {
    if (!e.isBuffer(r) && typeof r != "string")
      throw new TypeError(o + " must be a string or a buffer");
  }
  function s(r) {
    t.call(this), this._block = e.allocUnsafe(r), this._blockSize = r, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return n(s, t), s.prototype._transform = function(r, o, u) {
    var c = null;
    try {
      this.update(r, o);
    } catch (h) {
      c = h;
    }
    u(c);
  }, s.prototype._flush = function(r) {
    var o = null;
    try {
      this.push(this.digest());
    } catch (u) {
      o = u;
    }
    r(o);
  }, s.prototype.update = function(r, o) {
    if (i(r, "Data"), this._finalized)
      throw new Error("Digest already called");
    e.isBuffer(r) || (r = e.from(r, o));
    for (var u = this._block, c = 0; this._blockOffset + r.length - c >= this._blockSize; ) {
      for (var h = this._blockOffset; h < this._blockSize; )
        u[h++] = r[c++];
      this._update(), this._blockOffset = 0;
    }
    for (; c < r.length; )
      u[this._blockOffset++] = r[c++];
    for (var f = 0, b = r.length * 8; b > 0; ++f)
      this._length[f] += b, b = this._length[f] / 4294967296 | 0, b > 0 && (this._length[f] -= 4294967296 * b);
    return this;
  }, s.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, s.prototype.digest = function(r) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = !0;
    var o = this._digest();
    r !== void 0 && (o = o.toString(r)), this._block.fill(0), this._blockOffset = 0;
    for (var u = 0; u < 4; ++u)
      this._length[u] = 0;
    return o;
  }, s.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, ls = s, ls;
}
var ds, hd;
function h0() {
  if (hd)
    return ds;
  hd = 1;
  var e = mt(), t = Vb(), n = At().Buffer, i = new Array(16);
  function s() {
    t.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  e(s, t), s.prototype._update = function() {
    for (var f = i, b = 0; b < 16; ++b)
      f[b] = this._block.readInt32LE(b * 4);
    var v = this._a, m = this._b, E = this._c, M = this._d;
    v = o(v, m, E, M, f[0], 3614090360, 7), M = o(M, v, m, E, f[1], 3905402710, 12), E = o(E, M, v, m, f[2], 606105819, 17), m = o(m, E, M, v, f[3], 3250441966, 22), v = o(v, m, E, M, f[4], 4118548399, 7), M = o(M, v, m, E, f[5], 1200080426, 12), E = o(E, M, v, m, f[6], 2821735955, 17), m = o(m, E, M, v, f[7], 4249261313, 22), v = o(v, m, E, M, f[8], 1770035416, 7), M = o(M, v, m, E, f[9], 2336552879, 12), E = o(E, M, v, m, f[10], 4294925233, 17), m = o(m, E, M, v, f[11], 2304563134, 22), v = o(v, m, E, M, f[12], 1804603682, 7), M = o(M, v, m, E, f[13], 4254626195, 12), E = o(E, M, v, m, f[14], 2792965006, 17), m = o(m, E, M, v, f[15], 1236535329, 22), v = u(v, m, E, M, f[1], 4129170786, 5), M = u(M, v, m, E, f[6], 3225465664, 9), E = u(E, M, v, m, f[11], 643717713, 14), m = u(m, E, M, v, f[0], 3921069994, 20), v = u(v, m, E, M, f[5], 3593408605, 5), M = u(M, v, m, E, f[10], 38016083, 9), E = u(E, M, v, m, f[15], 3634488961, 14), m = u(m, E, M, v, f[4], 3889429448, 20), v = u(v, m, E, M, f[9], 568446438, 5), M = u(M, v, m, E, f[14], 3275163606, 9), E = u(E, M, v, m, f[3], 4107603335, 14), m = u(m, E, M, v, f[8], 1163531501, 20), v = u(v, m, E, M, f[13], 2850285829, 5), M = u(M, v, m, E, f[2], 4243563512, 9), E = u(E, M, v, m, f[7], 1735328473, 14), m = u(m, E, M, v, f[12], 2368359562, 20), v = c(v, m, E, M, f[5], 4294588738, 4), M = c(M, v, m, E, f[8], 2272392833, 11), E = c(E, M, v, m, f[11], 1839030562, 16), m = c(m, E, M, v, f[14], 4259657740, 23), v = c(v, m, E, M, f[1], 2763975236, 4), M = c(M, v, m, E, f[4], 1272893353, 11), E = c(E, M, v, m, f[7], 4139469664, 16), m = c(m, E, M, v, f[10], 3200236656, 23), v = c(v, m, E, M, f[13], 681279174, 4), M = c(M, v, m, E, f[0], 3936430074, 11), E = c(E, M, v, m, f[3], 3572445317, 16), m = c(m, E, M, v, f[6], 76029189, 23), v = c(v, m, E, M, f[9], 3654602809, 4), M = c(M, v, m, E, f[12], 3873151461, 11), E = c(E, M, v, m, f[15], 530742520, 16), m = c(m, E, M, v, f[2], 3299628645, 23), v = h(v, m, E, M, f[0], 4096336452, 6), M = h(M, v, m, E, f[7], 1126891415, 10), E = h(E, M, v, m, f[14], 2878612391, 15), m = h(m, E, M, v, f[5], 4237533241, 21), v = h(v, m, E, M, f[12], 1700485571, 6), M = h(M, v, m, E, f[3], 2399980690, 10), E = h(E, M, v, m, f[10], 4293915773, 15), m = h(m, E, M, v, f[1], 2240044497, 21), v = h(v, m, E, M, f[8], 1873313359, 6), M = h(M, v, m, E, f[15], 4264355552, 10), E = h(E, M, v, m, f[6], 2734768916, 15), m = h(m, E, M, v, f[13], 1309151649, 21), v = h(v, m, E, M, f[4], 4149444226, 6), M = h(M, v, m, E, f[11], 3174756917, 10), E = h(E, M, v, m, f[2], 718787259, 15), m = h(m, E, M, v, f[9], 3951481745, 21), this._a = this._a + v | 0, this._b = this._b + m | 0, this._c = this._c + E | 0, this._d = this._d + M | 0;
  }, s.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var f = n.allocUnsafe(16);
    return f.writeInt32LE(this._a, 0), f.writeInt32LE(this._b, 4), f.writeInt32LE(this._c, 8), f.writeInt32LE(this._d, 12), f;
  };
  function r(f, b) {
    return f << b | f >>> 32 - b;
  }
  function o(f, b, v, m, E, M, B) {
    return r(f + (b & v | ~b & m) + E + M | 0, B) + b | 0;
  }
  function u(f, b, v, m, E, M, B) {
    return r(f + (b & m | v & ~m) + E + M | 0, B) + b | 0;
  }
  function c(f, b, v, m, E, M, B) {
    return r(f + (b ^ v ^ m) + E + M | 0, B) + b | 0;
  }
  function h(f, b, v, m, E, M, B) {
    return r(f + (v ^ (b | ~m)) + E + M | 0, B) + b | 0;
  }
  return ds = s, ds;
}
var ps, ld;
function l0() {
  if (ld)
    return ps;
  ld = 1;
  var e = dr.Buffer, t = mt(), n = Vb(), i = new Array(16), s = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], r = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], o = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], u = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], c = [0, 1518500249, 1859775393, 2400959708, 2840853838], h = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function f() {
    n.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  t(f, n), f.prototype._update = function() {
    for (var I = i, T = 0; T < 16; ++T)
      I[T] = this._block.readInt32LE(T * 4);
    for (var k = this._a | 0, j = this._b | 0, N = this._c | 0, q = this._d | 0, D = this._e | 0, re = this._a | 0, te = this._b | 0, oe = this._c | 0, U = this._d | 0, y = this._e | 0, p = 0; p < 80; p += 1) {
      var a, l;
      p < 16 ? (a = v(k, j, N, q, D, I[s[p]], c[0], o[p]), l = B(re, te, oe, U, y, I[r[p]], h[0], u[p])) : p < 32 ? (a = m(k, j, N, q, D, I[s[p]], c[1], o[p]), l = M(re, te, oe, U, y, I[r[p]], h[1], u[p])) : p < 48 ? (a = E(k, j, N, q, D, I[s[p]], c[2], o[p]), l = E(re, te, oe, U, y, I[r[p]], h[2], u[p])) : p < 64 ? (a = M(k, j, N, q, D, I[s[p]], c[3], o[p]), l = m(re, te, oe, U, y, I[r[p]], h[3], u[p])) : (a = B(k, j, N, q, D, I[s[p]], c[4], o[p]), l = v(re, te, oe, U, y, I[r[p]], h[4], u[p])), k = D, D = q, q = b(N, 10), N = j, j = a, re = y, y = U, U = b(oe, 10), oe = te, te = l;
    }
    var _ = this._b + N + U | 0;
    this._b = this._c + q + y | 0, this._c = this._d + D + re | 0, this._d = this._e + k + te | 0, this._e = this._a + j + oe | 0, this._a = _;
  }, f.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var I = e.alloc ? e.alloc(20) : new e(20);
    return I.writeInt32LE(this._a, 0), I.writeInt32LE(this._b, 4), I.writeInt32LE(this._c, 8), I.writeInt32LE(this._d, 12), I.writeInt32LE(this._e, 16), I;
  };
  function b(I, T) {
    return I << T | I >>> 32 - T;
  }
  function v(I, T, k, j, N, q, D, re) {
    return b(I + (T ^ k ^ j) + q + D | 0, re) + N | 0;
  }
  function m(I, T, k, j, N, q, D, re) {
    return b(I + (T & k | ~T & j) + q + D | 0, re) + N | 0;
  }
  function E(I, T, k, j, N, q, D, re) {
    return b(I + ((T | ~k) ^ j) + q + D | 0, re) + N | 0;
  }
  function M(I, T, k, j, N, q, D, re) {
    return b(I + (T & j | k & ~j) + q + D | 0, re) + N | 0;
  }
  function B(I, T, k, j, N, q, D, re) {
    return b(I + (T ^ (k | ~j)) + q + D | 0, re) + N | 0;
  }
  return ps = f, ps;
}
var vs = { exports: {} }, bs, dd;
function hi() {
  if (dd)
    return bs;
  dd = 1;
  var e = At().Buffer;
  function t(n, i) {
    this._block = e.alloc(n), this._finalSize = i, this._blockSize = n, this._len = 0;
  }
  return t.prototype.update = function(n, i) {
    typeof n == "string" && (i = i || "utf8", n = e.from(n, i));
    for (var s = this._block, r = this._blockSize, o = n.length, u = this._len, c = 0; c < o; ) {
      for (var h = u % r, f = Math.min(o - c, r - h), b = 0; b < f; b++)
        s[h + b] = n[c + b];
      u += f, c += f, u % r === 0 && this._update(s);
    }
    return this._len += o, this;
  }, t.prototype.digest = function(n) {
    var i = this._len % this._blockSize;
    this._block[i] = 128, this._block.fill(0, i + 1), i >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var s = this._len * 8;
    if (s <= 4294967295)
      this._block.writeUInt32BE(s, this._blockSize - 4);
    else {
      var r = (s & 4294967295) >>> 0, o = (s - r) / 4294967296;
      this._block.writeUInt32BE(o, this._blockSize - 8), this._block.writeUInt32BE(r, this._blockSize - 4);
    }
    this._update(this._block);
    var u = this._hash();
    return n ? u.toString(n) : u;
  }, t.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, bs = t, bs;
}
var ys, pd;
function Y8() {
  if (pd)
    return ys;
  pd = 1;
  var e = mt(), t = hi(), n = At().Buffer, i = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], s = new Array(80);
  function r() {
    this.init(), this._w = s, t.call(this, 64, 56);
  }
  e(r, t), r.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function o(h) {
    return h << 5 | h >>> 27;
  }
  function u(h) {
    return h << 30 | h >>> 2;
  }
  function c(h, f, b, v) {
    return h === 0 ? f & b | ~f & v : h === 2 ? f & b | f & v | b & v : f ^ b ^ v;
  }
  return r.prototype._update = function(h) {
    for (var f = this._w, b = this._a | 0, v = this._b | 0, m = this._c | 0, E = this._d | 0, M = this._e | 0, B = 0; B < 16; ++B)
      f[B] = h.readInt32BE(B * 4);
    for (; B < 80; ++B)
      f[B] = f[B - 3] ^ f[B - 8] ^ f[B - 14] ^ f[B - 16];
    for (var I = 0; I < 80; ++I) {
      var T = ~~(I / 20), k = o(b) + c(T, v, m, E) + M + f[I] + i[T] | 0;
      M = E, E = m, m = u(v), v = b, b = k;
    }
    this._a = b + this._a | 0, this._b = v + this._b | 0, this._c = m + this._c | 0, this._d = E + this._d | 0, this._e = M + this._e | 0;
  }, r.prototype._hash = function() {
    var h = n.allocUnsafe(20);
    return h.writeInt32BE(this._a | 0, 0), h.writeInt32BE(this._b | 0, 4), h.writeInt32BE(this._c | 0, 8), h.writeInt32BE(this._d | 0, 12), h.writeInt32BE(this._e | 0, 16), h;
  }, ys = r, ys;
}
var gs, vd;
function Q8() {
  if (vd)
    return gs;
  vd = 1;
  var e = mt(), t = hi(), n = At().Buffer, i = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], s = new Array(80);
  function r() {
    this.init(), this._w = s, t.call(this, 64, 56);
  }
  e(r, t), r.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function o(f) {
    return f << 1 | f >>> 31;
  }
  function u(f) {
    return f << 5 | f >>> 27;
  }
  function c(f) {
    return f << 30 | f >>> 2;
  }
  function h(f, b, v, m) {
    return f === 0 ? b & v | ~b & m : f === 2 ? b & v | b & m | v & m : b ^ v ^ m;
  }
  return r.prototype._update = function(f) {
    for (var b = this._w, v = this._a | 0, m = this._b | 0, E = this._c | 0, M = this._d | 0, B = this._e | 0, I = 0; I < 16; ++I)
      b[I] = f.readInt32BE(I * 4);
    for (; I < 80; ++I)
      b[I] = o(b[I - 3] ^ b[I - 8] ^ b[I - 14] ^ b[I - 16]);
    for (var T = 0; T < 80; ++T) {
      var k = ~~(T / 20), j = u(v) + h(k, m, E, M) + B + b[T] + i[k] | 0;
      B = M, M = E, E = c(m), m = v, v = j;
    }
    this._a = v + this._a | 0, this._b = m + this._b | 0, this._c = E + this._c | 0, this._d = M + this._d | 0, this._e = B + this._e | 0;
  }, r.prototype._hash = function() {
    var f = n.allocUnsafe(20);
    return f.writeInt32BE(this._a | 0, 0), f.writeInt32BE(this._b | 0, 4), f.writeInt32BE(this._c | 0, 8), f.writeInt32BE(this._d | 0, 12), f.writeInt32BE(this._e | 0, 16), f;
  }, gs = r, gs;
}
var ms, bd;
function Kb() {
  if (bd)
    return ms;
  bd = 1;
  var e = mt(), t = hi(), n = At().Buffer, i = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], s = new Array(64);
  function r() {
    this.init(), this._w = s, t.call(this, 64, 56);
  }
  e(r, t), r.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function o(v, m, E) {
    return E ^ v & (m ^ E);
  }
  function u(v, m, E) {
    return v & m | E & (v | m);
  }
  function c(v) {
    return (v >>> 2 | v << 30) ^ (v >>> 13 | v << 19) ^ (v >>> 22 | v << 10);
  }
  function h(v) {
    return (v >>> 6 | v << 26) ^ (v >>> 11 | v << 21) ^ (v >>> 25 | v << 7);
  }
  function f(v) {
    return (v >>> 7 | v << 25) ^ (v >>> 18 | v << 14) ^ v >>> 3;
  }
  function b(v) {
    return (v >>> 17 | v << 15) ^ (v >>> 19 | v << 13) ^ v >>> 10;
  }
  return r.prototype._update = function(v) {
    for (var m = this._w, E = this._a | 0, M = this._b | 0, B = this._c | 0, I = this._d | 0, T = this._e | 0, k = this._f | 0, j = this._g | 0, N = this._h | 0, q = 0; q < 16; ++q)
      m[q] = v.readInt32BE(q * 4);
    for (; q < 64; ++q)
      m[q] = b(m[q - 2]) + m[q - 7] + f(m[q - 15]) + m[q - 16] | 0;
    for (var D = 0; D < 64; ++D) {
      var re = N + h(T) + o(T, k, j) + i[D] + m[D] | 0, te = c(E) + u(E, M, B) | 0;
      N = j, j = k, k = T, T = I + re | 0, I = B, B = M, M = E, E = re + te | 0;
    }
    this._a = E + this._a | 0, this._b = M + this._b | 0, this._c = B + this._c | 0, this._d = I + this._d | 0, this._e = T + this._e | 0, this._f = k + this._f | 0, this._g = j + this._g | 0, this._h = N + this._h | 0;
  }, r.prototype._hash = function() {
    var v = n.allocUnsafe(32);
    return v.writeInt32BE(this._a, 0), v.writeInt32BE(this._b, 4), v.writeInt32BE(this._c, 8), v.writeInt32BE(this._d, 12), v.writeInt32BE(this._e, 16), v.writeInt32BE(this._f, 20), v.writeInt32BE(this._g, 24), v.writeInt32BE(this._h, 28), v;
  }, ms = r, ms;
}
var _s, yd;
function e5() {
  if (yd)
    return _s;
  yd = 1;
  var e = mt(), t = Kb(), n = hi(), i = At().Buffer, s = new Array(64);
  function r() {
    this.init(), this._w = s, n.call(this, 64, 56);
  }
  return e(r, t), r.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, r.prototype._hash = function() {
    var o = i.allocUnsafe(28);
    return o.writeInt32BE(this._a, 0), o.writeInt32BE(this._b, 4), o.writeInt32BE(this._c, 8), o.writeInt32BE(this._d, 12), o.writeInt32BE(this._e, 16), o.writeInt32BE(this._f, 20), o.writeInt32BE(this._g, 24), o;
  }, _s = r, _s;
}
var ws, gd;
function Zb() {
  if (gd)
    return ws;
  gd = 1;
  var e = mt(), t = hi(), n = At().Buffer, i = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], s = new Array(160);
  function r() {
    this.init(), this._w = s, t.call(this, 128, 112);
  }
  e(r, t), r.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function o(M, B, I) {
    return I ^ M & (B ^ I);
  }
  function u(M, B, I) {
    return M & B | I & (M | B);
  }
  function c(M, B) {
    return (M >>> 28 | B << 4) ^ (B >>> 2 | M << 30) ^ (B >>> 7 | M << 25);
  }
  function h(M, B) {
    return (M >>> 14 | B << 18) ^ (M >>> 18 | B << 14) ^ (B >>> 9 | M << 23);
  }
  function f(M, B) {
    return (M >>> 1 | B << 31) ^ (M >>> 8 | B << 24) ^ M >>> 7;
  }
  function b(M, B) {
    return (M >>> 1 | B << 31) ^ (M >>> 8 | B << 24) ^ (M >>> 7 | B << 25);
  }
  function v(M, B) {
    return (M >>> 19 | B << 13) ^ (B >>> 29 | M << 3) ^ M >>> 6;
  }
  function m(M, B) {
    return (M >>> 19 | B << 13) ^ (B >>> 29 | M << 3) ^ (M >>> 6 | B << 26);
  }
  function E(M, B) {
    return M >>> 0 < B >>> 0 ? 1 : 0;
  }
  return r.prototype._update = function(M) {
    for (var B = this._w, I = this._ah | 0, T = this._bh | 0, k = this._ch | 0, j = this._dh | 0, N = this._eh | 0, q = this._fh | 0, D = this._gh | 0, re = this._hh | 0, te = this._al | 0, oe = this._bl | 0, U = this._cl | 0, y = this._dl | 0, p = this._el | 0, a = this._fl | 0, l = this._gl | 0, _ = this._hl | 0, x = 0; x < 32; x += 2)
      B[x] = M.readInt32BE(x * 4), B[x + 1] = M.readInt32BE(x * 4 + 4);
    for (; x < 160; x += 2) {
      var A = B[x - 30], S = B[x - 15 * 2 + 1], g = f(A, S), w = b(S, A);
      A = B[x - 2 * 2], S = B[x - 2 * 2 + 1];
      var d = v(A, S), R = m(S, A), G = B[x - 7 * 2], fe = B[x - 7 * 2 + 1], z = B[x - 16 * 2], V = B[x - 16 * 2 + 1], F = w + fe | 0, ee = g + G + E(F, w) | 0;
      F = F + R | 0, ee = ee + d + E(F, R) | 0, F = F + V | 0, ee = ee + z + E(F, V) | 0, B[x] = ee, B[x + 1] = F;
    }
    for (var he = 0; he < 160; he += 2) {
      ee = B[he], F = B[he + 1];
      var Z = u(I, T, k), K = u(te, oe, U), ce = c(I, te), ve = c(te, I), Be = h(N, p), Q = h(p, N), C = i[he], L = i[he + 1], W = o(N, q, D), de = o(p, a, l), me = _ + Q | 0, Te = re + Be + E(me, _) | 0;
      me = me + de | 0, Te = Te + W + E(me, de) | 0, me = me + L | 0, Te = Te + C + E(me, L) | 0, me = me + F | 0, Te = Te + ee + E(me, F) | 0;
      var Fe = ve + K | 0, H = ce + Z + E(Fe, ve) | 0;
      re = D, _ = l, D = q, l = a, q = N, a = p, p = y + me | 0, N = j + Te + E(p, y) | 0, j = k, y = U, k = T, U = oe, T = I, oe = te, te = me + Fe | 0, I = Te + H + E(te, me) | 0;
    }
    this._al = this._al + te | 0, this._bl = this._bl + oe | 0, this._cl = this._cl + U | 0, this._dl = this._dl + y | 0, this._el = this._el + p | 0, this._fl = this._fl + a | 0, this._gl = this._gl + l | 0, this._hl = this._hl + _ | 0, this._ah = this._ah + I + E(this._al, te) | 0, this._bh = this._bh + T + E(this._bl, oe) | 0, this._ch = this._ch + k + E(this._cl, U) | 0, this._dh = this._dh + j + E(this._dl, y) | 0, this._eh = this._eh + N + E(this._el, p) | 0, this._fh = this._fh + q + E(this._fl, a) | 0, this._gh = this._gh + D + E(this._gl, l) | 0, this._hh = this._hh + re + E(this._hl, _) | 0;
  }, r.prototype._hash = function() {
    var M = n.allocUnsafe(64);
    function B(I, T, k) {
      M.writeInt32BE(I, k), M.writeInt32BE(T, k + 4);
    }
    return B(this._ah, this._al, 0), B(this._bh, this._bl, 8), B(this._ch, this._cl, 16), B(this._dh, this._dl, 24), B(this._eh, this._el, 32), B(this._fh, this._fl, 40), B(this._gh, this._gl, 48), B(this._hh, this._hl, 56), M;
  }, ws = r, ws;
}
var xs, md;
function t5() {
  if (md)
    return xs;
  md = 1;
  var e = mt(), t = Zb(), n = hi(), i = At().Buffer, s = new Array(160);
  function r() {
    this.init(), this._w = s, n.call(this, 128, 112);
  }
  return e(r, t), r.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, r.prototype._hash = function() {
    var o = i.allocUnsafe(48);
    function u(c, h, f) {
      o.writeInt32BE(c, f), o.writeInt32BE(h, f + 4);
    }
    return u(this._ah, this._al, 0), u(this._bh, this._bl, 8), u(this._ch, this._cl, 16), u(this._dh, this._dl, 24), u(this._eh, this._el, 32), u(this._fh, this._fl, 40), o;
  }, xs = r, xs;
}
var _d;
function d0() {
  if (_d)
    return vs.exports;
  _d = 1;
  var e = vs.exports = function(n) {
    n = n.toLowerCase();
    var i = e[n];
    if (!i)
      throw new Error(n + " is not supported (we accept pull requests)");
    return new i();
  };
  return e.sha = Y8(), e.sha1 = Q8(), e.sha224 = e5(), e.sha256 = Kb(), e.sha384 = t5(), e.sha512 = Zb(), vs.exports;
}
var Es, wd;
function yn() {
  if (wd)
    return Es;
  wd = 1;
  var e = At().Buffer, t = Sb().Transform, n = vc().StringDecoder, i = mt();
  function s(r) {
    t.call(this), this.hashMode = typeof r == "string", this.hashMode ? this[r] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  return i(s, t), s.prototype.update = function(r, o, u) {
    typeof r == "string" && (r = e.from(r, o));
    var c = this._update(r);
    return this.hashMode ? this : (u && (c = this._toString(c, u)), c);
  }, s.prototype.setAutoPadding = function() {
  }, s.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, s.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, s.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, s.prototype._transform = function(r, o, u) {
    var c;
    try {
      this.hashMode ? this._update(r) : this.push(this._update(r));
    } catch (h) {
      c = h;
    } finally {
      u(c);
    }
  }, s.prototype._flush = function(r) {
    var o;
    try {
      this.push(this.__final());
    } catch (u) {
      o = u;
    }
    r(o);
  }, s.prototype._finalOrDigest = function(r) {
    var o = this.__final() || e.alloc(0);
    return r && (o = this._toString(o, r, !0)), o;
  }, s.prototype._toString = function(r, o, u) {
    if (this._decoder || (this._decoder = new n(o), this._encoding = o), this._encoding !== o)
      throw new Error("can't switch encodings");
    var c = this._decoder.write(r);
    return u && (c += this._decoder.end()), c;
  }, Es = s, Es;
}
var Ss, xd;
function Fi() {
  if (xd)
    return Ss;
  xd = 1;
  var e = mt(), t = h0(), n = l0(), i = d0(), s = yn();
  function r(o) {
    s.call(this, "digest"), this._hash = o;
  }
  return e(r, s), r.prototype._update = function(o) {
    this._hash.update(o);
  }, r.prototype._final = function() {
    return this._hash.digest();
  }, Ss = function(u) {
    return u = u.toLowerCase(), u === "md5" ? new t() : u === "rmd160" || u === "ripemd160" ? new n() : new r(i(u));
  }, Ss;
}
var As, Ed;
function r5() {
  if (Ed)
    return As;
  Ed = 1;
  var e = mt(), t = At().Buffer, n = yn(), i = t.alloc(128), s = 64;
  function r(o, u) {
    n.call(this, "digest"), typeof u == "string" && (u = t.from(u)), this._alg = o, this._key = u, u.length > s ? u = o(u) : u.length < s && (u = t.concat([u, i], s));
    for (var c = this._ipad = t.allocUnsafe(s), h = this._opad = t.allocUnsafe(s), f = 0; f < s; f++)
      c[f] = u[f] ^ 54, h[f] = u[f] ^ 92;
    this._hash = [c];
  }
  return e(r, n), r.prototype._update = function(o) {
    this._hash.push(o);
  }, r.prototype._final = function() {
    var o = this._alg(t.concat(this._hash));
    return this._alg(t.concat([this._opad, o]));
  }, As = r, As;
}
var Ms, Sd;
function Gb() {
  if (Sd)
    return Ms;
  Sd = 1;
  var e = h0();
  return Ms = function(t) {
    return new e().update(t).digest();
  }, Ms;
}
var Rs, Ad;
function Wb() {
  if (Ad)
    return Rs;
  Ad = 1;
  var e = mt(), t = r5(), n = yn(), i = At().Buffer, s = Gb(), r = l0(), o = d0(), u = i.alloc(128);
  function c(h, f) {
    n.call(this, "digest"), typeof f == "string" && (f = i.from(f));
    var b = h === "sha512" || h === "sha384" ? 128 : 64;
    if (this._alg = h, this._key = f, f.length > b) {
      var v = h === "rmd160" ? new r() : o(h);
      f = v.update(f).digest();
    } else
      f.length < b && (f = i.concat([f, u], b));
    for (var m = this._ipad = i.allocUnsafe(b), E = this._opad = i.allocUnsafe(b), M = 0; M < b; M++)
      m[M] = f[M] ^ 54, E[M] = f[M] ^ 92;
    this._hash = h === "rmd160" ? new r() : o(h), this._hash.update(m);
  }
  return e(c, n), c.prototype._update = function(h) {
    this._hash.update(h);
  }, c.prototype._final = function() {
    var h = this._hash.digest(), f = this._alg === "rmd160" ? new r() : o(this._alg);
    return f.update(this._opad).update(h).digest();
  }, Rs = function(f, b) {
    return f = f.toLowerCase(), f === "rmd160" || f === "ripemd160" ? new c("rmd160", b) : f === "md5" ? new t(s, b) : new c(f, b);
  }, Rs;
}
const n5 = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, i5 = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, a5 = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, f5 = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, o5 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, s5 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, u5 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, c5 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, h5 = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, l5 = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, d5 = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, Jb = {
  sha224WithRSAEncryption: n5,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption: i5,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption: a5,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption: f5,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: o5,
  sha224: s5,
  sha384: u5,
  sha512: c5,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA: h5,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA: l5,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption: d5,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var Bs, Md;
function p5() {
  return Md || (Md = 1, Bs = Jb), Bs;
}
var fa = {}, Is, Rd;
function Xb() {
  if (Rd)
    return Is;
  Rd = 1;
  var e = Math.pow(2, 30) - 1;
  return Is = function(t, n) {
    if (typeof t != "number")
      throw new TypeError("Iterations not a number");
    if (t < 0)
      throw new TypeError("Bad iterations");
    if (typeof n != "number")
      throw new TypeError("Key length not a number");
    if (n < 0 || n > e || n !== n)
      throw new TypeError("Bad key length");
  }, Is;
}
var Ts, Bd;
function Yb() {
  if (Bd)
    return Ts;
  Bd = 1;
  var e;
  if (Ze.process && Ze.process.browser)
    e = "utf-8";
  else if (Ze.process && Ze.process.version) {
    var t = parseInt(process.version.split(".")[0].slice(1), 10);
    e = t >= 6 ? "utf-8" : "binary";
  } else
    e = "utf-8";
  return Ts = e, Ts;
}
var Os, Id;
function Qb() {
  if (Id)
    return Os;
  Id = 1;
  var e = At().Buffer;
  return Os = function(t, n, i) {
    if (e.isBuffer(t))
      return t;
    if (typeof t == "string")
      return e.from(t, n);
    if (ArrayBuffer.isView(t))
      return e.from(t.buffer);
    throw new TypeError(i + " must be a string, a Buffer, a typed array or a DataView");
  }, Os;
}
var Ps, Td;
function ey() {
  if (Td)
    return Ps;
  Td = 1;
  var e = Gb(), t = l0(), n = d0(), i = At().Buffer, s = Xb(), r = Yb(), o = Qb(), u = i.alloc(128), c = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function h(v, m, E) {
    var M = f(v), B = v === "sha512" || v === "sha384" ? 128 : 64;
    m.length > B ? m = M(m) : m.length < B && (m = i.concat([m, u], B));
    for (var I = i.allocUnsafe(B + c[v]), T = i.allocUnsafe(B + c[v]), k = 0; k < B; k++)
      I[k] = m[k] ^ 54, T[k] = m[k] ^ 92;
    var j = i.allocUnsafe(B + E + 4);
    I.copy(j, 0, 0, B), this.ipad1 = j, this.ipad2 = I, this.opad = T, this.alg = v, this.blocksize = B, this.hash = M, this.size = c[v];
  }
  h.prototype.run = function(v, m) {
    v.copy(m, this.blocksize);
    var E = this.hash(m);
    return E.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function f(v) {
    function m(M) {
      return n(v).update(M).digest();
    }
    function E(M) {
      return new t().update(M).digest();
    }
    return v === "rmd160" || v === "ripemd160" ? E : v === "md5" ? e : m;
  }
  function b(v, m, E, M, B) {
    s(E, M), v = o(v, r, "Password"), m = o(m, r, "Salt"), B = B || "sha1";
    var I = new h(B, v, m.length), T = i.allocUnsafe(M), k = i.allocUnsafe(m.length + 4);
    m.copy(k, 0, 0, m.length);
    for (var j = 0, N = c[B], q = Math.ceil(M / N), D = 1; D <= q; D++) {
      k.writeUInt32BE(D, m.length);
      for (var re = I.run(k, I.ipad1), te = re, oe = 1; oe < E; oe++) {
        te = I.run(te, I.ipad2);
        for (var U = 0; U < N; U++)
          re[U] ^= te[U];
      }
      re.copy(T, j), j += N;
    }
    return T;
  }
  return Ps = b, Ps;
}
var Cs, Od;
function v5() {
  if (Od)
    return Cs;
  Od = 1;
  var e = At().Buffer, t = Xb(), n = Yb(), i = ey(), s = Qb(), r, o = Ze.crypto && Ze.crypto.subtle, u = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, c = [];
  function h(E) {
    if (Ze.process && !Ze.process.browser || !o || !o.importKey || !o.deriveBits)
      return Promise.resolve(!1);
    if (c[E] !== void 0)
      return c[E];
    r = r || e.alloc(8);
    var M = v(r, r, 10, 128, E).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return c[E] = M, M;
  }
  var f;
  function b() {
    return f || (Ze.process && Ze.process.nextTick ? f = Ze.process.nextTick : Ze.queueMicrotask ? f = Ze.queueMicrotask : Ze.setImmediate ? f = Ze.setImmediate : f = Ze.setTimeout, f);
  }
  function v(E, M, B, I, T) {
    return o.importKey(
      "raw",
      E,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(k) {
      return o.deriveBits({
        name: "PBKDF2",
        salt: M,
        iterations: B,
        hash: {
          name: T
        }
      }, k, I << 3);
    }).then(function(k) {
      return e.from(k);
    });
  }
  function m(E, M) {
    E.then(function(B) {
      b()(function() {
        M(null, B);
      });
    }, function(B) {
      b()(function() {
        M(B);
      });
    });
  }
  return Cs = function(E, M, B, I, T, k) {
    typeof T == "function" && (k = T, T = void 0), T = T || "sha1";
    var j = u[T.toLowerCase()];
    if (!j || typeof Ze.Promise != "function") {
      b()(function() {
        var N;
        try {
          N = i(E, M, B, I, T);
        } catch (q) {
          return k(q);
        }
        k(null, N);
      });
      return;
    }
    if (t(B, I), E = s(E, n, "Password"), M = s(M, n, "Salt"), typeof k != "function")
      throw new Error("No callback provided to pbkdf2");
    m(h(j).then(function(N) {
      return N ? v(E, M, B, I, j) : i(E, M, B, I, T);
    }), k);
  }, Cs;
}
var Pd;
function ty() {
  return Pd || (Pd = 1, fa.pbkdf2 = v5(), fa.pbkdf2Sync = ey()), fa;
}
var gr = {}, mn = {}, cr = {}, Cd;
function ry() {
  if (Cd)
    return cr;
  Cd = 1, cr.readUInt32BE = function(s, r) {
    var o = s[0 + r] << 24 | s[1 + r] << 16 | s[2 + r] << 8 | s[3 + r];
    return o >>> 0;
  }, cr.writeUInt32BE = function(s, r, o) {
    s[0 + o] = r >>> 24, s[1 + o] = r >>> 16 & 255, s[2 + o] = r >>> 8 & 255, s[3 + o] = r & 255;
  }, cr.ip = function(s, r, o, u) {
    for (var c = 0, h = 0, f = 6; f >= 0; f -= 2) {
      for (var b = 0; b <= 24; b += 8)
        c <<= 1, c |= r >>> b + f & 1;
      for (var b = 0; b <= 24; b += 8)
        c <<= 1, c |= s >>> b + f & 1;
    }
    for (var f = 6; f >= 0; f -= 2) {
      for (var b = 1; b <= 25; b += 8)
        h <<= 1, h |= r >>> b + f & 1;
      for (var b = 1; b <= 25; b += 8)
        h <<= 1, h |= s >>> b + f & 1;
    }
    o[u + 0] = c >>> 0, o[u + 1] = h >>> 0;
  }, cr.rip = function(s, r, o, u) {
    for (var c = 0, h = 0, f = 0; f < 4; f++)
      for (var b = 24; b >= 0; b -= 8)
        c <<= 1, c |= r >>> b + f & 1, c <<= 1, c |= s >>> b + f & 1;
    for (var f = 4; f < 8; f++)
      for (var b = 24; b >= 0; b -= 8)
        h <<= 1, h |= r >>> b + f & 1, h <<= 1, h |= s >>> b + f & 1;
    o[u + 0] = c >>> 0, o[u + 1] = h >>> 0;
  }, cr.pc1 = function(s, r, o, u) {
    for (var c = 0, h = 0, f = 7; f >= 5; f--) {
      for (var b = 0; b <= 24; b += 8)
        c <<= 1, c |= r >> b + f & 1;
      for (var b = 0; b <= 24; b += 8)
        c <<= 1, c |= s >> b + f & 1;
    }
    for (var b = 0; b <= 24; b += 8)
      c <<= 1, c |= r >> b + f & 1;
    for (var f = 1; f <= 3; f++) {
      for (var b = 0; b <= 24; b += 8)
        h <<= 1, h |= r >> b + f & 1;
      for (var b = 0; b <= 24; b += 8)
        h <<= 1, h |= s >> b + f & 1;
    }
    for (var b = 0; b <= 24; b += 8)
      h <<= 1, h |= s >> b + f & 1;
    o[u + 0] = c >>> 0, o[u + 1] = h >>> 0;
  }, cr.r28shl = function(s, r) {
    return s << r & 268435455 | s >>> 28 - r;
  };
  var e = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  cr.pc2 = function(s, r, o, u) {
    for (var c = 0, h = 0, f = e.length >>> 1, b = 0; b < f; b++)
      c <<= 1, c |= s >>> e[b] & 1;
    for (var b = f; b < e.length; b++)
      h <<= 1, h |= r >>> e[b] & 1;
    o[u + 0] = c >>> 0, o[u + 1] = h >>> 0;
  }, cr.expand = function(s, r, o) {
    var u = 0, c = 0;
    u = (s & 1) << 5 | s >>> 27;
    for (var h = 23; h >= 15; h -= 4)
      u <<= 6, u |= s >>> h & 63;
    for (var h = 11; h >= 3; h -= 4)
      c |= s >>> h & 63, c <<= 6;
    c |= (s & 31) << 1 | s >>> 31, r[o + 0] = u >>> 0, r[o + 1] = c >>> 0;
  };
  var t = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  cr.substitute = function(s, r) {
    for (var o = 0, u = 0; u < 4; u++) {
      var c = s >>> 18 - u * 6 & 63, h = t[u * 64 + c];
      o <<= 4, o |= h;
    }
    for (var u = 0; u < 4; u++) {
      var c = r >>> 18 - u * 6 & 63, h = t[4 * 64 + u * 64 + c];
      o <<= 4, o |= h;
    }
    return o >>> 0;
  };
  var n = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return cr.permute = function(s) {
    for (var r = 0, o = 0; o < n.length; o++)
      r <<= 1, r |= s >>> n[o] & 1;
    return r >>> 0;
  }, cr.padSplit = function(s, r, o) {
    for (var u = s.toString(2); u.length < r; )
      u = "0" + u;
    for (var c = [], h = 0; h < r; h += o)
      c.push(u.slice(h, h + o));
    return c.join(" ");
  }, cr;
}
var Ns, Nd;
function Tr() {
  if (Nd)
    return Ns;
  Nd = 1, Ns = e;
  function e(t, n) {
    if (!t)
      throw new Error(n || "Assertion failed");
  }
  return e.equal = function(n, i, s) {
    if (n != i)
      throw new Error(s || "Assertion failed: " + n + " != " + i);
  }, Ns;
}
var Ls, Ld;
function p0() {
  if (Ld)
    return Ls;
  Ld = 1;
  var e = Tr();
  function t(n) {
    this.options = n, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = n.padding !== !1;
  }
  return Ls = t, t.prototype._init = function() {
  }, t.prototype.update = function(i) {
    return i.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(i) : this._updateEncrypt(i);
  }, t.prototype._buffer = function(i, s) {
    for (var r = Math.min(this.buffer.length - this.bufferOff, i.length - s), o = 0; o < r; o++)
      this.buffer[this.bufferOff + o] = i[s + o];
    return this.bufferOff += r, r;
  }, t.prototype._flushBuffer = function(i, s) {
    return this._update(this.buffer, 0, i, s), this.bufferOff = 0, this.blockSize;
  }, t.prototype._updateEncrypt = function(i) {
    var s = 0, r = 0, o = (this.bufferOff + i.length) / this.blockSize | 0, u = new Array(o * this.blockSize);
    this.bufferOff !== 0 && (s += this._buffer(i, s), this.bufferOff === this.buffer.length && (r += this._flushBuffer(u, r)));
    for (var c = i.length - (i.length - s) % this.blockSize; s < c; s += this.blockSize)
      this._update(i, s, u, r), r += this.blockSize;
    for (; s < i.length; s++, this.bufferOff++)
      this.buffer[this.bufferOff] = i[s];
    return u;
  }, t.prototype._updateDecrypt = function(i) {
    for (var s = 0, r = 0, o = Math.ceil((this.bufferOff + i.length) / this.blockSize) - 1, u = new Array(o * this.blockSize); o > 0; o--)
      s += this._buffer(i, s), r += this._flushBuffer(u, r);
    return s += this._buffer(i, s), u;
  }, t.prototype.final = function(i) {
    var s;
    i && (s = this.update(i));
    var r;
    return this.type === "encrypt" ? r = this._finalEncrypt() : r = this._finalDecrypt(), s ? s.concat(r) : r;
  }, t.prototype._pad = function(i, s) {
    if (s === 0)
      return !1;
    for (; s < i.length; )
      i[s++] = 0;
    return !0;
  }, t.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var i = new Array(this.blockSize);
    return this._update(this.buffer, 0, i, 0), i;
  }, t.prototype._unpad = function(i) {
    return i;
  }, t.prototype._finalDecrypt = function() {
    e.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var i = new Array(this.blockSize);
    return this._flushBuffer(i, 0), this._unpad(i);
  }, Ls;
}
var ks, kd;
function ny() {
  if (kd)
    return ks;
  kd = 1;
  var e = Tr(), t = mt(), n = ry(), i = p0();
  function s() {
    this.tmp = new Array(2), this.keys = null;
  }
  function r(u) {
    i.call(this, u);
    var c = new s();
    this._desState = c, this.deriveKeys(c, u.key);
  }
  t(r, i), ks = r, r.create = function(c) {
    return new r(c);
  };
  var o = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return r.prototype.deriveKeys = function(c, h) {
    c.keys = new Array(16 * 2), e.equal(h.length, this.blockSize, "Invalid key length");
    var f = n.readUInt32BE(h, 0), b = n.readUInt32BE(h, 4);
    n.pc1(f, b, c.tmp, 0), f = c.tmp[0], b = c.tmp[1];
    for (var v = 0; v < c.keys.length; v += 2) {
      var m = o[v >>> 1];
      f = n.r28shl(f, m), b = n.r28shl(b, m), n.pc2(f, b, c.keys, v);
    }
  }, r.prototype._update = function(c, h, f, b) {
    var v = this._desState, m = n.readUInt32BE(c, h), E = n.readUInt32BE(c, h + 4);
    n.ip(m, E, v.tmp, 0), m = v.tmp[0], E = v.tmp[1], this.type === "encrypt" ? this._encrypt(v, m, E, v.tmp, 0) : this._decrypt(v, m, E, v.tmp, 0), m = v.tmp[0], E = v.tmp[1], n.writeUInt32BE(f, m, b), n.writeUInt32BE(f, E, b + 4);
  }, r.prototype._pad = function(c, h) {
    if (this.padding === !1)
      return !1;
    for (var f = c.length - h, b = h; b < c.length; b++)
      c[b] = f;
    return !0;
  }, r.prototype._unpad = function(c) {
    if (this.padding === !1)
      return c;
    for (var h = c[c.length - 1], f = c.length - h; f < c.length; f++)
      e.equal(c[f], h);
    return c.slice(0, c.length - h);
  }, r.prototype._encrypt = function(c, h, f, b, v) {
    for (var m = h, E = f, M = 0; M < c.keys.length; M += 2) {
      var B = c.keys[M], I = c.keys[M + 1];
      n.expand(E, c.tmp, 0), B ^= c.tmp[0], I ^= c.tmp[1];
      var T = n.substitute(B, I), k = n.permute(T), j = E;
      E = (m ^ k) >>> 0, m = j;
    }
    n.rip(E, m, b, v);
  }, r.prototype._decrypt = function(c, h, f, b, v) {
    for (var m = f, E = h, M = c.keys.length - 2; M >= 0; M -= 2) {
      var B = c.keys[M], I = c.keys[M + 1];
      n.expand(m, c.tmp, 0), B ^= c.tmp[0], I ^= c.tmp[1];
      var T = n.substitute(B, I), k = n.permute(T), j = m;
      m = (E ^ k) >>> 0, E = j;
    }
    n.rip(m, E, b, v);
  }, ks;
}
var js = {}, jd;
function b5() {
  if (jd)
    return js;
  jd = 1;
  var e = Tr(), t = mt(), n = {};
  function i(r) {
    e.equal(r.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var o = 0; o < this.iv.length; o++)
      this.iv[o] = r[o];
  }
  function s(r) {
    function o(f) {
      r.call(this, f), this._cbcInit();
    }
    t(o, r);
    for (var u = Object.keys(n), c = 0; c < u.length; c++) {
      var h = u[c];
      o.prototype[h] = n[h];
    }
    return o.create = function(b) {
      return new o(b);
    }, o;
  }
  return js.instantiate = s, n._cbcInit = function() {
    var o = new i(this.options.iv);
    this._cbcState = o;
  }, n._update = function(o, u, c, h) {
    var f = this._cbcState, b = this.constructor.super_.prototype, v = f.iv;
    if (this.type === "encrypt") {
      for (var m = 0; m < this.blockSize; m++)
        v[m] ^= o[u + m];
      b._update.call(this, v, 0, c, h);
      for (var m = 0; m < this.blockSize; m++)
        v[m] = c[h + m];
    } else {
      b._update.call(this, o, u, c, h);
      for (var m = 0; m < this.blockSize; m++)
        c[h + m] ^= v[m];
      for (var m = 0; m < this.blockSize; m++)
        v[m] = o[u + m];
    }
  }, js;
}
var qs, qd;
function y5() {
  if (qd)
    return qs;
  qd = 1;
  var e = Tr(), t = mt(), n = p0(), i = ny();
  function s(o, u) {
    e.equal(u.length, 24, "Invalid key length");
    var c = u.slice(0, 8), h = u.slice(8, 16), f = u.slice(16, 24);
    o === "encrypt" ? this.ciphers = [
      i.create({ type: "encrypt", key: c }),
      i.create({ type: "decrypt", key: h }),
      i.create({ type: "encrypt", key: f })
    ] : this.ciphers = [
      i.create({ type: "decrypt", key: f }),
      i.create({ type: "encrypt", key: h }),
      i.create({ type: "decrypt", key: c })
    ];
  }
  function r(o) {
    n.call(this, o);
    var u = new s(this.type, this.options.key);
    this._edeState = u;
  }
  return t(r, n), qs = r, r.create = function(u) {
    return new r(u);
  }, r.prototype._update = function(u, c, h, f) {
    var b = this._edeState;
    b.ciphers[0]._update(u, c, h, f), b.ciphers[1]._update(h, f, h, f), b.ciphers[2]._update(h, f, h, f);
  }, r.prototype._pad = i.prototype._pad, r.prototype._unpad = i.prototype._unpad, qs;
}
var Dd;
function g5() {
  return Dd || (Dd = 1, mn.utils = ry(), mn.Cipher = p0(), mn.DES = ny(), mn.CBC = b5(), mn.EDE = y5()), mn;
}
var Ds, $d;
function m5() {
  if ($d)
    return Ds;
  $d = 1;
  var e = yn(), t = g5(), n = mt(), i = At().Buffer, s = {
    "des-ede3-cbc": t.CBC.instantiate(t.EDE),
    "des-ede3": t.EDE,
    "des-ede-cbc": t.CBC.instantiate(t.EDE),
    "des-ede": t.EDE,
    "des-cbc": t.CBC.instantiate(t.DES),
    "des-ecb": t.DES
  };
  s.des = s["des-cbc"], s.des3 = s["des-ede3-cbc"], Ds = r, n(r, e);
  function r(o) {
    e.call(this);
    var u = o.mode.toLowerCase(), c = s[u], h;
    o.decrypt ? h = "decrypt" : h = "encrypt";
    var f = o.key;
    i.isBuffer(f) || (f = i.from(f)), (u === "des-ede" || u === "des-ede-cbc") && (f = i.concat([f, f.slice(0, 8)]));
    var b = o.iv;
    i.isBuffer(b) || (b = i.from(b)), this._des = c.create({
      key: f,
      iv: b,
      type: h
    });
  }
  return r.prototype._update = function(o) {
    return i.from(this._des.update(o));
  }, r.prototype._final = function() {
    return i.from(this._des.final());
  }, Ds;
}
var mr = {}, oa = {}, sa = {}, Ud;
function _5() {
  return Ud || (Ud = 1, sa.encrypt = function(e, t) {
    return e._cipher.encryptBlock(t);
  }, sa.decrypt = function(e, t) {
    return e._cipher.decryptBlock(t);
  }), sa;
}
var ua = {}, $s, Fd;
function Hi() {
  return Fd || (Fd = 1, $s = function(t, n) {
    for (var i = Math.min(t.length, n.length), s = new Buffer(i), r = 0; r < i; ++r)
      s[r] = t[r] ^ n[r];
    return s;
  }), $s;
}
var Hd;
function w5() {
  if (Hd)
    return ua;
  Hd = 1;
  var e = Hi();
  return ua.encrypt = function(t, n) {
    var i = e(n, t._prev);
    return t._prev = t._cipher.encryptBlock(i), t._prev;
  }, ua.decrypt = function(t, n) {
    var i = t._prev;
    t._prev = n;
    var s = t._cipher.decryptBlock(n);
    return e(s, i);
  }, ua;
}
var Us = {}, zd;
function x5() {
  if (zd)
    return Us;
  zd = 1;
  var e = At().Buffer, t = Hi();
  function n(i, s, r) {
    var o = s.length, u = t(s, i._cache);
    return i._cache = i._cache.slice(o), i._prev = e.concat([i._prev, r ? s : u]), u;
  }
  return Us.encrypt = function(i, s, r) {
    for (var o = e.allocUnsafe(0), u; s.length; )
      if (i._cache.length === 0 && (i._cache = i._cipher.encryptBlock(i._prev), i._prev = e.allocUnsafe(0)), i._cache.length <= s.length)
        u = i._cache.length, o = e.concat([o, n(i, s.slice(0, u), r)]), s = s.slice(u);
      else {
        o = e.concat([o, n(i, s, r)]);
        break;
      }
    return o;
  }, Us;
}
var Fs = {}, Vd;
function E5() {
  if (Vd)
    return Fs;
  Vd = 1;
  var e = At().Buffer;
  function t(n, i, s) {
    var r = n._cipher.encryptBlock(n._prev), o = r[0] ^ i;
    return n._prev = e.concat([
      n._prev.slice(1),
      e.from([s ? i : o])
    ]), o;
  }
  return Fs.encrypt = function(n, i, s) {
    for (var r = i.length, o = e.allocUnsafe(r), u = -1; ++u < r; )
      o[u] = t(n, i[u], s);
    return o;
  }, Fs;
}
var Hs = {}, Kd;
function S5() {
  if (Kd)
    return Hs;
  Kd = 1;
  var e = At().Buffer;
  function t(i, s, r) {
    for (var o, u = -1, c = 8, h = 0, f, b; ++u < c; )
      o = i._cipher.encryptBlock(i._prev), f = s & 1 << 7 - u ? 128 : 0, b = o[0] ^ f, h += (b & 128) >> u % 8, i._prev = n(i._prev, r ? f : b);
    return h;
  }
  function n(i, s) {
    var r = i.length, o = -1, u = e.allocUnsafe(i.length);
    for (i = e.concat([i, e.from([s])]); ++o < r; )
      u[o] = i[o] << 1 | i[o + 1] >> 7;
    return u;
  }
  return Hs.encrypt = function(i, s, r) {
    for (var o = s.length, u = e.allocUnsafe(o), c = -1; ++c < o; )
      u[c] = t(i, s[c], r);
    return u;
  }, Hs;
}
var zs = {}, Zd;
function A5() {
  if (Zd)
    return zs;
  Zd = 1;
  var e = Hi();
  function t(n) {
    return n._prev = n._cipher.encryptBlock(n._prev), n._prev;
  }
  return zs.encrypt = function(n, i) {
    for (; n._cache.length < i.length; )
      n._cache = Buffer.concat([n._cache, t(n)]);
    var s = n._cache.slice(0, i.length);
    return n._cache = n._cache.slice(i.length), e(i, s);
  }, zs;
}
var Vs = {}, Ks, Gd;
function iy() {
  if (Gd)
    return Ks;
  Gd = 1;
  function e(t) {
    for (var n = t.length, i; n--; )
      if (i = t.readUInt8(n), i === 255)
        t.writeUInt8(0, n);
      else {
        i++, t.writeUInt8(i, n);
        break;
      }
  }
  return Ks = e, Ks;
}
var Wd;
function Jd() {
  if (Wd)
    return Vs;
  Wd = 1;
  var e = Hi(), t = At().Buffer, n = iy();
  function i(r) {
    var o = r._cipher.encryptBlockRaw(r._prev);
    return n(r._prev), o;
  }
  var s = 16;
  return Vs.encrypt = function(r, o) {
    var u = Math.ceil(o.length / s), c = r._cache.length;
    r._cache = t.concat([
      r._cache,
      t.allocUnsafe(u * s)
    ]);
    for (var h = 0; h < u; h++) {
      var f = i(r), b = c + h * s;
      r._cache.writeUInt32BE(f[0], b + 0), r._cache.writeUInt32BE(f[1], b + 4), r._cache.writeUInt32BE(f[2], b + 8), r._cache.writeUInt32BE(f[3], b + 12);
    }
    var v = r._cache.slice(0, o.length);
    return r._cache = r._cache.slice(o.length), e(o, v);
  }, Vs;
}
const M5 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, R5 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, B5 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, ay = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128: M5,
  aes192: R5,
  aes256: B5,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var Zs, Xd;
function v0() {
  if (Xd)
    return Zs;
  Xd = 1;
  var e = {
    ECB: _5(),
    CBC: w5(),
    CFB: x5(),
    CFB8: E5(),
    CFB1: S5(),
    OFB: A5(),
    CTR: Jd(),
    GCM: Jd()
  }, t = ay;
  for (var n in t)
    t[n].module = e[t[n].mode];
  return Zs = t, Zs;
}
var Gs = {}, Yd;
function mf() {
  if (Yd)
    return Gs;
  Yd = 1;
  var e = At().Buffer;
  function t(u) {
    e.isBuffer(u) || (u = e.from(u));
    for (var c = u.length / 4 | 0, h = new Array(c), f = 0; f < c; f++)
      h[f] = u.readUInt32BE(f * 4);
    return h;
  }
  function n(u) {
    for (var c = 0; c < u.length; u++)
      u[c] = 0;
  }
  function i(u, c, h, f, b) {
    for (var v = h[0], m = h[1], E = h[2], M = h[3], B = u[0] ^ c[0], I = u[1] ^ c[1], T = u[2] ^ c[2], k = u[3] ^ c[3], j, N, q, D, re = 4, te = 1; te < b; te++)
      j = v[B >>> 24] ^ m[I >>> 16 & 255] ^ E[T >>> 8 & 255] ^ M[k & 255] ^ c[re++], N = v[I >>> 24] ^ m[T >>> 16 & 255] ^ E[k >>> 8 & 255] ^ M[B & 255] ^ c[re++], q = v[T >>> 24] ^ m[k >>> 16 & 255] ^ E[B >>> 8 & 255] ^ M[I & 255] ^ c[re++], D = v[k >>> 24] ^ m[B >>> 16 & 255] ^ E[I >>> 8 & 255] ^ M[T & 255] ^ c[re++], B = j, I = N, T = q, k = D;
    return j = (f[B >>> 24] << 24 | f[I >>> 16 & 255] << 16 | f[T >>> 8 & 255] << 8 | f[k & 255]) ^ c[re++], N = (f[I >>> 24] << 24 | f[T >>> 16 & 255] << 16 | f[k >>> 8 & 255] << 8 | f[B & 255]) ^ c[re++], q = (f[T >>> 24] << 24 | f[k >>> 16 & 255] << 16 | f[B >>> 8 & 255] << 8 | f[I & 255]) ^ c[re++], D = (f[k >>> 24] << 24 | f[B >>> 16 & 255] << 16 | f[I >>> 8 & 255] << 8 | f[T & 255]) ^ c[re++], j = j >>> 0, N = N >>> 0, q = q >>> 0, D = D >>> 0, [j, N, q, D];
  }
  var s = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], r = function() {
    for (var u = new Array(256), c = 0; c < 256; c++)
      c < 128 ? u[c] = c << 1 : u[c] = c << 1 ^ 283;
    for (var h = [], f = [], b = [[], [], [], []], v = [[], [], [], []], m = 0, E = 0, M = 0; M < 256; ++M) {
      var B = E ^ E << 1 ^ E << 2 ^ E << 3 ^ E << 4;
      B = B >>> 8 ^ B & 255 ^ 99, h[m] = B, f[B] = m;
      var I = u[m], T = u[I], k = u[T], j = u[B] * 257 ^ B * 16843008;
      b[0][m] = j << 24 | j >>> 8, b[1][m] = j << 16 | j >>> 16, b[2][m] = j << 8 | j >>> 24, b[3][m] = j, j = k * 16843009 ^ T * 65537 ^ I * 257 ^ m * 16843008, v[0][B] = j << 24 | j >>> 8, v[1][B] = j << 16 | j >>> 16, v[2][B] = j << 8 | j >>> 24, v[3][B] = j, m === 0 ? m = E = 1 : (m = I ^ u[u[u[k ^ I]]], E ^= u[u[E]]);
    }
    return {
      SBOX: h,
      INV_SBOX: f,
      SUB_MIX: b,
      INV_SUB_MIX: v
    };
  }();
  function o(u) {
    this._key = t(u), this._reset();
  }
  return o.blockSize = 4 * 4, o.keySize = 256 / 8, o.prototype.blockSize = o.blockSize, o.prototype.keySize = o.keySize, o.prototype._reset = function() {
    for (var u = this._key, c = u.length, h = c + 6, f = (h + 1) * 4, b = [], v = 0; v < c; v++)
      b[v] = u[v];
    for (v = c; v < f; v++) {
      var m = b[v - 1];
      v % c === 0 ? (m = m << 8 | m >>> 24, m = r.SBOX[m >>> 24] << 24 | r.SBOX[m >>> 16 & 255] << 16 | r.SBOX[m >>> 8 & 255] << 8 | r.SBOX[m & 255], m ^= s[v / c | 0] << 24) : c > 6 && v % c === 4 && (m = r.SBOX[m >>> 24] << 24 | r.SBOX[m >>> 16 & 255] << 16 | r.SBOX[m >>> 8 & 255] << 8 | r.SBOX[m & 255]), b[v] = b[v - c] ^ m;
    }
    for (var E = [], M = 0; M < f; M++) {
      var B = f - M, I = b[B - (M % 4 ? 0 : 4)];
      M < 4 || B <= 4 ? E[M] = I : E[M] = r.INV_SUB_MIX[0][r.SBOX[I >>> 24]] ^ r.INV_SUB_MIX[1][r.SBOX[I >>> 16 & 255]] ^ r.INV_SUB_MIX[2][r.SBOX[I >>> 8 & 255]] ^ r.INV_SUB_MIX[3][r.SBOX[I & 255]];
    }
    this._nRounds = h, this._keySchedule = b, this._invKeySchedule = E;
  }, o.prototype.encryptBlockRaw = function(u) {
    return u = t(u), i(u, this._keySchedule, r.SUB_MIX, r.SBOX, this._nRounds);
  }, o.prototype.encryptBlock = function(u) {
    var c = this.encryptBlockRaw(u), h = e.allocUnsafe(16);
    return h.writeUInt32BE(c[0], 0), h.writeUInt32BE(c[1], 4), h.writeUInt32BE(c[2], 8), h.writeUInt32BE(c[3], 12), h;
  }, o.prototype.decryptBlock = function(u) {
    u = t(u);
    var c = u[1];
    u[1] = u[3], u[3] = c;
    var h = i(u, this._invKeySchedule, r.INV_SUB_MIX, r.INV_SBOX, this._nRounds), f = e.allocUnsafe(16);
    return f.writeUInt32BE(h[0], 0), f.writeUInt32BE(h[3], 4), f.writeUInt32BE(h[2], 8), f.writeUInt32BE(h[1], 12), f;
  }, o.prototype.scrub = function() {
    n(this._keySchedule), n(this._invKeySchedule), n(this._key);
  }, Gs.AES = o, Gs;
}
var Ws, Qd;
function I5() {
  if (Qd)
    return Ws;
  Qd = 1;
  var e = At().Buffer, t = e.alloc(16, 0);
  function n(r) {
    return [
      r.readUInt32BE(0),
      r.readUInt32BE(4),
      r.readUInt32BE(8),
      r.readUInt32BE(12)
    ];
  }
  function i(r) {
    var o = e.allocUnsafe(16);
    return o.writeUInt32BE(r[0] >>> 0, 0), o.writeUInt32BE(r[1] >>> 0, 4), o.writeUInt32BE(r[2] >>> 0, 8), o.writeUInt32BE(r[3] >>> 0, 12), o;
  }
  function s(r) {
    this.h = r, this.state = e.alloc(16, 0), this.cache = e.allocUnsafe(0);
  }
  return s.prototype.ghash = function(r) {
    for (var o = -1; ++o < r.length; )
      this.state[o] ^= r[o];
    this._multiply();
  }, s.prototype._multiply = function() {
    for (var r = n(this.h), o = [0, 0, 0, 0], u, c, h, f = -1; ++f < 128; ) {
      for (c = (this.state[~~(f / 8)] & 1 << 7 - f % 8) !== 0, c && (o[0] ^= r[0], o[1] ^= r[1], o[2] ^= r[2], o[3] ^= r[3]), h = (r[3] & 1) !== 0, u = 3; u > 0; u--)
        r[u] = r[u] >>> 1 | (r[u - 1] & 1) << 31;
      r[0] = r[0] >>> 1, h && (r[0] = r[0] ^ 225 << 24);
    }
    this.state = i(o);
  }, s.prototype.update = function(r) {
    this.cache = e.concat([this.cache, r]);
    for (var o; this.cache.length >= 16; )
      o = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(o);
  }, s.prototype.final = function(r, o) {
    return this.cache.length && this.ghash(e.concat([this.cache, t], 16)), this.ghash(i([0, r, 0, o])), this.state;
  }, Ws = s, Ws;
}
var Js, e1;
function fy() {
  if (e1)
    return Js;
  e1 = 1;
  var e = mf(), t = At().Buffer, n = yn(), i = mt(), s = I5(), r = Hi(), o = iy();
  function u(f, b) {
    var v = 0;
    f.length !== b.length && v++;
    for (var m = Math.min(f.length, b.length), E = 0; E < m; ++E)
      v += f[E] ^ b[E];
    return v;
  }
  function c(f, b, v) {
    if (b.length === 12)
      return f._finID = t.concat([b, t.from([0, 0, 0, 1])]), t.concat([b, t.from([0, 0, 0, 2])]);
    var m = new s(v), E = b.length, M = E % 16;
    m.update(b), M && (M = 16 - M, m.update(t.alloc(M, 0))), m.update(t.alloc(8, 0));
    var B = E * 8, I = t.alloc(8);
    I.writeUIntBE(B, 0, 8), m.update(I), f._finID = m.state;
    var T = t.from(f._finID);
    return o(T), T;
  }
  function h(f, b, v, m) {
    n.call(this);
    var E = t.alloc(4, 0);
    this._cipher = new e.AES(b);
    var M = this._cipher.encryptBlock(E);
    this._ghash = new s(M), v = c(this, v, M), this._prev = t.from(v), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = m, this._alen = 0, this._len = 0, this._mode = f, this._authTag = null, this._called = !1;
  }
  return i(h, n), h.prototype._update = function(f) {
    if (!this._called && this._alen) {
      var b = 16 - this._alen % 16;
      b < 16 && (b = t.alloc(b, 0), this._ghash.update(b));
    }
    this._called = !0;
    var v = this._mode.encrypt(this, f);
    return this._decrypt ? this._ghash.update(f) : this._ghash.update(v), this._len += f.length, v;
  }, h.prototype._final = function() {
    if (this._decrypt && !this._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var f = r(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && u(f, this._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = f, this._cipher.scrub();
  }, h.prototype.getAuthTag = function() {
    if (this._decrypt || !t.isBuffer(this._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, h.prototype.setAuthTag = function(b) {
    if (!this._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = b;
  }, h.prototype.setAAD = function(b) {
    if (this._called)
      throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(b), this._alen += b.length;
  }, Js = h, Js;
}
var Xs, t1;
function oy() {
  if (t1)
    return Xs;
  t1 = 1;
  var e = mf(), t = At().Buffer, n = yn(), i = mt();
  function s(r, o, u, c) {
    n.call(this), this._cipher = new e.AES(o), this._prev = t.from(u), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = c, this._mode = r;
  }
  return i(s, n), s.prototype._update = function(r) {
    return this._mode.encrypt(this, r, this._decrypt);
  }, s.prototype._final = function() {
    this._cipher.scrub();
  }, Xs = s, Xs;
}
var Ys, r1;
function _f() {
  if (r1)
    return Ys;
  r1 = 1;
  var e = At().Buffer, t = h0();
  function n(i, s, r, o) {
    if (e.isBuffer(i) || (i = e.from(i, "binary")), s && (e.isBuffer(s) || (s = e.from(s, "binary")), s.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var u = r / 8, c = e.alloc(u), h = e.alloc(o || 0), f = e.alloc(0); u > 0 || o > 0; ) {
      var b = new t();
      b.update(f), b.update(i), s && b.update(s), f = b.digest();
      var v = 0;
      if (u > 0) {
        var m = c.length - u;
        v = Math.min(u, f.length), f.copy(c, m, 0, v), u -= v;
      }
      if (v < f.length && o > 0) {
        var E = h.length - o, M = Math.min(o, f.length - v);
        f.copy(h, E, v, v + M), o -= M;
      }
    }
    return f.fill(0), { key: c, iv: h };
  }
  return Ys = n, Ys;
}
var n1;
function T5() {
  if (n1)
    return oa;
  n1 = 1;
  var e = v0(), t = fy(), n = At().Buffer, i = oy(), s = yn(), r = mf(), o = _f(), u = mt();
  function c(m, E, M) {
    s.call(this), this._cache = new f(), this._cipher = new r.AES(E), this._prev = n.from(M), this._mode = m, this._autopadding = !0;
  }
  u(c, s), c.prototype._update = function(m) {
    this._cache.add(m);
    for (var E, M, B = []; E = this._cache.get(); )
      M = this._mode.encrypt(this, E), B.push(M);
    return n.concat(B);
  };
  var h = n.alloc(16, 16);
  c.prototype._final = function() {
    var m = this._cache.flush();
    if (this._autopadding)
      return m = this._mode.encrypt(this, m), this._cipher.scrub(), m;
    if (!m.equals(h))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, c.prototype.setAutoPadding = function(m) {
    return this._autopadding = !!m, this;
  };
  function f() {
    this.cache = n.allocUnsafe(0);
  }
  f.prototype.add = function(m) {
    this.cache = n.concat([this.cache, m]);
  }, f.prototype.get = function() {
    if (this.cache.length > 15) {
      var m = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), m;
    }
    return null;
  }, f.prototype.flush = function() {
    for (var m = 16 - this.cache.length, E = n.allocUnsafe(m), M = -1; ++M < m; )
      E.writeUInt8(m, M);
    return n.concat([this.cache, E]);
  };
  function b(m, E, M) {
    var B = e[m.toLowerCase()];
    if (!B)
      throw new TypeError("invalid suite type");
    if (typeof E == "string" && (E = n.from(E)), E.length !== B.key / 8)
      throw new TypeError("invalid key length " + E.length);
    if (typeof M == "string" && (M = n.from(M)), B.mode !== "GCM" && M.length !== B.iv)
      throw new TypeError("invalid iv length " + M.length);
    return B.type === "stream" ? new i(B.module, E, M) : B.type === "auth" ? new t(B.module, E, M) : new c(B.module, E, M);
  }
  function v(m, E) {
    var M = e[m.toLowerCase()];
    if (!M)
      throw new TypeError("invalid suite type");
    var B = o(E, !1, M.key, M.iv);
    return b(m, B.key, B.iv);
  }
  return oa.createCipheriv = b, oa.createCipher = v, oa;
}
var ca = {}, i1;
function O5() {
  if (i1)
    return ca;
  i1 = 1;
  var e = fy(), t = At().Buffer, n = v0(), i = oy(), s = yn(), r = mf(), o = _f(), u = mt();
  function c(m, E, M) {
    s.call(this), this._cache = new h(), this._last = void 0, this._cipher = new r.AES(E), this._prev = t.from(M), this._mode = m, this._autopadding = !0;
  }
  u(c, s), c.prototype._update = function(m) {
    this._cache.add(m);
    for (var E, M, B = []; E = this._cache.get(this._autopadding); )
      M = this._mode.decrypt(this, E), B.push(M);
    return t.concat(B);
  }, c.prototype._final = function() {
    var m = this._cache.flush();
    if (this._autopadding)
      return f(this._mode.decrypt(this, m));
    if (m)
      throw new Error("data not multiple of block length");
  }, c.prototype.setAutoPadding = function(m) {
    return this._autopadding = !!m, this;
  };
  function h() {
    this.cache = t.allocUnsafe(0);
  }
  h.prototype.add = function(m) {
    this.cache = t.concat([this.cache, m]);
  }, h.prototype.get = function(m) {
    var E;
    if (m) {
      if (this.cache.length > 16)
        return E = this.cache.slice(0, 16), this.cache = this.cache.slice(16), E;
    } else if (this.cache.length >= 16)
      return E = this.cache.slice(0, 16), this.cache = this.cache.slice(16), E;
    return null;
  }, h.prototype.flush = function() {
    if (this.cache.length)
      return this.cache;
  };
  function f(m) {
    var E = m[15];
    if (E < 1 || E > 16)
      throw new Error("unable to decrypt data");
    for (var M = -1; ++M < E; )
      if (m[M + (16 - E)] !== E)
        throw new Error("unable to decrypt data");
    if (E !== 16)
      return m.slice(0, 16 - E);
  }
  function b(m, E, M) {
    var B = n[m.toLowerCase()];
    if (!B)
      throw new TypeError("invalid suite type");
    if (typeof M == "string" && (M = t.from(M)), B.mode !== "GCM" && M.length !== B.iv)
      throw new TypeError("invalid iv length " + M.length);
    if (typeof E == "string" && (E = t.from(E)), E.length !== B.key / 8)
      throw new TypeError("invalid key length " + E.length);
    return B.type === "stream" ? new i(B.module, E, M, !0) : B.type === "auth" ? new e(B.module, E, M, !0) : new c(B.module, E, M);
  }
  function v(m, E) {
    var M = n[m.toLowerCase()];
    if (!M)
      throw new TypeError("invalid suite type");
    var B = o(E, !1, M.key, M.iv);
    return b(m, B.key, B.iv);
  }
  return ca.createDecipher = v, ca.createDecipheriv = b, ca;
}
var a1;
function b0() {
  if (a1)
    return mr;
  a1 = 1;
  var e = T5(), t = O5(), n = ay;
  function i() {
    return Object.keys(n);
  }
  return mr.createCipher = mr.Cipher = e.createCipher, mr.createCipheriv = mr.Cipheriv = e.createCipheriv, mr.createDecipher = mr.Decipher = t.createDecipher, mr.createDecipheriv = mr.Decipheriv = t.createDecipheriv, mr.listCiphers = mr.getCiphers = i, mr;
}
var Qs = {}, f1;
function P5() {
  return f1 || (f1 = 1, function(e) {
    e["des-ecb"] = {
      key: 8,
      iv: 0
    }, e["des-cbc"] = e.des = {
      key: 8,
      iv: 8
    }, e["des-ede3-cbc"] = e.des3 = {
      key: 24,
      iv: 8
    }, e["des-ede3"] = {
      key: 24,
      iv: 0
    }, e["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, e["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(Qs)), Qs;
}
var o1;
function C5() {
  if (o1)
    return gr;
  o1 = 1;
  var e = m5(), t = b0(), n = v0(), i = P5(), s = _f();
  function r(f, b) {
    f = f.toLowerCase();
    var v, m;
    if (n[f])
      v = n[f].key, m = n[f].iv;
    else if (i[f])
      v = i[f].key * 8, m = i[f].iv;
    else
      throw new TypeError("invalid suite type");
    var E = s(b, !1, v, m);
    return u(f, E.key, E.iv);
  }
  function o(f, b) {
    f = f.toLowerCase();
    var v, m;
    if (n[f])
      v = n[f].key, m = n[f].iv;
    else if (i[f])
      v = i[f].key * 8, m = i[f].iv;
    else
      throw new TypeError("invalid suite type");
    var E = s(b, !1, v, m);
    return c(f, E.key, E.iv);
  }
  function u(f, b, v) {
    if (f = f.toLowerCase(), n[f])
      return t.createCipheriv(f, b, v);
    if (i[f])
      return new e({ key: b, iv: v, mode: f });
    throw new TypeError("invalid suite type");
  }
  function c(f, b, v) {
    if (f = f.toLowerCase(), n[f])
      return t.createDecipheriv(f, b, v);
    if (i[f])
      return new e({ key: b, iv: v, mode: f, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function h() {
    return Object.keys(i).concat(t.getCiphers());
  }
  return gr.createCipher = gr.Cipher = r, gr.createCipheriv = gr.Cipheriv = u, gr.createDecipher = gr.Decipher = o, gr.createDecipheriv = gr.Decipheriv = c, gr.listCiphers = gr.getCiphers = h, gr;
}
var _n = {}, ha = { exports: {} }, s1;
function y0() {
  if (s1)
    return ha.exports;
  s1 = 1;
  var e;
  ha.exports = function(s) {
    return e || (e = new t(null)), e.generate(s);
  };
  function t(i) {
    this.rand = i;
  }
  if (ha.exports.Rand = t, t.prototype.generate = function(s) {
    return this._rand(s);
  }, t.prototype._rand = function(s) {
    if (this.rand.getBytes)
      return this.rand.getBytes(s);
    for (var r = new Uint8Array(s), o = 0; o < r.length; o++)
      r[o] = this.rand.getByte();
    return r;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? t.prototype._rand = function(s) {
      var r = new Uint8Array(s);
      return self.crypto.getRandomValues(r), r;
    } : self.msCrypto && self.msCrypto.getRandomValues ? t.prototype._rand = function(s) {
      var r = new Uint8Array(s);
      return self.msCrypto.getRandomValues(r), r;
    } : typeof window == "object" && (t.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var n = Ay();
      if (typeof n.randomBytes != "function")
        throw new Error("Not supported");
      t.prototype._rand = function(s) {
        return n.randomBytes(s);
      };
    } catch {
    }
  return ha.exports;
}
var eu, u1;
function sy() {
  if (u1)
    return eu;
  u1 = 1;
  var e = Wt, t = y0();
  function n(i) {
    this.rand = i || new t.Rand();
  }
  return eu = n, n.create = function(s) {
    return new n(s);
  }, n.prototype._randbelow = function(s) {
    var r = s.bitLength(), o = Math.ceil(r / 8);
    do
      var u = new e(this.rand.generate(o));
    while (u.cmp(s) >= 0);
    return u;
  }, n.prototype._randrange = function(s, r) {
    var o = r.sub(s);
    return s.add(this._randbelow(o));
  }, n.prototype.test = function(s, r, o) {
    var u = s.bitLength(), c = e.mont(s), h = new e(1).toRed(c);
    r || (r = Math.max(1, u / 48 | 0));
    for (var f = s.subn(1), b = 0; !f.testn(b); b++)
      ;
    for (var v = s.shrn(b), m = f.toRed(c), E = !0; r > 0; r--) {
      var M = this._randrange(new e(2), f);
      o && o(M);
      var B = M.toRed(c).redPow(v);
      if (!(B.cmp(h) === 0 || B.cmp(m) === 0)) {
        for (var I = 1; I < b; I++) {
          if (B = B.redSqr(), B.cmp(h) === 0)
            return !1;
          if (B.cmp(m) === 0)
            break;
        }
        if (I === b)
          return !1;
      }
    }
    return E;
  }, n.prototype.getDivisor = function(s, r) {
    var o = s.bitLength(), u = e.mont(s), c = new e(1).toRed(u);
    r || (r = Math.max(1, o / 48 | 0));
    for (var h = s.subn(1), f = 0; !h.testn(f); f++)
      ;
    for (var b = s.shrn(f), v = h.toRed(u); r > 0; r--) {
      var m = this._randrange(new e(2), h), E = s.gcd(m);
      if (E.cmpn(1) !== 0)
        return E;
      var M = m.toRed(u).redPow(b);
      if (!(M.cmp(c) === 0 || M.cmp(v) === 0)) {
        for (var B = 1; B < f; B++) {
          if (M = M.redSqr(), M.cmp(c) === 0)
            return M.fromRed().subn(1).gcd(s);
          if (M.cmp(v) === 0)
            break;
        }
        if (B === f)
          return M = M.redSqr(), M.fromRed().subn(1).gcd(s);
      }
    }
    return !1;
  }, eu;
}
var tu, c1;
function uy() {
  if (c1)
    return tu;
  c1 = 1;
  var e = ci();
  tu = B, B.simpleSieve = E, B.fermatTest = M;
  var t = Wt, n = new t(24), i = sy(), s = new i(), r = new t(1), o = new t(2), u = new t(5);
  new t(16), new t(8);
  var c = new t(10), h = new t(3);
  new t(7);
  var f = new t(11), b = new t(4);
  new t(12);
  var v = null;
  function m() {
    if (v !== null)
      return v;
    var I = 1048576, T = [];
    T[0] = 2;
    for (var k = 1, j = 3; j < I; j += 2) {
      for (var N = Math.ceil(Math.sqrt(j)), q = 0; q < k && T[q] <= N && j % T[q] !== 0; q++)
        ;
      k !== q && T[q] <= N || (T[k++] = j);
    }
    return v = T, T;
  }
  function E(I) {
    for (var T = m(), k = 0; k < T.length; k++)
      if (I.modn(T[k]) === 0)
        return I.cmpn(T[k]) === 0;
    return !0;
  }
  function M(I) {
    var T = t.mont(I);
    return o.toRed(T).redPow(I.subn(1)).fromRed().cmpn(1) === 0;
  }
  function B(I, T) {
    if (I < 16)
      return T === 2 || T === 5 ? new t([140, 123]) : new t([140, 39]);
    T = new t(T);
    for (var k, j; ; ) {
      for (k = new t(e(Math.ceil(I / 8))); k.bitLength() > I; )
        k.ishrn(1);
      if (k.isEven() && k.iadd(r), k.testn(1) || k.iadd(o), T.cmp(o)) {
        if (!T.cmp(u))
          for (; k.mod(c).cmp(h); )
            k.iadd(b);
      } else
        for (; k.mod(n).cmp(f); )
          k.iadd(b);
      if (j = k.shrn(1), E(j) && E(k) && M(j) && M(k) && s.test(j) && s.test(k))
        return k;
    }
  }
  return tu;
}
const N5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, L5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, k5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, j5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, q5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, D5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, $5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, U5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, F5 = {
  modp1: N5,
  modp2: L5,
  modp5: k5,
  modp14: j5,
  modp15: q5,
  modp16: D5,
  modp17: $5,
  modp18: U5
};
var ru, h1;
function H5() {
  if (h1)
    return ru;
  h1 = 1;
  var e = Wt, t = sy(), n = new t(), i = new e(24), s = new e(11), r = new e(10), o = new e(3), u = new e(7), c = uy(), h = ci();
  ru = E;
  function f(B, I) {
    return I = I || "utf8", Buffer.isBuffer(B) || (B = new Buffer(B, I)), this._pub = new e(B), this;
  }
  function b(B, I) {
    return I = I || "utf8", Buffer.isBuffer(B) || (B = new Buffer(B, I)), this._priv = new e(B), this;
  }
  var v = {};
  function m(B, I) {
    var T = I.toString("hex"), k = [T, B.toString(16)].join("_");
    if (k in v)
      return v[k];
    var j = 0;
    if (B.isEven() || !c.simpleSieve || !c.fermatTest(B) || !n.test(B))
      return j += 1, T === "02" || T === "05" ? j += 8 : j += 4, v[k] = j, j;
    n.test(B.shrn(1)) || (j += 2);
    var N;
    switch (T) {
      case "02":
        B.mod(i).cmp(s) && (j += 8);
        break;
      case "05":
        N = B.mod(r), N.cmp(o) && N.cmp(u) && (j += 8);
        break;
      default:
        j += 4;
    }
    return v[k] = j, j;
  }
  function E(B, I, T) {
    this.setGenerator(I), this.__prime = new e(B), this._prime = e.mont(this.__prime), this._primeLen = B.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, T ? (this.setPublicKey = f, this.setPrivateKey = b) : this._primeCode = 8;
  }
  Object.defineProperty(E.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = m(this.__prime, this.__gen)), this._primeCode;
    }
  }), E.prototype.generateKeys = function() {
    return this._priv || (this._priv = new e(h(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, E.prototype.computeSecret = function(B) {
    B = new e(B), B = B.toRed(this._prime);
    var I = B.redPow(this._priv).fromRed(), T = new Buffer(I.toArray()), k = this.getPrime();
    if (T.length < k.length) {
      var j = new Buffer(k.length - T.length);
      j.fill(0), T = Buffer.concat([j, T]);
    }
    return T;
  }, E.prototype.getPublicKey = function(I) {
    return M(this._pub, I);
  }, E.prototype.getPrivateKey = function(I) {
    return M(this._priv, I);
  }, E.prototype.getPrime = function(B) {
    return M(this.__prime, B);
  }, E.prototype.getGenerator = function(B) {
    return M(this._gen, B);
  }, E.prototype.setGenerator = function(B, I) {
    return I = I || "utf8", Buffer.isBuffer(B) || (B = new Buffer(B, I)), this.__gen = B, this._gen = new e(B), this;
  };
  function M(B, I) {
    var T = new Buffer(B.toArray());
    return I ? T.toString(I) : T;
  }
  return ru;
}
var l1;
function z5() {
  if (l1)
    return _n;
  l1 = 1;
  var e = uy(), t = F5, n = H5();
  function i(o) {
    var u = new Buffer(t[o].prime, "hex"), c = new Buffer(t[o].gen, "hex");
    return new n(u, c);
  }
  var s = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function r(o, u, c, h) {
    return Buffer.isBuffer(u) || s[u] === void 0 ? r(o, "binary", u, c) : (u = u || "binary", h = h || "binary", c = c || new Buffer([2]), Buffer.isBuffer(c) || (c = new Buffer(c, h)), typeof o == "number" ? new n(e(o, c), c, !0) : (Buffer.isBuffer(o) || (o = new Buffer(o, u)), new n(o, c, !0)));
  }
  return _n.DiffieHellmanGroup = _n.createDiffieHellmanGroup = _n.getDiffieHellman = i, _n.createDiffieHellman = _n.DiffieHellman = r, _n;
}
var gi = { exports: {} }, pa = { exports: {} };
pa.exports;
var d1;
function V5() {
  return d1 || (d1 = 1, function(e) {
    (function(t, n) {
      function i(p, a) {
        if (!p)
          throw new Error(a || "Assertion failed");
      }
      function s(p, a) {
        p.super_ = a;
        var l = function() {
        };
        l.prototype = a.prototype, p.prototype = new l(), p.prototype.constructor = p;
      }
      function r(p, a, l) {
        if (r.isBN(p))
          return p;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, p !== null && ((a === "le" || a === "be") && (l = a, a = 10), this._init(p || 0, a || 10, l || "be"));
      }
      typeof t == "object" ? t.exports = r : n.BN = r, r.BN = r, r.wordSize = 26;
      var o;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = dr.Buffer;
      } catch {
      }
      r.isBN = function(a) {
        return a instanceof r ? !0 : a !== null && typeof a == "object" && a.constructor.wordSize === r.wordSize && Array.isArray(a.words);
      }, r.max = function(a, l) {
        return a.cmp(l) > 0 ? a : l;
      }, r.min = function(a, l) {
        return a.cmp(l) < 0 ? a : l;
      }, r.prototype._init = function(a, l, _) {
        if (typeof a == "number")
          return this._initNumber(a, l, _);
        if (typeof a == "object")
          return this._initArray(a, l, _);
        l === "hex" && (l = 16), i(l === (l | 0) && l >= 2 && l <= 36), a = a.toString().replace(/\s+/g, "");
        var x = 0;
        a[0] === "-" && (x++, this.negative = 1), x < a.length && (l === 16 ? this._parseHex(a, x, _) : (this._parseBase(a, l, x), _ === "le" && this._initArray(this.toArray(), l, _)));
      }, r.prototype._initNumber = function(a, l, _) {
        a < 0 && (this.negative = 1, a = -a), a < 67108864 ? (this.words = [a & 67108863], this.length = 1) : a < 4503599627370496 ? (this.words = [
          a & 67108863,
          a / 67108864 & 67108863
        ], this.length = 2) : (i(a < 9007199254740992), this.words = [
          a & 67108863,
          a / 67108864 & 67108863,
          1
        ], this.length = 3), _ === "le" && this._initArray(this.toArray(), l, _);
      }, r.prototype._initArray = function(a, l, _) {
        if (i(typeof a.length == "number"), a.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(a.length / 3), this.words = new Array(this.length);
        for (var x = 0; x < this.length; x++)
          this.words[x] = 0;
        var A, S, g = 0;
        if (_ === "be")
          for (x = a.length - 1, A = 0; x >= 0; x -= 3)
            S = a[x] | a[x - 1] << 8 | a[x - 2] << 16, this.words[A] |= S << g & 67108863, this.words[A + 1] = S >>> 26 - g & 67108863, g += 24, g >= 26 && (g -= 26, A++);
        else if (_ === "le")
          for (x = 0, A = 0; x < a.length; x += 3)
            S = a[x] | a[x + 1] << 8 | a[x + 2] << 16, this.words[A] |= S << g & 67108863, this.words[A + 1] = S >>> 26 - g & 67108863, g += 24, g >= 26 && (g -= 26, A++);
        return this._strip();
      };
      function u(p, a) {
        var l = p.charCodeAt(a);
        if (l >= 48 && l <= 57)
          return l - 48;
        if (l >= 65 && l <= 70)
          return l - 55;
        if (l >= 97 && l <= 102)
          return l - 87;
        i(!1, "Invalid character in " + p);
      }
      function c(p, a, l) {
        var _ = u(p, l);
        return l - 1 >= a && (_ |= u(p, l - 1) << 4), _;
      }
      r.prototype._parseHex = function(a, l, _) {
        this.length = Math.ceil((a.length - l) / 6), this.words = new Array(this.length);
        for (var x = 0; x < this.length; x++)
          this.words[x] = 0;
        var A = 0, S = 0, g;
        if (_ === "be")
          for (x = a.length - 1; x >= l; x -= 2)
            g = c(a, l, x) << A, this.words[S] |= g & 67108863, A >= 18 ? (A -= 18, S += 1, this.words[S] |= g >>> 26) : A += 8;
        else {
          var w = a.length - l;
          for (x = w % 2 === 0 ? l + 1 : l; x < a.length; x += 2)
            g = c(a, l, x) << A, this.words[S] |= g & 67108863, A >= 18 ? (A -= 18, S += 1, this.words[S] |= g >>> 26) : A += 8;
        }
        this._strip();
      };
      function h(p, a, l, _) {
        for (var x = 0, A = 0, S = Math.min(p.length, l), g = a; g < S; g++) {
          var w = p.charCodeAt(g) - 48;
          x *= _, w >= 49 ? A = w - 49 + 10 : w >= 17 ? A = w - 17 + 10 : A = w, i(w >= 0 && A < _, "Invalid character"), x += A;
        }
        return x;
      }
      r.prototype._parseBase = function(a, l, _) {
        this.words = [0], this.length = 1;
        for (var x = 0, A = 1; A <= 67108863; A *= l)
          x++;
        x--, A = A / l | 0;
        for (var S = a.length - _, g = S % x, w = Math.min(S, S - g) + _, d = 0, R = _; R < w; R += x)
          d = h(a, R, R + x, l), this.imuln(A), this.words[0] + d < 67108864 ? this.words[0] += d : this._iaddn(d);
        if (g !== 0) {
          var G = 1;
          for (d = h(a, R, a.length, l), R = 0; R < g; R++)
            G *= l;
          this.imuln(G), this.words[0] + d < 67108864 ? this.words[0] += d : this._iaddn(d);
        }
        this._strip();
      }, r.prototype.copy = function(a) {
        a.words = new Array(this.length);
        for (var l = 0; l < this.length; l++)
          a.words[l] = this.words[l];
        a.length = this.length, a.negative = this.negative, a.red = this.red;
      };
      function f(p, a) {
        p.words = a.words, p.length = a.length, p.negative = a.negative, p.red = a.red;
      }
      if (r.prototype._move = function(a) {
        f(a, this);
      }, r.prototype.clone = function() {
        var a = new r(null);
        return this.copy(a), a;
      }, r.prototype._expand = function(a) {
        for (; this.length < a; )
          this.words[this.length++] = 0;
        return this;
      }, r.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, r.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          r.prototype[Symbol.for("nodejs.util.inspect.custom")] = b;
        } catch {
          r.prototype.inspect = b;
        }
      else
        r.prototype.inspect = b;
      function b() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var v = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], m = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], E = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      r.prototype.toString = function(a, l) {
        a = a || 10, l = l | 0 || 1;
        var _;
        if (a === 16 || a === "hex") {
          _ = "";
          for (var x = 0, A = 0, S = 0; S < this.length; S++) {
            var g = this.words[S], w = ((g << x | A) & 16777215).toString(16);
            A = g >>> 24 - x & 16777215, x += 2, x >= 26 && (x -= 26, S--), A !== 0 || S !== this.length - 1 ? _ = v[6 - w.length] + w + _ : _ = w + _;
          }
          for (A !== 0 && (_ = A.toString(16) + _); _.length % l !== 0; )
            _ = "0" + _;
          return this.negative !== 0 && (_ = "-" + _), _;
        }
        if (a === (a | 0) && a >= 2 && a <= 36) {
          var d = m[a], R = E[a];
          _ = "";
          var G = this.clone();
          for (G.negative = 0; !G.isZero(); ) {
            var fe = G.modrn(R).toString(a);
            G = G.idivn(R), G.isZero() ? _ = fe + _ : _ = v[d - fe.length] + fe + _;
          }
          for (this.isZero() && (_ = "0" + _); _.length % l !== 0; )
            _ = "0" + _;
          return this.negative !== 0 && (_ = "-" + _), _;
        }
        i(!1, "Base should be between 2 and 36");
      }, r.prototype.toNumber = function() {
        var a = this.words[0];
        return this.length === 2 ? a += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? a += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -a : a;
      }, r.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, o && (r.prototype.toBuffer = function(a, l) {
        return this.toArrayLike(o, a, l);
      }), r.prototype.toArray = function(a, l) {
        return this.toArrayLike(Array, a, l);
      };
      var M = function(a, l) {
        return a.allocUnsafe ? a.allocUnsafe(l) : new a(l);
      };
      r.prototype.toArrayLike = function(a, l, _) {
        this._strip();
        var x = this.byteLength(), A = _ || Math.max(1, x);
        i(x <= A, "byte array longer than desired length"), i(A > 0, "Requested array length <= 0");
        var S = M(a, A), g = l === "le" ? "LE" : "BE";
        return this["_toArrayLike" + g](S, x), S;
      }, r.prototype._toArrayLikeLE = function(a, l) {
        for (var _ = 0, x = 0, A = 0, S = 0; A < this.length; A++) {
          var g = this.words[A] << S | x;
          a[_++] = g & 255, _ < a.length && (a[_++] = g >> 8 & 255), _ < a.length && (a[_++] = g >> 16 & 255), S === 6 ? (_ < a.length && (a[_++] = g >> 24 & 255), x = 0, S = 0) : (x = g >>> 24, S += 2);
        }
        if (_ < a.length)
          for (a[_++] = x; _ < a.length; )
            a[_++] = 0;
      }, r.prototype._toArrayLikeBE = function(a, l) {
        for (var _ = a.length - 1, x = 0, A = 0, S = 0; A < this.length; A++) {
          var g = this.words[A] << S | x;
          a[_--] = g & 255, _ >= 0 && (a[_--] = g >> 8 & 255), _ >= 0 && (a[_--] = g >> 16 & 255), S === 6 ? (_ >= 0 && (a[_--] = g >> 24 & 255), x = 0, S = 0) : (x = g >>> 24, S += 2);
        }
        if (_ >= 0)
          for (a[_--] = x; _ >= 0; )
            a[_--] = 0;
      }, Math.clz32 ? r.prototype._countBits = function(a) {
        return 32 - Math.clz32(a);
      } : r.prototype._countBits = function(a) {
        var l = a, _ = 0;
        return l >= 4096 && (_ += 13, l >>>= 13), l >= 64 && (_ += 7, l >>>= 7), l >= 8 && (_ += 4, l >>>= 4), l >= 2 && (_ += 2, l >>>= 2), _ + l;
      }, r.prototype._zeroBits = function(a) {
        if (a === 0)
          return 26;
        var l = a, _ = 0;
        return l & 8191 || (_ += 13, l >>>= 13), l & 127 || (_ += 7, l >>>= 7), l & 15 || (_ += 4, l >>>= 4), l & 3 || (_ += 2, l >>>= 2), l & 1 || _++, _;
      }, r.prototype.bitLength = function() {
        var a = this.words[this.length - 1], l = this._countBits(a);
        return (this.length - 1) * 26 + l;
      };
      function B(p) {
        for (var a = new Array(p.bitLength()), l = 0; l < a.length; l++) {
          var _ = l / 26 | 0, x = l % 26;
          a[l] = p.words[_] >>> x & 1;
        }
        return a;
      }
      r.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var a = 0, l = 0; l < this.length; l++) {
          var _ = this._zeroBits(this.words[l]);
          if (a += _, _ !== 26)
            break;
        }
        return a;
      }, r.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, r.prototype.toTwos = function(a) {
        return this.negative !== 0 ? this.abs().inotn(a).iaddn(1) : this.clone();
      }, r.prototype.fromTwos = function(a) {
        return this.testn(a - 1) ? this.notn(a).iaddn(1).ineg() : this.clone();
      }, r.prototype.isNeg = function() {
        return this.negative !== 0;
      }, r.prototype.neg = function() {
        return this.clone().ineg();
      }, r.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, r.prototype.iuor = function(a) {
        for (; this.length < a.length; )
          this.words[this.length++] = 0;
        for (var l = 0; l < a.length; l++)
          this.words[l] = this.words[l] | a.words[l];
        return this._strip();
      }, r.prototype.ior = function(a) {
        return i((this.negative | a.negative) === 0), this.iuor(a);
      }, r.prototype.or = function(a) {
        return this.length > a.length ? this.clone().ior(a) : a.clone().ior(this);
      }, r.prototype.uor = function(a) {
        return this.length > a.length ? this.clone().iuor(a) : a.clone().iuor(this);
      }, r.prototype.iuand = function(a) {
        var l;
        this.length > a.length ? l = a : l = this;
        for (var _ = 0; _ < l.length; _++)
          this.words[_] = this.words[_] & a.words[_];
        return this.length = l.length, this._strip();
      }, r.prototype.iand = function(a) {
        return i((this.negative | a.negative) === 0), this.iuand(a);
      }, r.prototype.and = function(a) {
        return this.length > a.length ? this.clone().iand(a) : a.clone().iand(this);
      }, r.prototype.uand = function(a) {
        return this.length > a.length ? this.clone().iuand(a) : a.clone().iuand(this);
      }, r.prototype.iuxor = function(a) {
        var l, _;
        this.length > a.length ? (l = this, _ = a) : (l = a, _ = this);
        for (var x = 0; x < _.length; x++)
          this.words[x] = l.words[x] ^ _.words[x];
        if (this !== l)
          for (; x < l.length; x++)
            this.words[x] = l.words[x];
        return this.length = l.length, this._strip();
      }, r.prototype.ixor = function(a) {
        return i((this.negative | a.negative) === 0), this.iuxor(a);
      }, r.prototype.xor = function(a) {
        return this.length > a.length ? this.clone().ixor(a) : a.clone().ixor(this);
      }, r.prototype.uxor = function(a) {
        return this.length > a.length ? this.clone().iuxor(a) : a.clone().iuxor(this);
      }, r.prototype.inotn = function(a) {
        i(typeof a == "number" && a >= 0);
        var l = Math.ceil(a / 26) | 0, _ = a % 26;
        this._expand(l), _ > 0 && l--;
        for (var x = 0; x < l; x++)
          this.words[x] = ~this.words[x] & 67108863;
        return _ > 0 && (this.words[x] = ~this.words[x] & 67108863 >> 26 - _), this._strip();
      }, r.prototype.notn = function(a) {
        return this.clone().inotn(a);
      }, r.prototype.setn = function(a, l) {
        i(typeof a == "number" && a >= 0);
        var _ = a / 26 | 0, x = a % 26;
        return this._expand(_ + 1), l ? this.words[_] = this.words[_] | 1 << x : this.words[_] = this.words[_] & ~(1 << x), this._strip();
      }, r.prototype.iadd = function(a) {
        var l;
        if (this.negative !== 0 && a.negative === 0)
          return this.negative = 0, l = this.isub(a), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && a.negative !== 0)
          return a.negative = 0, l = this.isub(a), a.negative = 1, l._normSign();
        var _, x;
        this.length > a.length ? (_ = this, x = a) : (_ = a, x = this);
        for (var A = 0, S = 0; S < x.length; S++)
          l = (_.words[S] | 0) + (x.words[S] | 0) + A, this.words[S] = l & 67108863, A = l >>> 26;
        for (; A !== 0 && S < _.length; S++)
          l = (_.words[S] | 0) + A, this.words[S] = l & 67108863, A = l >>> 26;
        if (this.length = _.length, A !== 0)
          this.words[this.length] = A, this.length++;
        else if (_ !== this)
          for (; S < _.length; S++)
            this.words[S] = _.words[S];
        return this;
      }, r.prototype.add = function(a) {
        var l;
        return a.negative !== 0 && this.negative === 0 ? (a.negative = 0, l = this.sub(a), a.negative ^= 1, l) : a.negative === 0 && this.negative !== 0 ? (this.negative = 0, l = a.sub(this), this.negative = 1, l) : this.length > a.length ? this.clone().iadd(a) : a.clone().iadd(this);
      }, r.prototype.isub = function(a) {
        if (a.negative !== 0) {
          a.negative = 0;
          var l = this.iadd(a);
          return a.negative = 1, l._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(a), this.negative = 1, this._normSign();
        var _ = this.cmp(a);
        if (_ === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var x, A;
        _ > 0 ? (x = this, A = a) : (x = a, A = this);
        for (var S = 0, g = 0; g < A.length; g++)
          l = (x.words[g] | 0) - (A.words[g] | 0) + S, S = l >> 26, this.words[g] = l & 67108863;
        for (; S !== 0 && g < x.length; g++)
          l = (x.words[g] | 0) + S, S = l >> 26, this.words[g] = l & 67108863;
        if (S === 0 && g < x.length && x !== this)
          for (; g < x.length; g++)
            this.words[g] = x.words[g];
        return this.length = Math.max(this.length, g), x !== this && (this.negative = 1), this._strip();
      }, r.prototype.sub = function(a) {
        return this.clone().isub(a);
      };
      function I(p, a, l) {
        l.negative = a.negative ^ p.negative;
        var _ = p.length + a.length | 0;
        l.length = _, _ = _ - 1 | 0;
        var x = p.words[0] | 0, A = a.words[0] | 0, S = x * A, g = S & 67108863, w = S / 67108864 | 0;
        l.words[0] = g;
        for (var d = 1; d < _; d++) {
          for (var R = w >>> 26, G = w & 67108863, fe = Math.min(d, a.length - 1), z = Math.max(0, d - p.length + 1); z <= fe; z++) {
            var V = d - z | 0;
            x = p.words[V] | 0, A = a.words[z] | 0, S = x * A + G, R += S / 67108864 | 0, G = S & 67108863;
          }
          l.words[d] = G | 0, w = R | 0;
        }
        return w !== 0 ? l.words[d] = w | 0 : l.length--, l._strip();
      }
      var T = function(a, l, _) {
        var x = a.words, A = l.words, S = _.words, g = 0, w, d, R, G = x[0] | 0, fe = G & 8191, z = G >>> 13, V = x[1] | 0, F = V & 8191, ee = V >>> 13, he = x[2] | 0, Z = he & 8191, K = he >>> 13, ce = x[3] | 0, ve = ce & 8191, Be = ce >>> 13, Q = x[4] | 0, C = Q & 8191, L = Q >>> 13, W = x[5] | 0, de = W & 8191, me = W >>> 13, Te = x[6] | 0, Fe = Te & 8191, H = Te >>> 13, ue = x[7] | 0, se = ue & 8191, we = ue >>> 13, Ce = x[8] | 0, ze = Ce & 8191, Le = Ce >>> 13, Y = x[9] | 0, Se = Y & 8191, Ae = Y >>> 13, je = A[0] | 0, pe = je & 8191, Ee = je >>> 13, J = A[1] | 0, Ie = J & 8191, ke = J >>> 13, P = A[2] | 0, Me = P & 8191, be = P >>> 13, ie = A[3] | 0, le = ie & 8191, ge = ie >>> 13, Ge = A[4] | 0, De = Ge & 8191, Ne = Ge >>> 13, rt = A[5] | 0, ft = rt & 8191, We = rt >>> 13, at = A[6] | 0, $ = at & 8191, X = at >>> 13, ne = A[7] | 0, O = ne & 8191, ae = ne >>> 13, _e = A[8] | 0, xe = _e & 8191, Re = _e >>> 13, qe = A[9] | 0, He = qe & 8191, $e = qe >>> 13;
        _.negative = a.negative ^ l.negative, _.length = 19, w = Math.imul(fe, pe), d = Math.imul(fe, Ee), d = d + Math.imul(z, pe) | 0, R = Math.imul(z, Ee);
        var vt = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, w = Math.imul(F, pe), d = Math.imul(F, Ee), d = d + Math.imul(ee, pe) | 0, R = Math.imul(ee, Ee), w = w + Math.imul(fe, Ie) | 0, d = d + Math.imul(fe, ke) | 0, d = d + Math.imul(z, Ie) | 0, R = R + Math.imul(z, ke) | 0;
        var Qe = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, w = Math.imul(Z, pe), d = Math.imul(Z, Ee), d = d + Math.imul(K, pe) | 0, R = Math.imul(K, Ee), w = w + Math.imul(F, Ie) | 0, d = d + Math.imul(F, ke) | 0, d = d + Math.imul(ee, Ie) | 0, R = R + Math.imul(ee, ke) | 0, w = w + Math.imul(fe, Me) | 0, d = d + Math.imul(fe, be) | 0, d = d + Math.imul(z, Me) | 0, R = R + Math.imul(z, be) | 0;
        var ot = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, w = Math.imul(ve, pe), d = Math.imul(ve, Ee), d = d + Math.imul(Be, pe) | 0, R = Math.imul(Be, Ee), w = w + Math.imul(Z, Ie) | 0, d = d + Math.imul(Z, ke) | 0, d = d + Math.imul(K, Ie) | 0, R = R + Math.imul(K, ke) | 0, w = w + Math.imul(F, Me) | 0, d = d + Math.imul(F, be) | 0, d = d + Math.imul(ee, Me) | 0, R = R + Math.imul(ee, be) | 0, w = w + Math.imul(fe, le) | 0, d = d + Math.imul(fe, ge) | 0, d = d + Math.imul(z, le) | 0, R = R + Math.imul(z, ge) | 0;
        var st = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, w = Math.imul(C, pe), d = Math.imul(C, Ee), d = d + Math.imul(L, pe) | 0, R = Math.imul(L, Ee), w = w + Math.imul(ve, Ie) | 0, d = d + Math.imul(ve, ke) | 0, d = d + Math.imul(Be, Ie) | 0, R = R + Math.imul(Be, ke) | 0, w = w + Math.imul(Z, Me) | 0, d = d + Math.imul(Z, be) | 0, d = d + Math.imul(K, Me) | 0, R = R + Math.imul(K, be) | 0, w = w + Math.imul(F, le) | 0, d = d + Math.imul(F, ge) | 0, d = d + Math.imul(ee, le) | 0, R = R + Math.imul(ee, ge) | 0, w = w + Math.imul(fe, De) | 0, d = d + Math.imul(fe, Ne) | 0, d = d + Math.imul(z, De) | 0, R = R + Math.imul(z, Ne) | 0;
        var dt = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, w = Math.imul(de, pe), d = Math.imul(de, Ee), d = d + Math.imul(me, pe) | 0, R = Math.imul(me, Ee), w = w + Math.imul(C, Ie) | 0, d = d + Math.imul(C, ke) | 0, d = d + Math.imul(L, Ie) | 0, R = R + Math.imul(L, ke) | 0, w = w + Math.imul(ve, Me) | 0, d = d + Math.imul(ve, be) | 0, d = d + Math.imul(Be, Me) | 0, R = R + Math.imul(Be, be) | 0, w = w + Math.imul(Z, le) | 0, d = d + Math.imul(Z, ge) | 0, d = d + Math.imul(K, le) | 0, R = R + Math.imul(K, ge) | 0, w = w + Math.imul(F, De) | 0, d = d + Math.imul(F, Ne) | 0, d = d + Math.imul(ee, De) | 0, R = R + Math.imul(ee, Ne) | 0, w = w + Math.imul(fe, ft) | 0, d = d + Math.imul(fe, We) | 0, d = d + Math.imul(z, ft) | 0, R = R + Math.imul(z, We) | 0;
        var lt = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (lt >>> 26) | 0, lt &= 67108863, w = Math.imul(Fe, pe), d = Math.imul(Fe, Ee), d = d + Math.imul(H, pe) | 0, R = Math.imul(H, Ee), w = w + Math.imul(de, Ie) | 0, d = d + Math.imul(de, ke) | 0, d = d + Math.imul(me, Ie) | 0, R = R + Math.imul(me, ke) | 0, w = w + Math.imul(C, Me) | 0, d = d + Math.imul(C, be) | 0, d = d + Math.imul(L, Me) | 0, R = R + Math.imul(L, be) | 0, w = w + Math.imul(ve, le) | 0, d = d + Math.imul(ve, ge) | 0, d = d + Math.imul(Be, le) | 0, R = R + Math.imul(Be, ge) | 0, w = w + Math.imul(Z, De) | 0, d = d + Math.imul(Z, Ne) | 0, d = d + Math.imul(K, De) | 0, R = R + Math.imul(K, Ne) | 0, w = w + Math.imul(F, ft) | 0, d = d + Math.imul(F, We) | 0, d = d + Math.imul(ee, ft) | 0, R = R + Math.imul(ee, We) | 0, w = w + Math.imul(fe, $) | 0, d = d + Math.imul(fe, X) | 0, d = d + Math.imul(z, $) | 0, R = R + Math.imul(z, X) | 0;
        var ut = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, w = Math.imul(se, pe), d = Math.imul(se, Ee), d = d + Math.imul(we, pe) | 0, R = Math.imul(we, Ee), w = w + Math.imul(Fe, Ie) | 0, d = d + Math.imul(Fe, ke) | 0, d = d + Math.imul(H, Ie) | 0, R = R + Math.imul(H, ke) | 0, w = w + Math.imul(de, Me) | 0, d = d + Math.imul(de, be) | 0, d = d + Math.imul(me, Me) | 0, R = R + Math.imul(me, be) | 0, w = w + Math.imul(C, le) | 0, d = d + Math.imul(C, ge) | 0, d = d + Math.imul(L, le) | 0, R = R + Math.imul(L, ge) | 0, w = w + Math.imul(ve, De) | 0, d = d + Math.imul(ve, Ne) | 0, d = d + Math.imul(Be, De) | 0, R = R + Math.imul(Be, Ne) | 0, w = w + Math.imul(Z, ft) | 0, d = d + Math.imul(Z, We) | 0, d = d + Math.imul(K, ft) | 0, R = R + Math.imul(K, We) | 0, w = w + Math.imul(F, $) | 0, d = d + Math.imul(F, X) | 0, d = d + Math.imul(ee, $) | 0, R = R + Math.imul(ee, X) | 0, w = w + Math.imul(fe, O) | 0, d = d + Math.imul(fe, ae) | 0, d = d + Math.imul(z, O) | 0, R = R + Math.imul(z, ae) | 0;
        var ht = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, w = Math.imul(ze, pe), d = Math.imul(ze, Ee), d = d + Math.imul(Le, pe) | 0, R = Math.imul(Le, Ee), w = w + Math.imul(se, Ie) | 0, d = d + Math.imul(se, ke) | 0, d = d + Math.imul(we, Ie) | 0, R = R + Math.imul(we, ke) | 0, w = w + Math.imul(Fe, Me) | 0, d = d + Math.imul(Fe, be) | 0, d = d + Math.imul(H, Me) | 0, R = R + Math.imul(H, be) | 0, w = w + Math.imul(de, le) | 0, d = d + Math.imul(de, ge) | 0, d = d + Math.imul(me, le) | 0, R = R + Math.imul(me, ge) | 0, w = w + Math.imul(C, De) | 0, d = d + Math.imul(C, Ne) | 0, d = d + Math.imul(L, De) | 0, R = R + Math.imul(L, Ne) | 0, w = w + Math.imul(ve, ft) | 0, d = d + Math.imul(ve, We) | 0, d = d + Math.imul(Be, ft) | 0, R = R + Math.imul(Be, We) | 0, w = w + Math.imul(Z, $) | 0, d = d + Math.imul(Z, X) | 0, d = d + Math.imul(K, $) | 0, R = R + Math.imul(K, X) | 0, w = w + Math.imul(F, O) | 0, d = d + Math.imul(F, ae) | 0, d = d + Math.imul(ee, O) | 0, R = R + Math.imul(ee, ae) | 0, w = w + Math.imul(fe, xe) | 0, d = d + Math.imul(fe, Re) | 0, d = d + Math.imul(z, xe) | 0, R = R + Math.imul(z, Re) | 0;
        var ct = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, w = Math.imul(Se, pe), d = Math.imul(Se, Ee), d = d + Math.imul(Ae, pe) | 0, R = Math.imul(Ae, Ee), w = w + Math.imul(ze, Ie) | 0, d = d + Math.imul(ze, ke) | 0, d = d + Math.imul(Le, Ie) | 0, R = R + Math.imul(Le, ke) | 0, w = w + Math.imul(se, Me) | 0, d = d + Math.imul(se, be) | 0, d = d + Math.imul(we, Me) | 0, R = R + Math.imul(we, be) | 0, w = w + Math.imul(Fe, le) | 0, d = d + Math.imul(Fe, ge) | 0, d = d + Math.imul(H, le) | 0, R = R + Math.imul(H, ge) | 0, w = w + Math.imul(de, De) | 0, d = d + Math.imul(de, Ne) | 0, d = d + Math.imul(me, De) | 0, R = R + Math.imul(me, Ne) | 0, w = w + Math.imul(C, ft) | 0, d = d + Math.imul(C, We) | 0, d = d + Math.imul(L, ft) | 0, R = R + Math.imul(L, We) | 0, w = w + Math.imul(ve, $) | 0, d = d + Math.imul(ve, X) | 0, d = d + Math.imul(Be, $) | 0, R = R + Math.imul(Be, X) | 0, w = w + Math.imul(Z, O) | 0, d = d + Math.imul(Z, ae) | 0, d = d + Math.imul(K, O) | 0, R = R + Math.imul(K, ae) | 0, w = w + Math.imul(F, xe) | 0, d = d + Math.imul(F, Re) | 0, d = d + Math.imul(ee, xe) | 0, R = R + Math.imul(ee, Re) | 0, w = w + Math.imul(fe, He) | 0, d = d + Math.imul(fe, $e) | 0, d = d + Math.imul(z, He) | 0, R = R + Math.imul(z, $e) | 0;
        var et = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, w = Math.imul(Se, Ie), d = Math.imul(Se, ke), d = d + Math.imul(Ae, Ie) | 0, R = Math.imul(Ae, ke), w = w + Math.imul(ze, Me) | 0, d = d + Math.imul(ze, be) | 0, d = d + Math.imul(Le, Me) | 0, R = R + Math.imul(Le, be) | 0, w = w + Math.imul(se, le) | 0, d = d + Math.imul(se, ge) | 0, d = d + Math.imul(we, le) | 0, R = R + Math.imul(we, ge) | 0, w = w + Math.imul(Fe, De) | 0, d = d + Math.imul(Fe, Ne) | 0, d = d + Math.imul(H, De) | 0, R = R + Math.imul(H, Ne) | 0, w = w + Math.imul(de, ft) | 0, d = d + Math.imul(de, We) | 0, d = d + Math.imul(me, ft) | 0, R = R + Math.imul(me, We) | 0, w = w + Math.imul(C, $) | 0, d = d + Math.imul(C, X) | 0, d = d + Math.imul(L, $) | 0, R = R + Math.imul(L, X) | 0, w = w + Math.imul(ve, O) | 0, d = d + Math.imul(ve, ae) | 0, d = d + Math.imul(Be, O) | 0, R = R + Math.imul(Be, ae) | 0, w = w + Math.imul(Z, xe) | 0, d = d + Math.imul(Z, Re) | 0, d = d + Math.imul(K, xe) | 0, R = R + Math.imul(K, Re) | 0, w = w + Math.imul(F, He) | 0, d = d + Math.imul(F, $e) | 0, d = d + Math.imul(ee, He) | 0, R = R + Math.imul(ee, $e) | 0;
        var it = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, w = Math.imul(Se, Me), d = Math.imul(Se, be), d = d + Math.imul(Ae, Me) | 0, R = Math.imul(Ae, be), w = w + Math.imul(ze, le) | 0, d = d + Math.imul(ze, ge) | 0, d = d + Math.imul(Le, le) | 0, R = R + Math.imul(Le, ge) | 0, w = w + Math.imul(se, De) | 0, d = d + Math.imul(se, Ne) | 0, d = d + Math.imul(we, De) | 0, R = R + Math.imul(we, Ne) | 0, w = w + Math.imul(Fe, ft) | 0, d = d + Math.imul(Fe, We) | 0, d = d + Math.imul(H, ft) | 0, R = R + Math.imul(H, We) | 0, w = w + Math.imul(de, $) | 0, d = d + Math.imul(de, X) | 0, d = d + Math.imul(me, $) | 0, R = R + Math.imul(me, X) | 0, w = w + Math.imul(C, O) | 0, d = d + Math.imul(C, ae) | 0, d = d + Math.imul(L, O) | 0, R = R + Math.imul(L, ae) | 0, w = w + Math.imul(ve, xe) | 0, d = d + Math.imul(ve, Re) | 0, d = d + Math.imul(Be, xe) | 0, R = R + Math.imul(Be, Re) | 0, w = w + Math.imul(Z, He) | 0, d = d + Math.imul(Z, $e) | 0, d = d + Math.imul(K, He) | 0, R = R + Math.imul(K, $e) | 0;
        var Ye = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, w = Math.imul(Se, le), d = Math.imul(Se, ge), d = d + Math.imul(Ae, le) | 0, R = Math.imul(Ae, ge), w = w + Math.imul(ze, De) | 0, d = d + Math.imul(ze, Ne) | 0, d = d + Math.imul(Le, De) | 0, R = R + Math.imul(Le, Ne) | 0, w = w + Math.imul(se, ft) | 0, d = d + Math.imul(se, We) | 0, d = d + Math.imul(we, ft) | 0, R = R + Math.imul(we, We) | 0, w = w + Math.imul(Fe, $) | 0, d = d + Math.imul(Fe, X) | 0, d = d + Math.imul(H, $) | 0, R = R + Math.imul(H, X) | 0, w = w + Math.imul(de, O) | 0, d = d + Math.imul(de, ae) | 0, d = d + Math.imul(me, O) | 0, R = R + Math.imul(me, ae) | 0, w = w + Math.imul(C, xe) | 0, d = d + Math.imul(C, Re) | 0, d = d + Math.imul(L, xe) | 0, R = R + Math.imul(L, Re) | 0, w = w + Math.imul(ve, He) | 0, d = d + Math.imul(ve, $e) | 0, d = d + Math.imul(Be, He) | 0, R = R + Math.imul(Be, $e) | 0;
        var tt = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, w = Math.imul(Se, De), d = Math.imul(Se, Ne), d = d + Math.imul(Ae, De) | 0, R = Math.imul(Ae, Ne), w = w + Math.imul(ze, ft) | 0, d = d + Math.imul(ze, We) | 0, d = d + Math.imul(Le, ft) | 0, R = R + Math.imul(Le, We) | 0, w = w + Math.imul(se, $) | 0, d = d + Math.imul(se, X) | 0, d = d + Math.imul(we, $) | 0, R = R + Math.imul(we, X) | 0, w = w + Math.imul(Fe, O) | 0, d = d + Math.imul(Fe, ae) | 0, d = d + Math.imul(H, O) | 0, R = R + Math.imul(H, ae) | 0, w = w + Math.imul(de, xe) | 0, d = d + Math.imul(de, Re) | 0, d = d + Math.imul(me, xe) | 0, R = R + Math.imul(me, Re) | 0, w = w + Math.imul(C, He) | 0, d = d + Math.imul(C, $e) | 0, d = d + Math.imul(L, He) | 0, R = R + Math.imul(L, $e) | 0;
        var nt = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, w = Math.imul(Se, ft), d = Math.imul(Se, We), d = d + Math.imul(Ae, ft) | 0, R = Math.imul(Ae, We), w = w + Math.imul(ze, $) | 0, d = d + Math.imul(ze, X) | 0, d = d + Math.imul(Le, $) | 0, R = R + Math.imul(Le, X) | 0, w = w + Math.imul(se, O) | 0, d = d + Math.imul(se, ae) | 0, d = d + Math.imul(we, O) | 0, R = R + Math.imul(we, ae) | 0, w = w + Math.imul(Fe, xe) | 0, d = d + Math.imul(Fe, Re) | 0, d = d + Math.imul(H, xe) | 0, R = R + Math.imul(H, Re) | 0, w = w + Math.imul(de, He) | 0, d = d + Math.imul(de, $e) | 0, d = d + Math.imul(me, He) | 0, R = R + Math.imul(me, $e) | 0;
        var Xe = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, w = Math.imul(Se, $), d = Math.imul(Se, X), d = d + Math.imul(Ae, $) | 0, R = Math.imul(Ae, X), w = w + Math.imul(ze, O) | 0, d = d + Math.imul(ze, ae) | 0, d = d + Math.imul(Le, O) | 0, R = R + Math.imul(Le, ae) | 0, w = w + Math.imul(se, xe) | 0, d = d + Math.imul(se, Re) | 0, d = d + Math.imul(we, xe) | 0, R = R + Math.imul(we, Re) | 0, w = w + Math.imul(Fe, He) | 0, d = d + Math.imul(Fe, $e) | 0, d = d + Math.imul(H, He) | 0, R = R + Math.imul(H, $e) | 0;
        var Oe = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, w = Math.imul(Se, O), d = Math.imul(Se, ae), d = d + Math.imul(Ae, O) | 0, R = Math.imul(Ae, ae), w = w + Math.imul(ze, xe) | 0, d = d + Math.imul(ze, Re) | 0, d = d + Math.imul(Le, xe) | 0, R = R + Math.imul(Le, Re) | 0, w = w + Math.imul(se, He) | 0, d = d + Math.imul(se, $e) | 0, d = d + Math.imul(we, He) | 0, R = R + Math.imul(we, $e) | 0;
        var Pe = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, w = Math.imul(Se, xe), d = Math.imul(Se, Re), d = d + Math.imul(Ae, xe) | 0, R = Math.imul(Ae, Re), w = w + Math.imul(ze, He) | 0, d = d + Math.imul(ze, $e) | 0, d = d + Math.imul(Le, He) | 0, R = R + Math.imul(Le, $e) | 0;
        var Ke = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, w = Math.imul(Se, He), d = Math.imul(Se, $e), d = d + Math.imul(Ae, He) | 0, R = Math.imul(Ae, $e);
        var Ue = (g + w | 0) + ((d & 8191) << 13) | 0;
        return g = (R + (d >>> 13) | 0) + (Ue >>> 26) | 0, Ue &= 67108863, S[0] = vt, S[1] = Qe, S[2] = ot, S[3] = st, S[4] = dt, S[5] = lt, S[6] = ut, S[7] = ht, S[8] = ct, S[9] = et, S[10] = it, S[11] = Ye, S[12] = tt, S[13] = nt, S[14] = Xe, S[15] = Oe, S[16] = Pe, S[17] = Ke, S[18] = Ue, g !== 0 && (S[19] = g, _.length++), _;
      };
      Math.imul || (T = I);
      function k(p, a, l) {
        l.negative = a.negative ^ p.negative, l.length = p.length + a.length;
        for (var _ = 0, x = 0, A = 0; A < l.length - 1; A++) {
          var S = x;
          x = 0;
          for (var g = _ & 67108863, w = Math.min(A, a.length - 1), d = Math.max(0, A - p.length + 1); d <= w; d++) {
            var R = A - d, G = p.words[R] | 0, fe = a.words[d] | 0, z = G * fe, V = z & 67108863;
            S = S + (z / 67108864 | 0) | 0, V = V + g | 0, g = V & 67108863, S = S + (V >>> 26) | 0, x += S >>> 26, S &= 67108863;
          }
          l.words[A] = g, _ = S, S = x;
        }
        return _ !== 0 ? l.words[A] = _ : l.length--, l._strip();
      }
      function j(p, a, l) {
        return k(p, a, l);
      }
      r.prototype.mulTo = function(a, l) {
        var _, x = this.length + a.length;
        return this.length === 10 && a.length === 10 ? _ = T(this, a, l) : x < 63 ? _ = I(this, a, l) : x < 1024 ? _ = k(this, a, l) : _ = j(this, a, l), _;
      }, r.prototype.mul = function(a) {
        var l = new r(null);
        return l.words = new Array(this.length + a.length), this.mulTo(a, l);
      }, r.prototype.mulf = function(a) {
        var l = new r(null);
        return l.words = new Array(this.length + a.length), j(this, a, l);
      }, r.prototype.imul = function(a) {
        return this.clone().mulTo(a, this);
      }, r.prototype.imuln = function(a) {
        var l = a < 0;
        l && (a = -a), i(typeof a == "number"), i(a < 67108864);
        for (var _ = 0, x = 0; x < this.length; x++) {
          var A = (this.words[x] | 0) * a, S = (A & 67108863) + (_ & 67108863);
          _ >>= 26, _ += A / 67108864 | 0, _ += S >>> 26, this.words[x] = S & 67108863;
        }
        return _ !== 0 && (this.words[x] = _, this.length++), l ? this.ineg() : this;
      }, r.prototype.muln = function(a) {
        return this.clone().imuln(a);
      }, r.prototype.sqr = function() {
        return this.mul(this);
      }, r.prototype.isqr = function() {
        return this.imul(this.clone());
      }, r.prototype.pow = function(a) {
        var l = B(a);
        if (l.length === 0)
          return new r(1);
        for (var _ = this, x = 0; x < l.length && l[x] === 0; x++, _ = _.sqr())
          ;
        if (++x < l.length)
          for (var A = _.sqr(); x < l.length; x++, A = A.sqr())
            l[x] !== 0 && (_ = _.mul(A));
        return _;
      }, r.prototype.iushln = function(a) {
        i(typeof a == "number" && a >= 0);
        var l = a % 26, _ = (a - l) / 26, x = 67108863 >>> 26 - l << 26 - l, A;
        if (l !== 0) {
          var S = 0;
          for (A = 0; A < this.length; A++) {
            var g = this.words[A] & x, w = (this.words[A] | 0) - g << l;
            this.words[A] = w | S, S = g >>> 26 - l;
          }
          S && (this.words[A] = S, this.length++);
        }
        if (_ !== 0) {
          for (A = this.length - 1; A >= 0; A--)
            this.words[A + _] = this.words[A];
          for (A = 0; A < _; A++)
            this.words[A] = 0;
          this.length += _;
        }
        return this._strip();
      }, r.prototype.ishln = function(a) {
        return i(this.negative === 0), this.iushln(a);
      }, r.prototype.iushrn = function(a, l, _) {
        i(typeof a == "number" && a >= 0);
        var x;
        l ? x = (l - l % 26) / 26 : x = 0;
        var A = a % 26, S = Math.min((a - A) / 26, this.length), g = 67108863 ^ 67108863 >>> A << A, w = _;
        if (x -= S, x = Math.max(0, x), w) {
          for (var d = 0; d < S; d++)
            w.words[d] = this.words[d];
          w.length = S;
        }
        if (S !== 0)
          if (this.length > S)
            for (this.length -= S, d = 0; d < this.length; d++)
              this.words[d] = this.words[d + S];
          else
            this.words[0] = 0, this.length = 1;
        var R = 0;
        for (d = this.length - 1; d >= 0 && (R !== 0 || d >= x); d--) {
          var G = this.words[d] | 0;
          this.words[d] = R << 26 - A | G >>> A, R = G & g;
        }
        return w && R !== 0 && (w.words[w.length++] = R), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, r.prototype.ishrn = function(a, l, _) {
        return i(this.negative === 0), this.iushrn(a, l, _);
      }, r.prototype.shln = function(a) {
        return this.clone().ishln(a);
      }, r.prototype.ushln = function(a) {
        return this.clone().iushln(a);
      }, r.prototype.shrn = function(a) {
        return this.clone().ishrn(a);
      }, r.prototype.ushrn = function(a) {
        return this.clone().iushrn(a);
      }, r.prototype.testn = function(a) {
        i(typeof a == "number" && a >= 0);
        var l = a % 26, _ = (a - l) / 26, x = 1 << l;
        if (this.length <= _)
          return !1;
        var A = this.words[_];
        return !!(A & x);
      }, r.prototype.imaskn = function(a) {
        i(typeof a == "number" && a >= 0);
        var l = a % 26, _ = (a - l) / 26;
        if (i(this.negative === 0, "imaskn works only with positive numbers"), this.length <= _)
          return this;
        if (l !== 0 && _++, this.length = Math.min(_, this.length), l !== 0) {
          var x = 67108863 ^ 67108863 >>> l << l;
          this.words[this.length - 1] &= x;
        }
        return this._strip();
      }, r.prototype.maskn = function(a) {
        return this.clone().imaskn(a);
      }, r.prototype.iaddn = function(a) {
        return i(typeof a == "number"), i(a < 67108864), a < 0 ? this.isubn(-a) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= a ? (this.words[0] = a - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(a), this.negative = 1, this) : this._iaddn(a);
      }, r.prototype._iaddn = function(a) {
        this.words[0] += a;
        for (var l = 0; l < this.length && this.words[l] >= 67108864; l++)
          this.words[l] -= 67108864, l === this.length - 1 ? this.words[l + 1] = 1 : this.words[l + 1]++;
        return this.length = Math.max(this.length, l + 1), this;
      }, r.prototype.isubn = function(a) {
        if (i(typeof a == "number"), i(a < 67108864), a < 0)
          return this.iaddn(-a);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(a), this.negative = 1, this;
        if (this.words[0] -= a, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var l = 0; l < this.length && this.words[l] < 0; l++)
            this.words[l] += 67108864, this.words[l + 1] -= 1;
        return this._strip();
      }, r.prototype.addn = function(a) {
        return this.clone().iaddn(a);
      }, r.prototype.subn = function(a) {
        return this.clone().isubn(a);
      }, r.prototype.iabs = function() {
        return this.negative = 0, this;
      }, r.prototype.abs = function() {
        return this.clone().iabs();
      }, r.prototype._ishlnsubmul = function(a, l, _) {
        var x = a.length + _, A;
        this._expand(x);
        var S, g = 0;
        for (A = 0; A < a.length; A++) {
          S = (this.words[A + _] | 0) + g;
          var w = (a.words[A] | 0) * l;
          S -= w & 67108863, g = (S >> 26) - (w / 67108864 | 0), this.words[A + _] = S & 67108863;
        }
        for (; A < this.length - _; A++)
          S = (this.words[A + _] | 0) + g, g = S >> 26, this.words[A + _] = S & 67108863;
        if (g === 0)
          return this._strip();
        for (i(g === -1), g = 0, A = 0; A < this.length; A++)
          S = -(this.words[A] | 0) + g, g = S >> 26, this.words[A] = S & 67108863;
        return this.negative = 1, this._strip();
      }, r.prototype._wordDiv = function(a, l) {
        var _ = this.length - a.length, x = this.clone(), A = a, S = A.words[A.length - 1] | 0, g = this._countBits(S);
        _ = 26 - g, _ !== 0 && (A = A.ushln(_), x.iushln(_), S = A.words[A.length - 1] | 0);
        var w = x.length - A.length, d;
        if (l !== "mod") {
          d = new r(null), d.length = w + 1, d.words = new Array(d.length);
          for (var R = 0; R < d.length; R++)
            d.words[R] = 0;
        }
        var G = x.clone()._ishlnsubmul(A, 1, w);
        G.negative === 0 && (x = G, d && (d.words[w] = 1));
        for (var fe = w - 1; fe >= 0; fe--) {
          var z = (x.words[A.length + fe] | 0) * 67108864 + (x.words[A.length + fe - 1] | 0);
          for (z = Math.min(z / S | 0, 67108863), x._ishlnsubmul(A, z, fe); x.negative !== 0; )
            z--, x.negative = 0, x._ishlnsubmul(A, 1, fe), x.isZero() || (x.negative ^= 1);
          d && (d.words[fe] = z);
        }
        return d && d._strip(), x._strip(), l !== "div" && _ !== 0 && x.iushrn(_), {
          div: d || null,
          mod: x
        };
      }, r.prototype.divmod = function(a, l, _) {
        if (i(!a.isZero()), this.isZero())
          return {
            div: new r(0),
            mod: new r(0)
          };
        var x, A, S;
        return this.negative !== 0 && a.negative === 0 ? (S = this.neg().divmod(a, l), l !== "mod" && (x = S.div.neg()), l !== "div" && (A = S.mod.neg(), _ && A.negative !== 0 && A.iadd(a)), {
          div: x,
          mod: A
        }) : this.negative === 0 && a.negative !== 0 ? (S = this.divmod(a.neg(), l), l !== "mod" && (x = S.div.neg()), {
          div: x,
          mod: S.mod
        }) : this.negative & a.negative ? (S = this.neg().divmod(a.neg(), l), l !== "div" && (A = S.mod.neg(), _ && A.negative !== 0 && A.isub(a)), {
          div: S.div,
          mod: A
        }) : a.length > this.length || this.cmp(a) < 0 ? {
          div: new r(0),
          mod: this
        } : a.length === 1 ? l === "div" ? {
          div: this.divn(a.words[0]),
          mod: null
        } : l === "mod" ? {
          div: null,
          mod: new r(this.modrn(a.words[0]))
        } : {
          div: this.divn(a.words[0]),
          mod: new r(this.modrn(a.words[0]))
        } : this._wordDiv(a, l);
      }, r.prototype.div = function(a) {
        return this.divmod(a, "div", !1).div;
      }, r.prototype.mod = function(a) {
        return this.divmod(a, "mod", !1).mod;
      }, r.prototype.umod = function(a) {
        return this.divmod(a, "mod", !0).mod;
      }, r.prototype.divRound = function(a) {
        var l = this.divmod(a);
        if (l.mod.isZero())
          return l.div;
        var _ = l.div.negative !== 0 ? l.mod.isub(a) : l.mod, x = a.ushrn(1), A = a.andln(1), S = _.cmp(x);
        return S < 0 || A === 1 && S === 0 ? l.div : l.div.negative !== 0 ? l.div.isubn(1) : l.div.iaddn(1);
      }, r.prototype.modrn = function(a) {
        var l = a < 0;
        l && (a = -a), i(a <= 67108863);
        for (var _ = (1 << 26) % a, x = 0, A = this.length - 1; A >= 0; A--)
          x = (_ * x + (this.words[A] | 0)) % a;
        return l ? -x : x;
      }, r.prototype.modn = function(a) {
        return this.modrn(a);
      }, r.prototype.idivn = function(a) {
        var l = a < 0;
        l && (a = -a), i(a <= 67108863);
        for (var _ = 0, x = this.length - 1; x >= 0; x--) {
          var A = (this.words[x] | 0) + _ * 67108864;
          this.words[x] = A / a | 0, _ = A % a;
        }
        return this._strip(), l ? this.ineg() : this;
      }, r.prototype.divn = function(a) {
        return this.clone().idivn(a);
      }, r.prototype.egcd = function(a) {
        i(a.negative === 0), i(!a.isZero());
        var l = this, _ = a.clone();
        l.negative !== 0 ? l = l.umod(a) : l = l.clone();
        for (var x = new r(1), A = new r(0), S = new r(0), g = new r(1), w = 0; l.isEven() && _.isEven(); )
          l.iushrn(1), _.iushrn(1), ++w;
        for (var d = _.clone(), R = l.clone(); !l.isZero(); ) {
          for (var G = 0, fe = 1; !(l.words[0] & fe) && G < 26; ++G, fe <<= 1)
            ;
          if (G > 0)
            for (l.iushrn(G); G-- > 0; )
              (x.isOdd() || A.isOdd()) && (x.iadd(d), A.isub(R)), x.iushrn(1), A.iushrn(1);
          for (var z = 0, V = 1; !(_.words[0] & V) && z < 26; ++z, V <<= 1)
            ;
          if (z > 0)
            for (_.iushrn(z); z-- > 0; )
              (S.isOdd() || g.isOdd()) && (S.iadd(d), g.isub(R)), S.iushrn(1), g.iushrn(1);
          l.cmp(_) >= 0 ? (l.isub(_), x.isub(S), A.isub(g)) : (_.isub(l), S.isub(x), g.isub(A));
        }
        return {
          a: S,
          b: g,
          gcd: _.iushln(w)
        };
      }, r.prototype._invmp = function(a) {
        i(a.negative === 0), i(!a.isZero());
        var l = this, _ = a.clone();
        l.negative !== 0 ? l = l.umod(a) : l = l.clone();
        for (var x = new r(1), A = new r(0), S = _.clone(); l.cmpn(1) > 0 && _.cmpn(1) > 0; ) {
          for (var g = 0, w = 1; !(l.words[0] & w) && g < 26; ++g, w <<= 1)
            ;
          if (g > 0)
            for (l.iushrn(g); g-- > 0; )
              x.isOdd() && x.iadd(S), x.iushrn(1);
          for (var d = 0, R = 1; !(_.words[0] & R) && d < 26; ++d, R <<= 1)
            ;
          if (d > 0)
            for (_.iushrn(d); d-- > 0; )
              A.isOdd() && A.iadd(S), A.iushrn(1);
          l.cmp(_) >= 0 ? (l.isub(_), x.isub(A)) : (_.isub(l), A.isub(x));
        }
        var G;
        return l.cmpn(1) === 0 ? G = x : G = A, G.cmpn(0) < 0 && G.iadd(a), G;
      }, r.prototype.gcd = function(a) {
        if (this.isZero())
          return a.abs();
        if (a.isZero())
          return this.abs();
        var l = this.clone(), _ = a.clone();
        l.negative = 0, _.negative = 0;
        for (var x = 0; l.isEven() && _.isEven(); x++)
          l.iushrn(1), _.iushrn(1);
        do {
          for (; l.isEven(); )
            l.iushrn(1);
          for (; _.isEven(); )
            _.iushrn(1);
          var A = l.cmp(_);
          if (A < 0) {
            var S = l;
            l = _, _ = S;
          } else if (A === 0 || _.cmpn(1) === 0)
            break;
          l.isub(_);
        } while (!0);
        return _.iushln(x);
      }, r.prototype.invm = function(a) {
        return this.egcd(a).a.umod(a);
      }, r.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, r.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, r.prototype.andln = function(a) {
        return this.words[0] & a;
      }, r.prototype.bincn = function(a) {
        i(typeof a == "number");
        var l = a % 26, _ = (a - l) / 26, x = 1 << l;
        if (this.length <= _)
          return this._expand(_ + 1), this.words[_] |= x, this;
        for (var A = x, S = _; A !== 0 && S < this.length; S++) {
          var g = this.words[S] | 0;
          g += A, A = g >>> 26, g &= 67108863, this.words[S] = g;
        }
        return A !== 0 && (this.words[S] = A, this.length++), this;
      }, r.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, r.prototype.cmpn = function(a) {
        var l = a < 0;
        if (this.negative !== 0 && !l)
          return -1;
        if (this.negative === 0 && l)
          return 1;
        this._strip();
        var _;
        if (this.length > 1)
          _ = 1;
        else {
          l && (a = -a), i(a <= 67108863, "Number is too big");
          var x = this.words[0] | 0;
          _ = x === a ? 0 : x < a ? -1 : 1;
        }
        return this.negative !== 0 ? -_ | 0 : _;
      }, r.prototype.cmp = function(a) {
        if (this.negative !== 0 && a.negative === 0)
          return -1;
        if (this.negative === 0 && a.negative !== 0)
          return 1;
        var l = this.ucmp(a);
        return this.negative !== 0 ? -l | 0 : l;
      }, r.prototype.ucmp = function(a) {
        if (this.length > a.length)
          return 1;
        if (this.length < a.length)
          return -1;
        for (var l = 0, _ = this.length - 1; _ >= 0; _--) {
          var x = this.words[_] | 0, A = a.words[_] | 0;
          if (x !== A) {
            x < A ? l = -1 : x > A && (l = 1);
            break;
          }
        }
        return l;
      }, r.prototype.gtn = function(a) {
        return this.cmpn(a) === 1;
      }, r.prototype.gt = function(a) {
        return this.cmp(a) === 1;
      }, r.prototype.gten = function(a) {
        return this.cmpn(a) >= 0;
      }, r.prototype.gte = function(a) {
        return this.cmp(a) >= 0;
      }, r.prototype.ltn = function(a) {
        return this.cmpn(a) === -1;
      }, r.prototype.lt = function(a) {
        return this.cmp(a) === -1;
      }, r.prototype.lten = function(a) {
        return this.cmpn(a) <= 0;
      }, r.prototype.lte = function(a) {
        return this.cmp(a) <= 0;
      }, r.prototype.eqn = function(a) {
        return this.cmpn(a) === 0;
      }, r.prototype.eq = function(a) {
        return this.cmp(a) === 0;
      }, r.red = function(a) {
        return new U(a);
      }, r.prototype.toRed = function(a) {
        return i(!this.red, "Already a number in reduction context"), i(this.negative === 0, "red works only with positives"), a.convertTo(this)._forceRed(a);
      }, r.prototype.fromRed = function() {
        return i(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, r.prototype._forceRed = function(a) {
        return this.red = a, this;
      }, r.prototype.forceRed = function(a) {
        return i(!this.red, "Already a number in reduction context"), this._forceRed(a);
      }, r.prototype.redAdd = function(a) {
        return i(this.red, "redAdd works only with red numbers"), this.red.add(this, a);
      }, r.prototype.redIAdd = function(a) {
        return i(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, a);
      }, r.prototype.redSub = function(a) {
        return i(this.red, "redSub works only with red numbers"), this.red.sub(this, a);
      }, r.prototype.redISub = function(a) {
        return i(this.red, "redISub works only with red numbers"), this.red.isub(this, a);
      }, r.prototype.redShl = function(a) {
        return i(this.red, "redShl works only with red numbers"), this.red.shl(this, a);
      }, r.prototype.redMul = function(a) {
        return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.mul(this, a);
      }, r.prototype.redIMul = function(a) {
        return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.imul(this, a);
      }, r.prototype.redSqr = function() {
        return i(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, r.prototype.redISqr = function() {
        return i(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, r.prototype.redSqrt = function() {
        return i(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, r.prototype.redInvm = function() {
        return i(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, r.prototype.redNeg = function() {
        return i(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, r.prototype.redPow = function(a) {
        return i(this.red && !a.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, a);
      };
      var N = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function q(p, a) {
        this.name = p, this.p = new r(a, 16), this.n = this.p.bitLength(), this.k = new r(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      q.prototype._tmp = function() {
        var a = new r(null);
        return a.words = new Array(Math.ceil(this.n / 13)), a;
      }, q.prototype.ireduce = function(a) {
        var l = a, _;
        do
          this.split(l, this.tmp), l = this.imulK(l), l = l.iadd(this.tmp), _ = l.bitLength();
        while (_ > this.n);
        var x = _ < this.n ? -1 : l.ucmp(this.p);
        return x === 0 ? (l.words[0] = 0, l.length = 1) : x > 0 ? l.isub(this.p) : l.strip !== void 0 ? l.strip() : l._strip(), l;
      }, q.prototype.split = function(a, l) {
        a.iushrn(this.n, 0, l);
      }, q.prototype.imulK = function(a) {
        return a.imul(this.k);
      };
      function D() {
        q.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      s(D, q), D.prototype.split = function(a, l) {
        for (var _ = 4194303, x = Math.min(a.length, 9), A = 0; A < x; A++)
          l.words[A] = a.words[A];
        if (l.length = x, a.length <= 9) {
          a.words[0] = 0, a.length = 1;
          return;
        }
        var S = a.words[9];
        for (l.words[l.length++] = S & _, A = 10; A < a.length; A++) {
          var g = a.words[A] | 0;
          a.words[A - 10] = (g & _) << 4 | S >>> 22, S = g;
        }
        S >>>= 22, a.words[A - 10] = S, S === 0 && a.length > 10 ? a.length -= 10 : a.length -= 9;
      }, D.prototype.imulK = function(a) {
        a.words[a.length] = 0, a.words[a.length + 1] = 0, a.length += 2;
        for (var l = 0, _ = 0; _ < a.length; _++) {
          var x = a.words[_] | 0;
          l += x * 977, a.words[_] = l & 67108863, l = x * 64 + (l / 67108864 | 0);
        }
        return a.words[a.length - 1] === 0 && (a.length--, a.words[a.length - 1] === 0 && a.length--), a;
      };
      function re() {
        q.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      s(re, q);
      function te() {
        q.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      s(te, q);
      function oe() {
        q.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      s(oe, q), oe.prototype.imulK = function(a) {
        for (var l = 0, _ = 0; _ < a.length; _++) {
          var x = (a.words[_] | 0) * 19 + l, A = x & 67108863;
          x >>>= 26, a.words[_] = A, l = x;
        }
        return l !== 0 && (a.words[a.length++] = l), a;
      }, r._prime = function(a) {
        if (N[a])
          return N[a];
        var l;
        if (a === "k256")
          l = new D();
        else if (a === "p224")
          l = new re();
        else if (a === "p192")
          l = new te();
        else if (a === "p25519")
          l = new oe();
        else
          throw new Error("Unknown prime " + a);
        return N[a] = l, l;
      };
      function U(p) {
        if (typeof p == "string") {
          var a = r._prime(p);
          this.m = a.p, this.prime = a;
        } else
          i(p.gtn(1), "modulus must be greater than 1"), this.m = p, this.prime = null;
      }
      U.prototype._verify1 = function(a) {
        i(a.negative === 0, "red works only with positives"), i(a.red, "red works only with red numbers");
      }, U.prototype._verify2 = function(a, l) {
        i((a.negative | l.negative) === 0, "red works only with positives"), i(
          a.red && a.red === l.red,
          "red works only with red numbers"
        );
      }, U.prototype.imod = function(a) {
        return this.prime ? this.prime.ireduce(a)._forceRed(this) : (f(a, a.umod(this.m)._forceRed(this)), a);
      }, U.prototype.neg = function(a) {
        return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this);
      }, U.prototype.add = function(a, l) {
        this._verify2(a, l);
        var _ = a.add(l);
        return _.cmp(this.m) >= 0 && _.isub(this.m), _._forceRed(this);
      }, U.prototype.iadd = function(a, l) {
        this._verify2(a, l);
        var _ = a.iadd(l);
        return _.cmp(this.m) >= 0 && _.isub(this.m), _;
      }, U.prototype.sub = function(a, l) {
        this._verify2(a, l);
        var _ = a.sub(l);
        return _.cmpn(0) < 0 && _.iadd(this.m), _._forceRed(this);
      }, U.prototype.isub = function(a, l) {
        this._verify2(a, l);
        var _ = a.isub(l);
        return _.cmpn(0) < 0 && _.iadd(this.m), _;
      }, U.prototype.shl = function(a, l) {
        return this._verify1(a), this.imod(a.ushln(l));
      }, U.prototype.imul = function(a, l) {
        return this._verify2(a, l), this.imod(a.imul(l));
      }, U.prototype.mul = function(a, l) {
        return this._verify2(a, l), this.imod(a.mul(l));
      }, U.prototype.isqr = function(a) {
        return this.imul(a, a.clone());
      }, U.prototype.sqr = function(a) {
        return this.mul(a, a);
      }, U.prototype.sqrt = function(a) {
        if (a.isZero())
          return a.clone();
        var l = this.m.andln(3);
        if (i(l % 2 === 1), l === 3) {
          var _ = this.m.add(new r(1)).iushrn(2);
          return this.pow(a, _);
        }
        for (var x = this.m.subn(1), A = 0; !x.isZero() && x.andln(1) === 0; )
          A++, x.iushrn(1);
        i(!x.isZero());
        var S = new r(1).toRed(this), g = S.redNeg(), w = this.m.subn(1).iushrn(1), d = this.m.bitLength();
        for (d = new r(2 * d * d).toRed(this); this.pow(d, w).cmp(g) !== 0; )
          d.redIAdd(g);
        for (var R = this.pow(d, x), G = this.pow(a, x.addn(1).iushrn(1)), fe = this.pow(a, x), z = A; fe.cmp(S) !== 0; ) {
          for (var V = fe, F = 0; V.cmp(S) !== 0; F++)
            V = V.redSqr();
          i(F < z);
          var ee = this.pow(R, new r(1).iushln(z - F - 1));
          G = G.redMul(ee), R = ee.redSqr(), fe = fe.redMul(R), z = F;
        }
        return G;
      }, U.prototype.invm = function(a) {
        var l = a._invmp(this.m);
        return l.negative !== 0 ? (l.negative = 0, this.imod(l).redNeg()) : this.imod(l);
      }, U.prototype.pow = function(a, l) {
        if (l.isZero())
          return new r(1).toRed(this);
        if (l.cmpn(1) === 0)
          return a.clone();
        var _ = 4, x = new Array(1 << _);
        x[0] = new r(1).toRed(this), x[1] = a;
        for (var A = 2; A < x.length; A++)
          x[A] = this.mul(x[A - 1], a);
        var S = x[0], g = 0, w = 0, d = l.bitLength() % 26;
        for (d === 0 && (d = 26), A = l.length - 1; A >= 0; A--) {
          for (var R = l.words[A], G = d - 1; G >= 0; G--) {
            var fe = R >> G & 1;
            if (S !== x[0] && (S = this.sqr(S)), fe === 0 && g === 0) {
              w = 0;
              continue;
            }
            g <<= 1, g |= fe, w++, !(w !== _ && (A !== 0 || G !== 0)) && (S = this.mul(S, x[g]), w = 0, g = 0);
          }
          d = 26;
        }
        return S;
      }, U.prototype.convertTo = function(a) {
        var l = a.umod(this.m);
        return l === a ? l.clone() : l;
      }, U.prototype.convertFrom = function(a) {
        var l = a.clone();
        return l.red = null, l;
      }, r.mont = function(a) {
        return new y(a);
      };
      function y(p) {
        U.call(this, p), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new r(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      s(y, U), y.prototype.convertTo = function(a) {
        return this.imod(a.ushln(this.shift));
      }, y.prototype.convertFrom = function(a) {
        var l = this.imod(a.mul(this.rinv));
        return l.red = null, l;
      }, y.prototype.imul = function(a, l) {
        if (a.isZero() || l.isZero())
          return a.words[0] = 0, a.length = 1, a;
        var _ = a.imul(l), x = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = _.isub(x).iushrn(this.shift), S = A;
        return A.cmp(this.m) >= 0 ? S = A.isub(this.m) : A.cmpn(0) < 0 && (S = A.iadd(this.m)), S._forceRed(this);
      }, y.prototype.mul = function(a, l) {
        if (a.isZero() || l.isZero())
          return new r(0)._forceRed(this);
        var _ = a.mul(l), x = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = _.isub(x).iushrn(this.shift), S = A;
        return A.cmp(this.m) >= 0 ? S = A.isub(this.m) : A.cmpn(0) < 0 && (S = A.iadd(this.m)), S._forceRed(this);
      }, y.prototype.invm = function(a) {
        var l = this.imod(a._invmp(this.m).mul(this.r2));
        return l._forceRed(this);
      };
    })(e, Ze);
  }(pa)), pa.exports;
}
var nu, p1;
function g0() {
  if (p1)
    return nu;
  p1 = 1;
  var e = V5(), t = ci();
  function n(r) {
    var o = i(r), u = o.toRed(e.mont(r.modulus)).redPow(new e(r.publicExponent)).fromRed();
    return { blinder: u, unblinder: o.invm(r.modulus) };
  }
  function i(r) {
    var o = r.modulus.byteLength(), u;
    do
      u = new e(t(o));
    while (u.cmp(r.modulus) >= 0 || !u.umod(r.prime1) || !u.umod(r.prime2));
    return u;
  }
  function s(r, o) {
    var u = n(o), c = o.modulus.byteLength(), h = new e(r).mul(u.blinder).umod(o.modulus), f = h.toRed(e.mont(o.prime1)), b = h.toRed(e.mont(o.prime2)), v = o.coefficient, m = o.prime1, E = o.prime2, M = f.redPow(o.exponent1).fromRed(), B = b.redPow(o.exponent2).fromRed(), I = M.isub(B).imul(v).umod(m).imul(E);
    return B.iadd(I).imul(u.unblinder).umod(o.modulus).toArrayLike(Buffer, "be", c);
  }
  return s.getr = i, nu = s, nu;
}
var iu = {};
const K5 = "elliptic", Z5 = "6.5.4", G5 = "EC cryptography", W5 = "lib/elliptic.js", J5 = [
  "lib"
], X5 = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, Y5 = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, Q5 = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], ex = "Fedor Indutny <fedor@indutny.com>", tx = "MIT", rx = {
  url: "https://github.com/indutny/elliptic/issues"
}, nx = "https://github.com/indutny/elliptic", ix = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, ax = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, fx = {
  name: K5,
  version: Z5,
  description: G5,
  main: W5,
  files: J5,
  scripts: X5,
  repository: Y5,
  keywords: Q5,
  author: ex,
  license: tx,
  bugs: rx,
  homepage: nx,
  devDependencies: ix,
  dependencies: ax
};
var au = {}, fu = {}, v1;
function cy() {
  return v1 || (v1 = 1, function(e) {
    var t = e;
    function n(r, o) {
      if (Array.isArray(r))
        return r.slice();
      if (!r)
        return [];
      var u = [];
      if (typeof r != "string") {
        for (var c = 0; c < r.length; c++)
          u[c] = r[c] | 0;
        return u;
      }
      if (o === "hex") {
        r = r.replace(/[^a-z0-9]+/ig, ""), r.length % 2 !== 0 && (r = "0" + r);
        for (var c = 0; c < r.length; c += 2)
          u.push(parseInt(r[c] + r[c + 1], 16));
      } else
        for (var c = 0; c < r.length; c++) {
          var h = r.charCodeAt(c), f = h >> 8, b = h & 255;
          f ? u.push(f, b) : u.push(b);
        }
      return u;
    }
    t.toArray = n;
    function i(r) {
      return r.length === 1 ? "0" + r : r;
    }
    t.zero2 = i;
    function s(r) {
      for (var o = "", u = 0; u < r.length; u++)
        o += i(r[u].toString(16));
      return o;
    }
    t.toHex = s, t.encode = function(o, u) {
      return u === "hex" ? s(o) : o;
    };
  }(fu)), fu;
}
var b1;
function Or() {
  return b1 || (b1 = 1, function(e) {
    var t = e, n = Wt, i = Tr(), s = cy();
    t.assert = i, t.toArray = s.toArray, t.zero2 = s.zero2, t.toHex = s.toHex, t.encode = s.encode;
    function r(f, b, v) {
      var m = new Array(Math.max(f.bitLength(), v) + 1);
      m.fill(0);
      for (var E = 1 << b + 1, M = f.clone(), B = 0; B < m.length; B++) {
        var I, T = M.andln(E - 1);
        M.isOdd() ? (T > (E >> 1) - 1 ? I = (E >> 1) - T : I = T, M.isubn(I)) : I = 0, m[B] = I, M.iushrn(1);
      }
      return m;
    }
    t.getNAF = r;
    function o(f, b) {
      var v = [
        [],
        []
      ];
      f = f.clone(), b = b.clone();
      for (var m = 0, E = 0, M; f.cmpn(-m) > 0 || b.cmpn(-E) > 0; ) {
        var B = f.andln(3) + m & 3, I = b.andln(3) + E & 3;
        B === 3 && (B = -1), I === 3 && (I = -1);
        var T;
        B & 1 ? (M = f.andln(7) + m & 7, (M === 3 || M === 5) && I === 2 ? T = -B : T = B) : T = 0, v[0].push(T);
        var k;
        I & 1 ? (M = b.andln(7) + E & 7, (M === 3 || M === 5) && B === 2 ? k = -I : k = I) : k = 0, v[1].push(k), 2 * m === T + 1 && (m = 1 - m), 2 * E === k + 1 && (E = 1 - E), f.iushrn(1), b.iushrn(1);
      }
      return v;
    }
    t.getJSF = o;
    function u(f, b, v) {
      var m = "_" + b;
      f.prototype[b] = function() {
        return this[m] !== void 0 ? this[m] : this[m] = v.call(this);
      };
    }
    t.cachedProperty = u;
    function c(f) {
      return typeof f == "string" ? t.toArray(f, "hex") : f;
    }
    t.parseBytes = c;
    function h(f) {
      return new n(f, "hex", "le");
    }
    t.intFromLE = h;
  }(au)), au;
}
var ou = {}, su, y1;
function wf() {
  if (y1)
    return su;
  y1 = 1;
  var e = Wt, t = Or(), n = t.getNAF, i = t.getJSF, s = t.assert;
  function r(u, c) {
    this.type = u, this.p = new e(c.p, 16), this.red = c.prime ? e.red(c.prime) : e.mont(this.p), this.zero = new e(0).toRed(this.red), this.one = new e(1).toRed(this.red), this.two = new e(2).toRed(this.red), this.n = c.n && new e(c.n, 16), this.g = c.g && this.pointFromJSON(c.g, c.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var h = this.n && this.p.div(this.n);
    !h || h.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  su = r, r.prototype.point = function() {
    throw new Error("Not implemented");
  }, r.prototype.validate = function() {
    throw new Error("Not implemented");
  }, r.prototype._fixedNafMul = function(c, h) {
    s(c.precomputed);
    var f = c._getDoubles(), b = n(h, 1, this._bitLength), v = (1 << f.step + 1) - (f.step % 2 === 0 ? 2 : 1);
    v /= 3;
    var m = [], E, M;
    for (E = 0; E < b.length; E += f.step) {
      M = 0;
      for (var B = E + f.step - 1; B >= E; B--)
        M = (M << 1) + b[B];
      m.push(M);
    }
    for (var I = this.jpoint(null, null, null), T = this.jpoint(null, null, null), k = v; k > 0; k--) {
      for (E = 0; E < m.length; E++)
        M = m[E], M === k ? T = T.mixedAdd(f.points[E]) : M === -k && (T = T.mixedAdd(f.points[E].neg()));
      I = I.add(T);
    }
    return I.toP();
  }, r.prototype._wnafMul = function(c, h) {
    var f = 4, b = c._getNAFPoints(f);
    f = b.wnd;
    for (var v = b.points, m = n(h, f, this._bitLength), E = this.jpoint(null, null, null), M = m.length - 1; M >= 0; M--) {
      for (var B = 0; M >= 0 && m[M] === 0; M--)
        B++;
      if (M >= 0 && B++, E = E.dblp(B), M < 0)
        break;
      var I = m[M];
      s(I !== 0), c.type === "affine" ? I > 0 ? E = E.mixedAdd(v[I - 1 >> 1]) : E = E.mixedAdd(v[-I - 1 >> 1].neg()) : I > 0 ? E = E.add(v[I - 1 >> 1]) : E = E.add(v[-I - 1 >> 1].neg());
    }
    return c.type === "affine" ? E.toP() : E;
  }, r.prototype._wnafMulAdd = function(c, h, f, b, v) {
    var m = this._wnafT1, E = this._wnafT2, M = this._wnafT3, B = 0, I, T, k;
    for (I = 0; I < b; I++) {
      k = h[I];
      var j = k._getNAFPoints(c);
      m[I] = j.wnd, E[I] = j.points;
    }
    for (I = b - 1; I >= 1; I -= 2) {
      var N = I - 1, q = I;
      if (m[N] !== 1 || m[q] !== 1) {
        M[N] = n(f[N], m[N], this._bitLength), M[q] = n(f[q], m[q], this._bitLength), B = Math.max(M[N].length, B), B = Math.max(M[q].length, B);
        continue;
      }
      var D = [
        h[N],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        h[q]
        /* 7 */
      ];
      h[N].y.cmp(h[q].y) === 0 ? (D[1] = h[N].add(h[q]), D[2] = h[N].toJ().mixedAdd(h[q].neg())) : h[N].y.cmp(h[q].y.redNeg()) === 0 ? (D[1] = h[N].toJ().mixedAdd(h[q]), D[2] = h[N].add(h[q].neg())) : (D[1] = h[N].toJ().mixedAdd(h[q]), D[2] = h[N].toJ().mixedAdd(h[q].neg()));
      var re = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], te = i(f[N], f[q]);
      for (B = Math.max(te[0].length, B), M[N] = new Array(B), M[q] = new Array(B), T = 0; T < B; T++) {
        var oe = te[0][T] | 0, U = te[1][T] | 0;
        M[N][T] = re[(oe + 1) * 3 + (U + 1)], M[q][T] = 0, E[N] = D;
      }
    }
    var y = this.jpoint(null, null, null), p = this._wnafT4;
    for (I = B; I >= 0; I--) {
      for (var a = 0; I >= 0; ) {
        var l = !0;
        for (T = 0; T < b; T++)
          p[T] = M[T][I] | 0, p[T] !== 0 && (l = !1);
        if (!l)
          break;
        a++, I--;
      }
      if (I >= 0 && a++, y = y.dblp(a), I < 0)
        break;
      for (T = 0; T < b; T++) {
        var _ = p[T];
        _ !== 0 && (_ > 0 ? k = E[T][_ - 1 >> 1] : _ < 0 && (k = E[T][-_ - 1 >> 1].neg()), k.type === "affine" ? y = y.mixedAdd(k) : y = y.add(k));
      }
    }
    for (I = 0; I < b; I++)
      E[I] = null;
    return v ? y : y.toP();
  };
  function o(u, c) {
    this.curve = u, this.type = c, this.precomputed = null;
  }
  return r.BasePoint = o, o.prototype.eq = function() {
    throw new Error("Not implemented");
  }, o.prototype.validate = function() {
    return this.curve.validate(this);
  }, r.prototype.decodePoint = function(c, h) {
    c = t.toArray(c, h);
    var f = this.p.byteLength();
    if ((c[0] === 4 || c[0] === 6 || c[0] === 7) && c.length - 1 === 2 * f) {
      c[0] === 6 ? s(c[c.length - 1] % 2 === 0) : c[0] === 7 && s(c[c.length - 1] % 2 === 1);
      var b = this.point(
        c.slice(1, 1 + f),
        c.slice(1 + f, 1 + 2 * f)
      );
      return b;
    } else if ((c[0] === 2 || c[0] === 3) && c.length - 1 === f)
      return this.pointFromX(c.slice(1, 1 + f), c[0] === 3);
    throw new Error("Unknown point format");
  }, o.prototype.encodeCompressed = function(c) {
    return this.encode(c, !0);
  }, o.prototype._encode = function(c) {
    var h = this.curve.p.byteLength(), f = this.getX().toArray("be", h);
    return c ? [this.getY().isEven() ? 2 : 3].concat(f) : [4].concat(f, this.getY().toArray("be", h));
  }, o.prototype.encode = function(c, h) {
    return t.encode(this._encode(h), c);
  }, o.prototype.precompute = function(c) {
    if (this.precomputed)
      return this;
    var h = {
      doubles: null,
      naf: null,
      beta: null
    };
    return h.naf = this._getNAFPoints(8), h.doubles = this._getDoubles(4, c), h.beta = this._getBeta(), this.precomputed = h, this;
  }, o.prototype._hasDoubles = function(c) {
    if (!this.precomputed)
      return !1;
    var h = this.precomputed.doubles;
    return h ? h.points.length >= Math.ceil((c.bitLength() + 1) / h.step) : !1;
  }, o.prototype._getDoubles = function(c, h) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var f = [this], b = this, v = 0; v < h; v += c) {
      for (var m = 0; m < c; m++)
        b = b.dbl();
      f.push(b);
    }
    return {
      step: c,
      points: f
    };
  }, o.prototype._getNAFPoints = function(c) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var h = [this], f = (1 << c) - 1, b = f === 1 ? null : this.dbl(), v = 1; v < f; v++)
      h[v] = h[v - 1].add(b);
    return {
      wnd: c,
      points: h
    };
  }, o.prototype._getBeta = function() {
    return null;
  }, o.prototype.dblp = function(c) {
    for (var h = this, f = 0; f < c; f++)
      h = h.dbl();
    return h;
  }, su;
}
var uu, g1;
function ox() {
  if (g1)
    return uu;
  g1 = 1;
  var e = Or(), t = Wt, n = mt(), i = wf(), s = e.assert;
  function r(c) {
    i.call(this, "short", c), this.a = new t(c.a, 16).toRed(this.red), this.b = new t(c.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(c), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  n(r, i), uu = r, r.prototype._getEndomorphism = function(h) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var f, b;
      if (h.beta)
        f = new t(h.beta, 16).toRed(this.red);
      else {
        var v = this._getEndoRoots(this.p);
        f = v[0].cmp(v[1]) < 0 ? v[0] : v[1], f = f.toRed(this.red);
      }
      if (h.lambda)
        b = new t(h.lambda, 16);
      else {
        var m = this._getEndoRoots(this.n);
        this.g.mul(m[0]).x.cmp(this.g.x.redMul(f)) === 0 ? b = m[0] : (b = m[1], s(this.g.mul(b).x.cmp(this.g.x.redMul(f)) === 0));
      }
      var E;
      return h.basis ? E = h.basis.map(function(M) {
        return {
          a: new t(M.a, 16),
          b: new t(M.b, 16)
        };
      }) : E = this._getEndoBasis(b), {
        beta: f,
        lambda: b,
        basis: E
      };
    }
  }, r.prototype._getEndoRoots = function(h) {
    var f = h === this.p ? this.red : t.mont(h), b = new t(2).toRed(f).redInvm(), v = b.redNeg(), m = new t(3).toRed(f).redNeg().redSqrt().redMul(b), E = v.redAdd(m).fromRed(), M = v.redSub(m).fromRed();
    return [E, M];
  }, r.prototype._getEndoBasis = function(h) {
    for (var f = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), b = h, v = this.n.clone(), m = new t(1), E = new t(0), M = new t(0), B = new t(1), I, T, k, j, N, q, D, re = 0, te, oe; b.cmpn(0) !== 0; ) {
      var U = v.div(b);
      te = v.sub(U.mul(b)), oe = M.sub(U.mul(m));
      var y = B.sub(U.mul(E));
      if (!k && te.cmp(f) < 0)
        I = D.neg(), T = m, k = te.neg(), j = oe;
      else if (k && ++re === 2)
        break;
      D = te, v = b, b = te, M = m, m = oe, B = E, E = y;
    }
    N = te.neg(), q = oe;
    var p = k.sqr().add(j.sqr()), a = N.sqr().add(q.sqr());
    return a.cmp(p) >= 0 && (N = I, q = T), k.negative && (k = k.neg(), j = j.neg()), N.negative && (N = N.neg(), q = q.neg()), [
      { a: k, b: j },
      { a: N, b: q }
    ];
  }, r.prototype._endoSplit = function(h) {
    var f = this.endo.basis, b = f[0], v = f[1], m = v.b.mul(h).divRound(this.n), E = b.b.neg().mul(h).divRound(this.n), M = m.mul(b.a), B = E.mul(v.a), I = m.mul(b.b), T = E.mul(v.b), k = h.sub(M).sub(B), j = I.add(T).neg();
    return { k1: k, k2: j };
  }, r.prototype.pointFromX = function(h, f) {
    h = new t(h, 16), h.red || (h = h.toRed(this.red));
    var b = h.redSqr().redMul(h).redIAdd(h.redMul(this.a)).redIAdd(this.b), v = b.redSqrt();
    if (v.redSqr().redSub(b).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var m = v.fromRed().isOdd();
    return (f && !m || !f && m) && (v = v.redNeg()), this.point(h, v);
  }, r.prototype.validate = function(h) {
    if (h.inf)
      return !0;
    var f = h.x, b = h.y, v = this.a.redMul(f), m = f.redSqr().redMul(f).redIAdd(v).redIAdd(this.b);
    return b.redSqr().redISub(m).cmpn(0) === 0;
  }, r.prototype._endoWnafMulAdd = function(h, f, b) {
    for (var v = this._endoWnafT1, m = this._endoWnafT2, E = 0; E < h.length; E++) {
      var M = this._endoSplit(f[E]), B = h[E], I = B._getBeta();
      M.k1.negative && (M.k1.ineg(), B = B.neg(!0)), M.k2.negative && (M.k2.ineg(), I = I.neg(!0)), v[E * 2] = B, v[E * 2 + 1] = I, m[E * 2] = M.k1, m[E * 2 + 1] = M.k2;
    }
    for (var T = this._wnafMulAdd(1, v, m, E * 2, b), k = 0; k < E * 2; k++)
      v[k] = null, m[k] = null;
    return T;
  };
  function o(c, h, f, b) {
    i.BasePoint.call(this, c, "affine"), h === null && f === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new t(h, 16), this.y = new t(f, 16), b && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  n(o, i.BasePoint), r.prototype.point = function(h, f, b) {
    return new o(this, h, f, b);
  }, r.prototype.pointFromJSON = function(h, f) {
    return o.fromJSON(this, h, f);
  }, o.prototype._getBeta = function() {
    if (this.curve.endo) {
      var h = this.precomputed;
      if (h && h.beta)
        return h.beta;
      var f = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (h) {
        var b = this.curve, v = function(m) {
          return b.point(m.x.redMul(b.endo.beta), m.y);
        };
        h.beta = f, f.precomputed = {
          beta: null,
          naf: h.naf && {
            wnd: h.naf.wnd,
            points: h.naf.points.map(v)
          },
          doubles: h.doubles && {
            step: h.doubles.step,
            points: h.doubles.points.map(v)
          }
        };
      }
      return f;
    }
  }, o.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, o.fromJSON = function(h, f, b) {
    typeof f == "string" && (f = JSON.parse(f));
    var v = h.point(f[0], f[1], b);
    if (!f[2])
      return v;
    function m(M) {
      return h.point(M[0], M[1], b);
    }
    var E = f[2];
    return v.precomputed = {
      beta: null,
      doubles: E.doubles && {
        step: E.doubles.step,
        points: [v].concat(E.doubles.points.map(m))
      },
      naf: E.naf && {
        wnd: E.naf.wnd,
        points: [v].concat(E.naf.points.map(m))
      }
    }, v;
  }, o.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, o.prototype.isInfinity = function() {
    return this.inf;
  }, o.prototype.add = function(h) {
    if (this.inf)
      return h;
    if (h.inf)
      return this;
    if (this.eq(h))
      return this.dbl();
    if (this.neg().eq(h))
      return this.curve.point(null, null);
    if (this.x.cmp(h.x) === 0)
      return this.curve.point(null, null);
    var f = this.y.redSub(h.y);
    f.cmpn(0) !== 0 && (f = f.redMul(this.x.redSub(h.x).redInvm()));
    var b = f.redSqr().redISub(this.x).redISub(h.x), v = f.redMul(this.x.redSub(b)).redISub(this.y);
    return this.curve.point(b, v);
  }, o.prototype.dbl = function() {
    if (this.inf)
      return this;
    var h = this.y.redAdd(this.y);
    if (h.cmpn(0) === 0)
      return this.curve.point(null, null);
    var f = this.curve.a, b = this.x.redSqr(), v = h.redInvm(), m = b.redAdd(b).redIAdd(b).redIAdd(f).redMul(v), E = m.redSqr().redISub(this.x.redAdd(this.x)), M = m.redMul(this.x.redSub(E)).redISub(this.y);
    return this.curve.point(E, M);
  }, o.prototype.getX = function() {
    return this.x.fromRed();
  }, o.prototype.getY = function() {
    return this.y.fromRed();
  }, o.prototype.mul = function(h) {
    return h = new t(h, 16), this.isInfinity() ? this : this._hasDoubles(h) ? this.curve._fixedNafMul(this, h) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [h]) : this.curve._wnafMul(this, h);
  }, o.prototype.mulAdd = function(h, f, b) {
    var v = [this, f], m = [h, b];
    return this.curve.endo ? this.curve._endoWnafMulAdd(v, m) : this.curve._wnafMulAdd(1, v, m, 2);
  }, o.prototype.jmulAdd = function(h, f, b) {
    var v = [this, f], m = [h, b];
    return this.curve.endo ? this.curve._endoWnafMulAdd(v, m, !0) : this.curve._wnafMulAdd(1, v, m, 2, !0);
  }, o.prototype.eq = function(h) {
    return this === h || this.inf === h.inf && (this.inf || this.x.cmp(h.x) === 0 && this.y.cmp(h.y) === 0);
  }, o.prototype.neg = function(h) {
    if (this.inf)
      return this;
    var f = this.curve.point(this.x, this.y.redNeg());
    if (h && this.precomputed) {
      var b = this.precomputed, v = function(m) {
        return m.neg();
      };
      f.precomputed = {
        naf: b.naf && {
          wnd: b.naf.wnd,
          points: b.naf.points.map(v)
        },
        doubles: b.doubles && {
          step: b.doubles.step,
          points: b.doubles.points.map(v)
        }
      };
    }
    return f;
  }, o.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var h = this.curve.jpoint(this.x, this.y, this.curve.one);
    return h;
  };
  function u(c, h, f, b) {
    i.BasePoint.call(this, c, "jacobian"), h === null && f === null && b === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new t(0)) : (this.x = new t(h, 16), this.y = new t(f, 16), this.z = new t(b, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return n(u, i.BasePoint), r.prototype.jpoint = function(h, f, b) {
    return new u(this, h, f, b);
  }, u.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var h = this.z.redInvm(), f = h.redSqr(), b = this.x.redMul(f), v = this.y.redMul(f).redMul(h);
    return this.curve.point(b, v);
  }, u.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, u.prototype.add = function(h) {
    if (this.isInfinity())
      return h;
    if (h.isInfinity())
      return this;
    var f = h.z.redSqr(), b = this.z.redSqr(), v = this.x.redMul(f), m = h.x.redMul(b), E = this.y.redMul(f.redMul(h.z)), M = h.y.redMul(b.redMul(this.z)), B = v.redSub(m), I = E.redSub(M);
    if (B.cmpn(0) === 0)
      return I.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var T = B.redSqr(), k = T.redMul(B), j = v.redMul(T), N = I.redSqr().redIAdd(k).redISub(j).redISub(j), q = I.redMul(j.redISub(N)).redISub(E.redMul(k)), D = this.z.redMul(h.z).redMul(B);
    return this.curve.jpoint(N, q, D);
  }, u.prototype.mixedAdd = function(h) {
    if (this.isInfinity())
      return h.toJ();
    if (h.isInfinity())
      return this;
    var f = this.z.redSqr(), b = this.x, v = h.x.redMul(f), m = this.y, E = h.y.redMul(f).redMul(this.z), M = b.redSub(v), B = m.redSub(E);
    if (M.cmpn(0) === 0)
      return B.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var I = M.redSqr(), T = I.redMul(M), k = b.redMul(I), j = B.redSqr().redIAdd(T).redISub(k).redISub(k), N = B.redMul(k.redISub(j)).redISub(m.redMul(T)), q = this.z.redMul(M);
    return this.curve.jpoint(j, N, q);
  }, u.prototype.dblp = function(h) {
    if (h === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!h)
      return this.dbl();
    var f;
    if (this.curve.zeroA || this.curve.threeA) {
      var b = this;
      for (f = 0; f < h; f++)
        b = b.dbl();
      return b;
    }
    var v = this.curve.a, m = this.curve.tinv, E = this.x, M = this.y, B = this.z, I = B.redSqr().redSqr(), T = M.redAdd(M);
    for (f = 0; f < h; f++) {
      var k = E.redSqr(), j = T.redSqr(), N = j.redSqr(), q = k.redAdd(k).redIAdd(k).redIAdd(v.redMul(I)), D = E.redMul(j), re = q.redSqr().redISub(D.redAdd(D)), te = D.redISub(re), oe = q.redMul(te);
      oe = oe.redIAdd(oe).redISub(N);
      var U = T.redMul(B);
      f + 1 < h && (I = I.redMul(N)), E = re, B = U, T = oe;
    }
    return this.curve.jpoint(E, T.redMul(m), B);
  }, u.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, u.prototype._zeroDbl = function() {
    var h, f, b;
    if (this.zOne) {
      var v = this.x.redSqr(), m = this.y.redSqr(), E = m.redSqr(), M = this.x.redAdd(m).redSqr().redISub(v).redISub(E);
      M = M.redIAdd(M);
      var B = v.redAdd(v).redIAdd(v), I = B.redSqr().redISub(M).redISub(M), T = E.redIAdd(E);
      T = T.redIAdd(T), T = T.redIAdd(T), h = I, f = B.redMul(M.redISub(I)).redISub(T), b = this.y.redAdd(this.y);
    } else {
      var k = this.x.redSqr(), j = this.y.redSqr(), N = j.redSqr(), q = this.x.redAdd(j).redSqr().redISub(k).redISub(N);
      q = q.redIAdd(q);
      var D = k.redAdd(k).redIAdd(k), re = D.redSqr(), te = N.redIAdd(N);
      te = te.redIAdd(te), te = te.redIAdd(te), h = re.redISub(q).redISub(q), f = D.redMul(q.redISub(h)).redISub(te), b = this.y.redMul(this.z), b = b.redIAdd(b);
    }
    return this.curve.jpoint(h, f, b);
  }, u.prototype._threeDbl = function() {
    var h, f, b;
    if (this.zOne) {
      var v = this.x.redSqr(), m = this.y.redSqr(), E = m.redSqr(), M = this.x.redAdd(m).redSqr().redISub(v).redISub(E);
      M = M.redIAdd(M);
      var B = v.redAdd(v).redIAdd(v).redIAdd(this.curve.a), I = B.redSqr().redISub(M).redISub(M);
      h = I;
      var T = E.redIAdd(E);
      T = T.redIAdd(T), T = T.redIAdd(T), f = B.redMul(M.redISub(I)).redISub(T), b = this.y.redAdd(this.y);
    } else {
      var k = this.z.redSqr(), j = this.y.redSqr(), N = this.x.redMul(j), q = this.x.redSub(k).redMul(this.x.redAdd(k));
      q = q.redAdd(q).redIAdd(q);
      var D = N.redIAdd(N);
      D = D.redIAdd(D);
      var re = D.redAdd(D);
      h = q.redSqr().redISub(re), b = this.y.redAdd(this.z).redSqr().redISub(j).redISub(k);
      var te = j.redSqr();
      te = te.redIAdd(te), te = te.redIAdd(te), te = te.redIAdd(te), f = q.redMul(D.redISub(h)).redISub(te);
    }
    return this.curve.jpoint(h, f, b);
  }, u.prototype._dbl = function() {
    var h = this.curve.a, f = this.x, b = this.y, v = this.z, m = v.redSqr().redSqr(), E = f.redSqr(), M = b.redSqr(), B = E.redAdd(E).redIAdd(E).redIAdd(h.redMul(m)), I = f.redAdd(f);
    I = I.redIAdd(I);
    var T = I.redMul(M), k = B.redSqr().redISub(T.redAdd(T)), j = T.redISub(k), N = M.redSqr();
    N = N.redIAdd(N), N = N.redIAdd(N), N = N.redIAdd(N);
    var q = B.redMul(j).redISub(N), D = b.redAdd(b).redMul(v);
    return this.curve.jpoint(k, q, D);
  }, u.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var h = this.x.redSqr(), f = this.y.redSqr(), b = this.z.redSqr(), v = f.redSqr(), m = h.redAdd(h).redIAdd(h), E = m.redSqr(), M = this.x.redAdd(f).redSqr().redISub(h).redISub(v);
    M = M.redIAdd(M), M = M.redAdd(M).redIAdd(M), M = M.redISub(E);
    var B = M.redSqr(), I = v.redIAdd(v);
    I = I.redIAdd(I), I = I.redIAdd(I), I = I.redIAdd(I);
    var T = m.redIAdd(M).redSqr().redISub(E).redISub(B).redISub(I), k = f.redMul(T);
    k = k.redIAdd(k), k = k.redIAdd(k);
    var j = this.x.redMul(B).redISub(k);
    j = j.redIAdd(j), j = j.redIAdd(j);
    var N = this.y.redMul(T.redMul(I.redISub(T)).redISub(M.redMul(B)));
    N = N.redIAdd(N), N = N.redIAdd(N), N = N.redIAdd(N);
    var q = this.z.redAdd(M).redSqr().redISub(b).redISub(B);
    return this.curve.jpoint(j, N, q);
  }, u.prototype.mul = function(h, f) {
    return h = new t(h, f), this.curve._wnafMul(this, h);
  }, u.prototype.eq = function(h) {
    if (h.type === "affine")
      return this.eq(h.toJ());
    if (this === h)
      return !0;
    var f = this.z.redSqr(), b = h.z.redSqr();
    if (this.x.redMul(b).redISub(h.x.redMul(f)).cmpn(0) !== 0)
      return !1;
    var v = f.redMul(this.z), m = b.redMul(h.z);
    return this.y.redMul(m).redISub(h.y.redMul(v)).cmpn(0) === 0;
  }, u.prototype.eqXToP = function(h) {
    var f = this.z.redSqr(), b = h.toRed(this.curve.red).redMul(f);
    if (this.x.cmp(b) === 0)
      return !0;
    for (var v = h.clone(), m = this.curve.redN.redMul(f); ; ) {
      if (v.iadd(this.curve.n), v.cmp(this.curve.p) >= 0)
        return !1;
      if (b.redIAdd(m), this.x.cmp(b) === 0)
        return !0;
    }
  }, u.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, u.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, uu;
}
var cu, m1;
function sx() {
  if (m1)
    return cu;
  m1 = 1;
  var e = Wt, t = mt(), n = wf(), i = Or();
  function s(o) {
    n.call(this, "mont", o), this.a = new e(o.a, 16).toRed(this.red), this.b = new e(o.b, 16).toRed(this.red), this.i4 = new e(4).toRed(this.red).redInvm(), this.two = new e(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  t(s, n), cu = s, s.prototype.validate = function(u) {
    var c = u.normalize().x, h = c.redSqr(), f = h.redMul(c).redAdd(h.redMul(this.a)).redAdd(c), b = f.redSqrt();
    return b.redSqr().cmp(f) === 0;
  };
  function r(o, u, c) {
    n.BasePoint.call(this, o, "projective"), u === null && c === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new e(u, 16), this.z = new e(c, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return t(r, n.BasePoint), s.prototype.decodePoint = function(u, c) {
    return this.point(i.toArray(u, c), 1);
  }, s.prototype.point = function(u, c) {
    return new r(this, u, c);
  }, s.prototype.pointFromJSON = function(u) {
    return r.fromJSON(this, u);
  }, r.prototype.precompute = function() {
  }, r.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, r.fromJSON = function(u, c) {
    return new r(u, c[0], c[1] || u.one);
  }, r.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, r.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, r.prototype.dbl = function() {
    var u = this.x.redAdd(this.z), c = u.redSqr(), h = this.x.redSub(this.z), f = h.redSqr(), b = c.redSub(f), v = c.redMul(f), m = b.redMul(f.redAdd(this.curve.a24.redMul(b)));
    return this.curve.point(v, m);
  }, r.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, r.prototype.diffAdd = function(u, c) {
    var h = this.x.redAdd(this.z), f = this.x.redSub(this.z), b = u.x.redAdd(u.z), v = u.x.redSub(u.z), m = v.redMul(h), E = b.redMul(f), M = c.z.redMul(m.redAdd(E).redSqr()), B = c.x.redMul(m.redISub(E).redSqr());
    return this.curve.point(M, B);
  }, r.prototype.mul = function(u) {
    for (var c = u.clone(), h = this, f = this.curve.point(null, null), b = this, v = []; c.cmpn(0) !== 0; c.iushrn(1))
      v.push(c.andln(1));
    for (var m = v.length - 1; m >= 0; m--)
      v[m] === 0 ? (h = h.diffAdd(f, b), f = f.dbl()) : (f = h.diffAdd(f, b), h = h.dbl());
    return f;
  }, r.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, r.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, r.prototype.eq = function(u) {
    return this.getX().cmp(u.getX()) === 0;
  }, r.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, r.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, cu;
}
var hu, _1;
function ux() {
  if (_1)
    return hu;
  _1 = 1;
  var e = Or(), t = Wt, n = mt(), i = wf(), s = e.assert;
  function r(u) {
    this.twisted = (u.a | 0) !== 1, this.mOneA = this.twisted && (u.a | 0) === -1, this.extended = this.mOneA, i.call(this, "edwards", u), this.a = new t(u.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new t(u.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new t(u.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), s(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (u.c | 0) === 1;
  }
  n(r, i), hu = r, r.prototype._mulA = function(c) {
    return this.mOneA ? c.redNeg() : this.a.redMul(c);
  }, r.prototype._mulC = function(c) {
    return this.oneC ? c : this.c.redMul(c);
  }, r.prototype.jpoint = function(c, h, f, b) {
    return this.point(c, h, f, b);
  }, r.prototype.pointFromX = function(c, h) {
    c = new t(c, 16), c.red || (c = c.toRed(this.red));
    var f = c.redSqr(), b = this.c2.redSub(this.a.redMul(f)), v = this.one.redSub(this.c2.redMul(this.d).redMul(f)), m = b.redMul(v.redInvm()), E = m.redSqrt();
    if (E.redSqr().redSub(m).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var M = E.fromRed().isOdd();
    return (h && !M || !h && M) && (E = E.redNeg()), this.point(c, E);
  }, r.prototype.pointFromY = function(c, h) {
    c = new t(c, 16), c.red || (c = c.toRed(this.red));
    var f = c.redSqr(), b = f.redSub(this.c2), v = f.redMul(this.d).redMul(this.c2).redSub(this.a), m = b.redMul(v.redInvm());
    if (m.cmp(this.zero) === 0) {
      if (h)
        throw new Error("invalid point");
      return this.point(this.zero, c);
    }
    var E = m.redSqrt();
    if (E.redSqr().redSub(m).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return E.fromRed().isOdd() !== h && (E = E.redNeg()), this.point(E, c);
  }, r.prototype.validate = function(c) {
    if (c.isInfinity())
      return !0;
    c.normalize();
    var h = c.x.redSqr(), f = c.y.redSqr(), b = h.redMul(this.a).redAdd(f), v = this.c2.redMul(this.one.redAdd(this.d.redMul(h).redMul(f)));
    return b.cmp(v) === 0;
  };
  function o(u, c, h, f, b) {
    i.BasePoint.call(this, u, "projective"), c === null && h === null && f === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new t(c, 16), this.y = new t(h, 16), this.z = f ? new t(f, 16) : this.curve.one, this.t = b && new t(b, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return n(o, i.BasePoint), r.prototype.pointFromJSON = function(c) {
    return o.fromJSON(this, c);
  }, r.prototype.point = function(c, h, f, b) {
    return new o(this, c, h, f, b);
  }, o.fromJSON = function(c, h) {
    return new o(c, h[0], h[1], h[2]);
  }, o.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, o.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, o.prototype._extDbl = function() {
    var c = this.x.redSqr(), h = this.y.redSqr(), f = this.z.redSqr();
    f = f.redIAdd(f);
    var b = this.curve._mulA(c), v = this.x.redAdd(this.y).redSqr().redISub(c).redISub(h), m = b.redAdd(h), E = m.redSub(f), M = b.redSub(h), B = v.redMul(E), I = m.redMul(M), T = v.redMul(M), k = E.redMul(m);
    return this.curve.point(B, I, k, T);
  }, o.prototype._projDbl = function() {
    var c = this.x.redAdd(this.y).redSqr(), h = this.x.redSqr(), f = this.y.redSqr(), b, v, m, E, M, B;
    if (this.curve.twisted) {
      E = this.curve._mulA(h);
      var I = E.redAdd(f);
      this.zOne ? (b = c.redSub(h).redSub(f).redMul(I.redSub(this.curve.two)), v = I.redMul(E.redSub(f)), m = I.redSqr().redSub(I).redSub(I)) : (M = this.z.redSqr(), B = I.redSub(M).redISub(M), b = c.redSub(h).redISub(f).redMul(B), v = I.redMul(E.redSub(f)), m = I.redMul(B));
    } else
      E = h.redAdd(f), M = this.curve._mulC(this.z).redSqr(), B = E.redSub(M).redSub(M), b = this.curve._mulC(c.redISub(E)).redMul(B), v = this.curve._mulC(E).redMul(h.redISub(f)), m = E.redMul(B);
    return this.curve.point(b, v, m);
  }, o.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, o.prototype._extAdd = function(c) {
    var h = this.y.redSub(this.x).redMul(c.y.redSub(c.x)), f = this.y.redAdd(this.x).redMul(c.y.redAdd(c.x)), b = this.t.redMul(this.curve.dd).redMul(c.t), v = this.z.redMul(c.z.redAdd(c.z)), m = f.redSub(h), E = v.redSub(b), M = v.redAdd(b), B = f.redAdd(h), I = m.redMul(E), T = M.redMul(B), k = m.redMul(B), j = E.redMul(M);
    return this.curve.point(I, T, j, k);
  }, o.prototype._projAdd = function(c) {
    var h = this.z.redMul(c.z), f = h.redSqr(), b = this.x.redMul(c.x), v = this.y.redMul(c.y), m = this.curve.d.redMul(b).redMul(v), E = f.redSub(m), M = f.redAdd(m), B = this.x.redAdd(this.y).redMul(c.x.redAdd(c.y)).redISub(b).redISub(v), I = h.redMul(E).redMul(B), T, k;
    return this.curve.twisted ? (T = h.redMul(M).redMul(v.redSub(this.curve._mulA(b))), k = E.redMul(M)) : (T = h.redMul(M).redMul(v.redSub(b)), k = this.curve._mulC(E).redMul(M)), this.curve.point(I, T, k);
  }, o.prototype.add = function(c) {
    return this.isInfinity() ? c : c.isInfinity() ? this : this.curve.extended ? this._extAdd(c) : this._projAdd(c);
  }, o.prototype.mul = function(c) {
    return this._hasDoubles(c) ? this.curve._fixedNafMul(this, c) : this.curve._wnafMul(this, c);
  }, o.prototype.mulAdd = function(c, h, f) {
    return this.curve._wnafMulAdd(1, [this, h], [c, f], 2, !1);
  }, o.prototype.jmulAdd = function(c, h, f) {
    return this.curve._wnafMulAdd(1, [this, h], [c, f], 2, !0);
  }, o.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var c = this.z.redInvm();
    return this.x = this.x.redMul(c), this.y = this.y.redMul(c), this.t && (this.t = this.t.redMul(c)), this.z = this.curve.one, this.zOne = !0, this;
  }, o.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, o.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, o.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, o.prototype.eq = function(c) {
    return this === c || this.getX().cmp(c.getX()) === 0 && this.getY().cmp(c.getY()) === 0;
  }, o.prototype.eqXToP = function(c) {
    var h = c.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(h) === 0)
      return !0;
    for (var f = c.clone(), b = this.curve.redN.redMul(this.z); ; ) {
      if (f.iadd(this.curve.n), f.cmp(this.curve.p) >= 0)
        return !1;
      if (h.redIAdd(b), this.x.cmp(h) === 0)
        return !0;
    }
  }, o.prototype.toP = o.prototype.normalize, o.prototype.mixedAdd = o.prototype.add, hu;
}
var w1;
function hy() {
  return w1 || (w1 = 1, function(e) {
    var t = e;
    t.base = wf(), t.short = ox(), t.mont = sx(), t.edwards = ux();
  }(ou)), ou;
}
var lu = {}, du = {}, Ct = {}, x1;
function Jr() {
  if (x1)
    return Ct;
  x1 = 1;
  var e = Tr(), t = mt();
  Ct.inherits = t;
  function n(y, p) {
    return (y.charCodeAt(p) & 64512) !== 55296 || p < 0 || p + 1 >= y.length ? !1 : (y.charCodeAt(p + 1) & 64512) === 56320;
  }
  function i(y, p) {
    if (Array.isArray(y))
      return y.slice();
    if (!y)
      return [];
    var a = [];
    if (typeof y == "string")
      if (p) {
        if (p === "hex")
          for (y = y.replace(/[^a-z0-9]+/ig, ""), y.length % 2 !== 0 && (y = "0" + y), _ = 0; _ < y.length; _ += 2)
            a.push(parseInt(y[_] + y[_ + 1], 16));
      } else
        for (var l = 0, _ = 0; _ < y.length; _++) {
          var x = y.charCodeAt(_);
          x < 128 ? a[l++] = x : x < 2048 ? (a[l++] = x >> 6 | 192, a[l++] = x & 63 | 128) : n(y, _) ? (x = 65536 + ((x & 1023) << 10) + (y.charCodeAt(++_) & 1023), a[l++] = x >> 18 | 240, a[l++] = x >> 12 & 63 | 128, a[l++] = x >> 6 & 63 | 128, a[l++] = x & 63 | 128) : (a[l++] = x >> 12 | 224, a[l++] = x >> 6 & 63 | 128, a[l++] = x & 63 | 128);
        }
    else
      for (_ = 0; _ < y.length; _++)
        a[_] = y[_] | 0;
    return a;
  }
  Ct.toArray = i;
  function s(y) {
    for (var p = "", a = 0; a < y.length; a++)
      p += u(y[a].toString(16));
    return p;
  }
  Ct.toHex = s;
  function r(y) {
    var p = y >>> 24 | y >>> 8 & 65280 | y << 8 & 16711680 | (y & 255) << 24;
    return p >>> 0;
  }
  Ct.htonl = r;
  function o(y, p) {
    for (var a = "", l = 0; l < y.length; l++) {
      var _ = y[l];
      p === "little" && (_ = r(_)), a += c(_.toString(16));
    }
    return a;
  }
  Ct.toHex32 = o;
  function u(y) {
    return y.length === 1 ? "0" + y : y;
  }
  Ct.zero2 = u;
  function c(y) {
    return y.length === 7 ? "0" + y : y.length === 6 ? "00" + y : y.length === 5 ? "000" + y : y.length === 4 ? "0000" + y : y.length === 3 ? "00000" + y : y.length === 2 ? "000000" + y : y.length === 1 ? "0000000" + y : y;
  }
  Ct.zero8 = c;
  function h(y, p, a, l) {
    var _ = a - p;
    e(_ % 4 === 0);
    for (var x = new Array(_ / 4), A = 0, S = p; A < x.length; A++, S += 4) {
      var g;
      l === "big" ? g = y[S] << 24 | y[S + 1] << 16 | y[S + 2] << 8 | y[S + 3] : g = y[S + 3] << 24 | y[S + 2] << 16 | y[S + 1] << 8 | y[S], x[A] = g >>> 0;
    }
    return x;
  }
  Ct.join32 = h;
  function f(y, p) {
    for (var a = new Array(y.length * 4), l = 0, _ = 0; l < y.length; l++, _ += 4) {
      var x = y[l];
      p === "big" ? (a[_] = x >>> 24, a[_ + 1] = x >>> 16 & 255, a[_ + 2] = x >>> 8 & 255, a[_ + 3] = x & 255) : (a[_ + 3] = x >>> 24, a[_ + 2] = x >>> 16 & 255, a[_ + 1] = x >>> 8 & 255, a[_] = x & 255);
    }
    return a;
  }
  Ct.split32 = f;
  function b(y, p) {
    return y >>> p | y << 32 - p;
  }
  Ct.rotr32 = b;
  function v(y, p) {
    return y << p | y >>> 32 - p;
  }
  Ct.rotl32 = v;
  function m(y, p) {
    return y + p >>> 0;
  }
  Ct.sum32 = m;
  function E(y, p, a) {
    return y + p + a >>> 0;
  }
  Ct.sum32_3 = E;
  function M(y, p, a, l) {
    return y + p + a + l >>> 0;
  }
  Ct.sum32_4 = M;
  function B(y, p, a, l, _) {
    return y + p + a + l + _ >>> 0;
  }
  Ct.sum32_5 = B;
  function I(y, p, a, l) {
    var _ = y[p], x = y[p + 1], A = l + x >>> 0, S = (A < l ? 1 : 0) + a + _;
    y[p] = S >>> 0, y[p + 1] = A;
  }
  Ct.sum64 = I;
  function T(y, p, a, l) {
    var _ = p + l >>> 0, x = (_ < p ? 1 : 0) + y + a;
    return x >>> 0;
  }
  Ct.sum64_hi = T;
  function k(y, p, a, l) {
    var _ = p + l;
    return _ >>> 0;
  }
  Ct.sum64_lo = k;
  function j(y, p, a, l, _, x, A, S) {
    var g = 0, w = p;
    w = w + l >>> 0, g += w < p ? 1 : 0, w = w + x >>> 0, g += w < x ? 1 : 0, w = w + S >>> 0, g += w < S ? 1 : 0;
    var d = y + a + _ + A + g;
    return d >>> 0;
  }
  Ct.sum64_4_hi = j;
  function N(y, p, a, l, _, x, A, S) {
    var g = p + l + x + S;
    return g >>> 0;
  }
  Ct.sum64_4_lo = N;
  function q(y, p, a, l, _, x, A, S, g, w) {
    var d = 0, R = p;
    R = R + l >>> 0, d += R < p ? 1 : 0, R = R + x >>> 0, d += R < x ? 1 : 0, R = R + S >>> 0, d += R < S ? 1 : 0, R = R + w >>> 0, d += R < w ? 1 : 0;
    var G = y + a + _ + A + g + d;
    return G >>> 0;
  }
  Ct.sum64_5_hi = q;
  function D(y, p, a, l, _, x, A, S, g, w) {
    var d = p + l + x + S + w;
    return d >>> 0;
  }
  Ct.sum64_5_lo = D;
  function re(y, p, a) {
    var l = p << 32 - a | y >>> a;
    return l >>> 0;
  }
  Ct.rotr64_hi = re;
  function te(y, p, a) {
    var l = y << 32 - a | p >>> a;
    return l >>> 0;
  }
  Ct.rotr64_lo = te;
  function oe(y, p, a) {
    return y >>> a;
  }
  Ct.shr64_hi = oe;
  function U(y, p, a) {
    var l = y << 32 - a | p >>> a;
    return l >>> 0;
  }
  return Ct.shr64_lo = U, Ct;
}
var pu = {}, E1;
function zi() {
  if (E1)
    return pu;
  E1 = 1;
  var e = Jr(), t = Tr();
  function n() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return pu.BlockHash = n, n.prototype.update = function(s, r) {
    if (s = e.toArray(s, r), this.pending ? this.pending = this.pending.concat(s) : this.pending = s, this.pendingTotal += s.length, this.pending.length >= this._delta8) {
      s = this.pending;
      var o = s.length % this._delta8;
      this.pending = s.slice(s.length - o, s.length), this.pending.length === 0 && (this.pending = null), s = e.join32(s, 0, s.length - o, this.endian);
      for (var u = 0; u < s.length; u += this._delta32)
        this._update(s, u, u + this._delta32);
    }
    return this;
  }, n.prototype.digest = function(s) {
    return this.update(this._pad()), t(this.pending === null), this._digest(s);
  }, n.prototype._pad = function() {
    var s = this.pendingTotal, r = this._delta8, o = r - (s + this.padLength) % r, u = new Array(o + this.padLength);
    u[0] = 128;
    for (var c = 1; c < o; c++)
      u[c] = 0;
    if (s <<= 3, this.endian === "big") {
      for (var h = 8; h < this.padLength; h++)
        u[c++] = 0;
      u[c++] = 0, u[c++] = 0, u[c++] = 0, u[c++] = 0, u[c++] = s >>> 24 & 255, u[c++] = s >>> 16 & 255, u[c++] = s >>> 8 & 255, u[c++] = s & 255;
    } else
      for (u[c++] = s & 255, u[c++] = s >>> 8 & 255, u[c++] = s >>> 16 & 255, u[c++] = s >>> 24 & 255, u[c++] = 0, u[c++] = 0, u[c++] = 0, u[c++] = 0, h = 8; h < this.padLength; h++)
        u[c++] = 0;
    return u;
  }, pu;
}
var wn = {}, Ur = {}, S1;
function ly() {
  if (S1)
    return Ur;
  S1 = 1;
  var e = Jr(), t = e.rotr32;
  function n(f, b, v, m) {
    if (f === 0)
      return i(b, v, m);
    if (f === 1 || f === 3)
      return r(b, v, m);
    if (f === 2)
      return s(b, v, m);
  }
  Ur.ft_1 = n;
  function i(f, b, v) {
    return f & b ^ ~f & v;
  }
  Ur.ch32 = i;
  function s(f, b, v) {
    return f & b ^ f & v ^ b & v;
  }
  Ur.maj32 = s;
  function r(f, b, v) {
    return f ^ b ^ v;
  }
  Ur.p32 = r;
  function o(f) {
    return t(f, 2) ^ t(f, 13) ^ t(f, 22);
  }
  Ur.s0_256 = o;
  function u(f) {
    return t(f, 6) ^ t(f, 11) ^ t(f, 25);
  }
  Ur.s1_256 = u;
  function c(f) {
    return t(f, 7) ^ t(f, 18) ^ f >>> 3;
  }
  Ur.g0_256 = c;
  function h(f) {
    return t(f, 17) ^ t(f, 19) ^ f >>> 10;
  }
  return Ur.g1_256 = h, Ur;
}
var vu, A1;
function cx() {
  if (A1)
    return vu;
  A1 = 1;
  var e = Jr(), t = zi(), n = ly(), i = e.rotl32, s = e.sum32, r = e.sum32_5, o = n.ft_1, u = t.BlockHash, c = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function h() {
    if (!(this instanceof h))
      return new h();
    u.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return e.inherits(h, u), vu = h, h.blockSize = 512, h.outSize = 160, h.hmacStrength = 80, h.padLength = 64, h.prototype._update = function(b, v) {
    for (var m = this.W, E = 0; E < 16; E++)
      m[E] = b[v + E];
    for (; E < m.length; E++)
      m[E] = i(m[E - 3] ^ m[E - 8] ^ m[E - 14] ^ m[E - 16], 1);
    var M = this.h[0], B = this.h[1], I = this.h[2], T = this.h[3], k = this.h[4];
    for (E = 0; E < m.length; E++) {
      var j = ~~(E / 20), N = r(i(M, 5), o(j, B, I, T), k, m[E], c[j]);
      k = T, T = I, I = i(B, 30), B = M, M = N;
    }
    this.h[0] = s(this.h[0], M), this.h[1] = s(this.h[1], B), this.h[2] = s(this.h[2], I), this.h[3] = s(this.h[3], T), this.h[4] = s(this.h[4], k);
  }, h.prototype._digest = function(b) {
    return b === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  }, vu;
}
var bu, M1;
function dy() {
  if (M1)
    return bu;
  M1 = 1;
  var e = Jr(), t = zi(), n = ly(), i = Tr(), s = e.sum32, r = e.sum32_4, o = e.sum32_5, u = n.ch32, c = n.maj32, h = n.s0_256, f = n.s1_256, b = n.g0_256, v = n.g1_256, m = t.BlockHash, E = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function M() {
    if (!(this instanceof M))
      return new M();
    m.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = E, this.W = new Array(64);
  }
  return e.inherits(M, m), bu = M, M.blockSize = 512, M.outSize = 256, M.hmacStrength = 192, M.padLength = 64, M.prototype._update = function(I, T) {
    for (var k = this.W, j = 0; j < 16; j++)
      k[j] = I[T + j];
    for (; j < k.length; j++)
      k[j] = r(v(k[j - 2]), k[j - 7], b(k[j - 15]), k[j - 16]);
    var N = this.h[0], q = this.h[1], D = this.h[2], re = this.h[3], te = this.h[4], oe = this.h[5], U = this.h[6], y = this.h[7];
    for (i(this.k.length === k.length), j = 0; j < k.length; j++) {
      var p = o(y, f(te), u(te, oe, U), this.k[j], k[j]), a = s(h(N), c(N, q, D));
      y = U, U = oe, oe = te, te = s(re, p), re = D, D = q, q = N, N = s(p, a);
    }
    this.h[0] = s(this.h[0], N), this.h[1] = s(this.h[1], q), this.h[2] = s(this.h[2], D), this.h[3] = s(this.h[3], re), this.h[4] = s(this.h[4], te), this.h[5] = s(this.h[5], oe), this.h[6] = s(this.h[6], U), this.h[7] = s(this.h[7], y);
  }, M.prototype._digest = function(I) {
    return I === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  }, bu;
}
var yu, R1;
function hx() {
  if (R1)
    return yu;
  R1 = 1;
  var e = Jr(), t = dy();
  function n() {
    if (!(this instanceof n))
      return new n();
    t.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return e.inherits(n, t), yu = n, n.blockSize = 512, n.outSize = 224, n.hmacStrength = 192, n.padLength = 64, n.prototype._digest = function(s) {
    return s === "hex" ? e.toHex32(this.h.slice(0, 7), "big") : e.split32(this.h.slice(0, 7), "big");
  }, yu;
}
var gu, B1;
function py() {
  if (B1)
    return gu;
  B1 = 1;
  var e = Jr(), t = zi(), n = Tr(), i = e.rotr64_hi, s = e.rotr64_lo, r = e.shr64_hi, o = e.shr64_lo, u = e.sum64, c = e.sum64_hi, h = e.sum64_lo, f = e.sum64_4_hi, b = e.sum64_4_lo, v = e.sum64_5_hi, m = e.sum64_5_lo, E = t.BlockHash, M = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function B() {
    if (!(this instanceof B))
      return new B();
    E.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = M, this.W = new Array(160);
  }
  e.inherits(B, E), gu = B, B.blockSize = 1024, B.outSize = 512, B.hmacStrength = 192, B.padLength = 128, B.prototype._prepareBlock = function(a, l) {
    for (var _ = this.W, x = 0; x < 32; x++)
      _[x] = a[l + x];
    for (; x < _.length; x += 2) {
      var A = U(_[x - 4], _[x - 3]), S = y(_[x - 4], _[x - 3]), g = _[x - 14], w = _[x - 13], d = te(_[x - 30], _[x - 29]), R = oe(_[x - 30], _[x - 29]), G = _[x - 32], fe = _[x - 31];
      _[x] = f(
        A,
        S,
        g,
        w,
        d,
        R,
        G,
        fe
      ), _[x + 1] = b(
        A,
        S,
        g,
        w,
        d,
        R,
        G,
        fe
      );
    }
  }, B.prototype._update = function(a, l) {
    this._prepareBlock(a, l);
    var _ = this.W, x = this.h[0], A = this.h[1], S = this.h[2], g = this.h[3], w = this.h[4], d = this.h[5], R = this.h[6], G = this.h[7], fe = this.h[8], z = this.h[9], V = this.h[10], F = this.h[11], ee = this.h[12], he = this.h[13], Z = this.h[14], K = this.h[15];
    n(this.k.length === _.length);
    for (var ce = 0; ce < _.length; ce += 2) {
      var ve = Z, Be = K, Q = D(fe, z), C = re(fe, z), L = I(fe, z, V, F, ee), W = T(fe, z, V, F, ee, he), de = this.k[ce], me = this.k[ce + 1], Te = _[ce], Fe = _[ce + 1], H = v(
        ve,
        Be,
        Q,
        C,
        L,
        W,
        de,
        me,
        Te,
        Fe
      ), ue = m(
        ve,
        Be,
        Q,
        C,
        L,
        W,
        de,
        me,
        Te,
        Fe
      );
      ve = N(x, A), Be = q(x, A), Q = k(x, A, S, g, w), C = j(x, A, S, g, w, d);
      var se = c(ve, Be, Q, C), we = h(ve, Be, Q, C);
      Z = ee, K = he, ee = V, he = F, V = fe, F = z, fe = c(R, G, H, ue), z = h(G, G, H, ue), R = w, G = d, w = S, d = g, S = x, g = A, x = c(H, ue, se, we), A = h(H, ue, se, we);
    }
    u(this.h, 0, x, A), u(this.h, 2, S, g), u(this.h, 4, w, d), u(this.h, 6, R, G), u(this.h, 8, fe, z), u(this.h, 10, V, F), u(this.h, 12, ee, he), u(this.h, 14, Z, K);
  }, B.prototype._digest = function(a) {
    return a === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  };
  function I(p, a, l, _, x) {
    var A = p & l ^ ~p & x;
    return A < 0 && (A += 4294967296), A;
  }
  function T(p, a, l, _, x, A) {
    var S = a & _ ^ ~a & A;
    return S < 0 && (S += 4294967296), S;
  }
  function k(p, a, l, _, x) {
    var A = p & l ^ p & x ^ l & x;
    return A < 0 && (A += 4294967296), A;
  }
  function j(p, a, l, _, x, A) {
    var S = a & _ ^ a & A ^ _ & A;
    return S < 0 && (S += 4294967296), S;
  }
  function N(p, a) {
    var l = i(p, a, 28), _ = i(a, p, 2), x = i(a, p, 7), A = l ^ _ ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function q(p, a) {
    var l = s(p, a, 28), _ = s(a, p, 2), x = s(a, p, 7), A = l ^ _ ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function D(p, a) {
    var l = i(p, a, 14), _ = i(p, a, 18), x = i(a, p, 9), A = l ^ _ ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function re(p, a) {
    var l = s(p, a, 14), _ = s(p, a, 18), x = s(a, p, 9), A = l ^ _ ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function te(p, a) {
    var l = i(p, a, 1), _ = i(p, a, 8), x = r(p, a, 7), A = l ^ _ ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function oe(p, a) {
    var l = s(p, a, 1), _ = s(p, a, 8), x = o(p, a, 7), A = l ^ _ ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function U(p, a) {
    var l = i(p, a, 19), _ = i(a, p, 29), x = r(p, a, 6), A = l ^ _ ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function y(p, a) {
    var l = s(p, a, 19), _ = s(a, p, 29), x = o(p, a, 6), A = l ^ _ ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  return gu;
}
var mu, I1;
function lx() {
  if (I1)
    return mu;
  I1 = 1;
  var e = Jr(), t = py();
  function n() {
    if (!(this instanceof n))
      return new n();
    t.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return e.inherits(n, t), mu = n, n.blockSize = 1024, n.outSize = 384, n.hmacStrength = 192, n.padLength = 128, n.prototype._digest = function(s) {
    return s === "hex" ? e.toHex32(this.h.slice(0, 12), "big") : e.split32(this.h.slice(0, 12), "big");
  }, mu;
}
var T1;
function dx() {
  return T1 || (T1 = 1, wn.sha1 = cx(), wn.sha224 = hx(), wn.sha256 = dy(), wn.sha384 = lx(), wn.sha512 = py()), wn;
}
var _u = {}, O1;
function px() {
  if (O1)
    return _u;
  O1 = 1;
  var e = Jr(), t = zi(), n = e.rotl32, i = e.sum32, s = e.sum32_3, r = e.sum32_4, o = t.BlockHash;
  function u() {
    if (!(this instanceof u))
      return new u();
    o.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  e.inherits(u, o), _u.ripemd160 = u, u.blockSize = 512, u.outSize = 160, u.hmacStrength = 192, u.padLength = 64, u.prototype._update = function(B, I) {
    for (var T = this.h[0], k = this.h[1], j = this.h[2], N = this.h[3], q = this.h[4], D = T, re = k, te = j, oe = N, U = q, y = 0; y < 80; y++) {
      var p = i(
        n(
          r(T, c(y, k, j, N), B[b[y] + I], h(y)),
          m[y]
        ),
        q
      );
      T = q, q = N, N = n(j, 10), j = k, k = p, p = i(
        n(
          r(D, c(79 - y, re, te, oe), B[v[y] + I], f(y)),
          E[y]
        ),
        U
      ), D = U, U = oe, oe = n(te, 10), te = re, re = p;
    }
    p = s(this.h[1], j, oe), this.h[1] = s(this.h[2], N, U), this.h[2] = s(this.h[3], q, D), this.h[3] = s(this.h[4], T, re), this.h[4] = s(this.h[0], k, te), this.h[0] = p;
  }, u.prototype._digest = function(B) {
    return B === "hex" ? e.toHex32(this.h, "little") : e.split32(this.h, "little");
  };
  function c(M, B, I, T) {
    return M <= 15 ? B ^ I ^ T : M <= 31 ? B & I | ~B & T : M <= 47 ? (B | ~I) ^ T : M <= 63 ? B & T | I & ~T : B ^ (I | ~T);
  }
  function h(M) {
    return M <= 15 ? 0 : M <= 31 ? 1518500249 : M <= 47 ? 1859775393 : M <= 63 ? 2400959708 : 2840853838;
  }
  function f(M) {
    return M <= 15 ? 1352829926 : M <= 31 ? 1548603684 : M <= 47 ? 1836072691 : M <= 63 ? 2053994217 : 0;
  }
  var b = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], v = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], m = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], E = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return _u;
}
var wu, P1;
function vx() {
  if (P1)
    return wu;
  P1 = 1;
  var e = Jr(), t = Tr();
  function n(i, s, r) {
    if (!(this instanceof n))
      return new n(i, s, r);
    this.Hash = i, this.blockSize = i.blockSize / 8, this.outSize = i.outSize / 8, this.inner = null, this.outer = null, this._init(e.toArray(s, r));
  }
  return wu = n, n.prototype._init = function(s) {
    s.length > this.blockSize && (s = new this.Hash().update(s).digest()), t(s.length <= this.blockSize);
    for (var r = s.length; r < this.blockSize; r++)
      s.push(0);
    for (r = 0; r < s.length; r++)
      s[r] ^= 54;
    for (this.inner = new this.Hash().update(s), r = 0; r < s.length; r++)
      s[r] ^= 106;
    this.outer = new this.Hash().update(s);
  }, n.prototype.update = function(s, r) {
    return this.inner.update(s, r), this;
  }, n.prototype.digest = function(s) {
    return this.outer.update(this.inner.digest()), this.outer.digest(s);
  }, wu;
}
var C1;
function m0() {
  return C1 || (C1 = 1, function(e) {
    var t = e;
    t.utils = Jr(), t.common = zi(), t.sha = dx(), t.ripemd = px(), t.hmac = vx(), t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
  }(du)), du;
}
var xu, N1;
function bx() {
  return N1 || (N1 = 1, xu = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), xu;
}
var L1;
function _0() {
  return L1 || (L1 = 1, function(e) {
    var t = e, n = m0(), i = hy(), s = Or(), r = s.assert;
    function o(h) {
      h.type === "short" ? this.curve = new i.short(h) : h.type === "edwards" ? this.curve = new i.edwards(h) : this.curve = new i.mont(h), this.g = this.curve.g, this.n = this.curve.n, this.hash = h.hash, r(this.g.validate(), "Invalid curve"), r(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    t.PresetCurve = o;
    function u(h, f) {
      Object.defineProperty(t, h, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var b = new o(f);
          return Object.defineProperty(t, h, {
            configurable: !0,
            enumerable: !0,
            value: b
          }), b;
        }
      });
    }
    u("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: n.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), u("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: n.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), u("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: n.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), u("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: n.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), u("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: n.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), u("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: n.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), u("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: n.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var c;
    try {
      c = bx();
    } catch {
      c = void 0;
    }
    u("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: n.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        c
      ]
    });
  }(lu)), lu;
}
var Eu, k1;
function yx() {
  if (k1)
    return Eu;
  k1 = 1;
  var e = m0(), t = cy(), n = Tr();
  function i(s) {
    if (!(this instanceof i))
      return new i(s);
    this.hash = s.hash, this.predResist = !!s.predResist, this.outLen = this.hash.outSize, this.minEntropy = s.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var r = t.toArray(s.entropy, s.entropyEnc || "hex"), o = t.toArray(s.nonce, s.nonceEnc || "hex"), u = t.toArray(s.pers, s.persEnc || "hex");
    n(
      r.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(r, o, u);
  }
  return Eu = i, i.prototype._init = function(r, o, u) {
    var c = r.concat(o).concat(u);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var h = 0; h < this.V.length; h++)
      this.K[h] = 0, this.V[h] = 1;
    this._update(c), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, i.prototype._hmac = function() {
    return new e.hmac(this.hash, this.K);
  }, i.prototype._update = function(r) {
    var o = this._hmac().update(this.V).update([0]);
    r && (o = o.update(r)), this.K = o.digest(), this.V = this._hmac().update(this.V).digest(), r && (this.K = this._hmac().update(this.V).update([1]).update(r).digest(), this.V = this._hmac().update(this.V).digest());
  }, i.prototype.reseed = function(r, o, u, c) {
    typeof o != "string" && (c = u, u = o, o = null), r = t.toArray(r, o), u = t.toArray(u, c), n(
      r.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(r.concat(u || [])), this._reseed = 1;
  }, i.prototype.generate = function(r, o, u, c) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof o != "string" && (c = u, u = o, o = null), u && (u = t.toArray(u, c || "hex"), this._update(u));
    for (var h = []; h.length < r; )
      this.V = this._hmac().update(this.V).digest(), h = h.concat(this.V);
    var f = h.slice(0, r);
    return this._update(u), this._reseed++, t.encode(f, o);
  }, Eu;
}
var Su, j1;
function gx() {
  if (j1)
    return Su;
  j1 = 1;
  var e = Wt, t = Or(), n = t.assert;
  function i(s, r) {
    this.ec = s, this.priv = null, this.pub = null, r.priv && this._importPrivate(r.priv, r.privEnc), r.pub && this._importPublic(r.pub, r.pubEnc);
  }
  return Su = i, i.fromPublic = function(r, o, u) {
    return o instanceof i ? o : new i(r, {
      pub: o,
      pubEnc: u
    });
  }, i.fromPrivate = function(r, o, u) {
    return o instanceof i ? o : new i(r, {
      priv: o,
      privEnc: u
    });
  }, i.prototype.validate = function() {
    var r = this.getPublic();
    return r.isInfinity() ? { result: !1, reason: "Invalid public key" } : r.validate() ? r.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, i.prototype.getPublic = function(r, o) {
    return typeof r == "string" && (o = r, r = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), o ? this.pub.encode(o, r) : this.pub;
  }, i.prototype.getPrivate = function(r) {
    return r === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, i.prototype._importPrivate = function(r, o) {
    this.priv = new e(r, o || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, i.prototype._importPublic = function(r, o) {
    if (r.x || r.y) {
      this.ec.curve.type === "mont" ? n(r.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && n(r.x && r.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(r.x, r.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(r, o);
  }, i.prototype.derive = function(r) {
    return r.validate() || n(r.validate(), "public point not validated"), r.mul(this.priv).getX();
  }, i.prototype.sign = function(r, o, u) {
    return this.ec.sign(r, this, o, u);
  }, i.prototype.verify = function(r, o) {
    return this.ec.verify(r, o, this);
  }, i.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, Su;
}
var Au, q1;
function mx() {
  if (q1)
    return Au;
  q1 = 1;
  var e = Wt, t = Or(), n = t.assert;
  function i(c, h) {
    if (c instanceof i)
      return c;
    this._importDER(c, h) || (n(c.r && c.s, "Signature without r or s"), this.r = new e(c.r, 16), this.s = new e(c.s, 16), c.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = c.recoveryParam);
  }
  Au = i;
  function s() {
    this.place = 0;
  }
  function r(c, h) {
    var f = c[h.place++];
    if (!(f & 128))
      return f;
    var b = f & 15;
    if (b === 0 || b > 4)
      return !1;
    for (var v = 0, m = 0, E = h.place; m < b; m++, E++)
      v <<= 8, v |= c[E], v >>>= 0;
    return v <= 127 ? !1 : (h.place = E, v);
  }
  function o(c) {
    for (var h = 0, f = c.length - 1; !c[h] && !(c[h + 1] & 128) && h < f; )
      h++;
    return h === 0 ? c : c.slice(h);
  }
  i.prototype._importDER = function(h, f) {
    h = t.toArray(h, f);
    var b = new s();
    if (h[b.place++] !== 48)
      return !1;
    var v = r(h, b);
    if (v === !1 || v + b.place !== h.length || h[b.place++] !== 2)
      return !1;
    var m = r(h, b);
    if (m === !1)
      return !1;
    var E = h.slice(b.place, m + b.place);
    if (b.place += m, h[b.place++] !== 2)
      return !1;
    var M = r(h, b);
    if (M === !1 || h.length !== M + b.place)
      return !1;
    var B = h.slice(b.place, M + b.place);
    if (E[0] === 0)
      if (E[1] & 128)
        E = E.slice(1);
      else
        return !1;
    if (B[0] === 0)
      if (B[1] & 128)
        B = B.slice(1);
      else
        return !1;
    return this.r = new e(E), this.s = new e(B), this.recoveryParam = null, !0;
  };
  function u(c, h) {
    if (h < 128) {
      c.push(h);
      return;
    }
    var f = 1 + (Math.log(h) / Math.LN2 >>> 3);
    for (c.push(f | 128); --f; )
      c.push(h >>> (f << 3) & 255);
    c.push(h);
  }
  return i.prototype.toDER = function(h) {
    var f = this.r.toArray(), b = this.s.toArray();
    for (f[0] & 128 && (f = [0].concat(f)), b[0] & 128 && (b = [0].concat(b)), f = o(f), b = o(b); !b[0] && !(b[1] & 128); )
      b = b.slice(1);
    var v = [2];
    u(v, f.length), v = v.concat(f), v.push(2), u(v, b.length);
    var m = v.concat(b), E = [48];
    return u(E, m.length), E = E.concat(m), t.encode(E, h);
  }, Au;
}
var Mu, D1;
function _x() {
  if (D1)
    return Mu;
  D1 = 1;
  var e = Wt, t = yx(), n = Or(), i = _0(), s = y0(), r = n.assert, o = gx(), u = mx();
  function c(h) {
    if (!(this instanceof c))
      return new c(h);
    typeof h == "string" && (r(
      Object.prototype.hasOwnProperty.call(i, h),
      "Unknown curve " + h
    ), h = i[h]), h instanceof i.PresetCurve && (h = { curve: h }), this.curve = h.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = h.curve.g, this.g.precompute(h.curve.n.bitLength() + 1), this.hash = h.hash || h.curve.hash;
  }
  return Mu = c, c.prototype.keyPair = function(f) {
    return new o(this, f);
  }, c.prototype.keyFromPrivate = function(f, b) {
    return o.fromPrivate(this, f, b);
  }, c.prototype.keyFromPublic = function(f, b) {
    return o.fromPublic(this, f, b);
  }, c.prototype.genKeyPair = function(f) {
    f || (f = {});
    for (var b = new t({
      hash: this.hash,
      pers: f.pers,
      persEnc: f.persEnc || "utf8",
      entropy: f.entropy || s(this.hash.hmacStrength),
      entropyEnc: f.entropy && f.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), v = this.n.byteLength(), m = this.n.sub(new e(2)); ; ) {
      var E = new e(b.generate(v));
      if (!(E.cmp(m) > 0))
        return E.iaddn(1), this.keyFromPrivate(E);
    }
  }, c.prototype._truncateToN = function(f, b) {
    var v = f.byteLength() * 8 - this.n.bitLength();
    return v > 0 && (f = f.ushrn(v)), !b && f.cmp(this.n) >= 0 ? f.sub(this.n) : f;
  }, c.prototype.sign = function(f, b, v, m) {
    typeof v == "object" && (m = v, v = null), m || (m = {}), b = this.keyFromPrivate(b, v), f = this._truncateToN(new e(f, 16));
    for (var E = this.n.byteLength(), M = b.getPrivate().toArray("be", E), B = f.toArray("be", E), I = new t({
      hash: this.hash,
      entropy: M,
      nonce: B,
      pers: m.pers,
      persEnc: m.persEnc || "utf8"
    }), T = this.n.sub(new e(1)), k = 0; ; k++) {
      var j = m.k ? m.k(k) : new e(I.generate(this.n.byteLength()));
      if (j = this._truncateToN(j, !0), !(j.cmpn(1) <= 0 || j.cmp(T) >= 0)) {
        var N = this.g.mul(j);
        if (!N.isInfinity()) {
          var q = N.getX(), D = q.umod(this.n);
          if (D.cmpn(0) !== 0) {
            var re = j.invm(this.n).mul(D.mul(b.getPrivate()).iadd(f));
            if (re = re.umod(this.n), re.cmpn(0) !== 0) {
              var te = (N.getY().isOdd() ? 1 : 0) | (q.cmp(D) !== 0 ? 2 : 0);
              return m.canonical && re.cmp(this.nh) > 0 && (re = this.n.sub(re), te ^= 1), new u({ r: D, s: re, recoveryParam: te });
            }
          }
        }
      }
    }
  }, c.prototype.verify = function(f, b, v, m) {
    f = this._truncateToN(new e(f, 16)), v = this.keyFromPublic(v, m), b = new u(b, "hex");
    var E = b.r, M = b.s;
    if (E.cmpn(1) < 0 || E.cmp(this.n) >= 0 || M.cmpn(1) < 0 || M.cmp(this.n) >= 0)
      return !1;
    var B = M.invm(this.n), I = B.mul(f).umod(this.n), T = B.mul(E).umod(this.n), k;
    return this.curve._maxwellTrick ? (k = this.g.jmulAdd(I, v.getPublic(), T), k.isInfinity() ? !1 : k.eqXToP(E)) : (k = this.g.mulAdd(I, v.getPublic(), T), k.isInfinity() ? !1 : k.getX().umod(this.n).cmp(E) === 0);
  }, c.prototype.recoverPubKey = function(h, f, b, v) {
    r((3 & b) === b, "The recovery param is more than two bits"), f = new u(f, v);
    var m = this.n, E = new e(h), M = f.r, B = f.s, I = b & 1, T = b >> 1;
    if (M.cmp(this.curve.p.umod(this.curve.n)) >= 0 && T)
      throw new Error("Unable to find sencond key candinate");
    T ? M = this.curve.pointFromX(M.add(this.curve.n), I) : M = this.curve.pointFromX(M, I);
    var k = f.r.invm(m), j = m.sub(E).mul(k).umod(m), N = B.mul(k).umod(m);
    return this.g.mulAdd(j, M, N);
  }, c.prototype.getKeyRecoveryParam = function(h, f, b, v) {
    if (f = new u(f, v), f.recoveryParam !== null)
      return f.recoveryParam;
    for (var m = 0; m < 4; m++) {
      var E;
      try {
        E = this.recoverPubKey(h, f, m);
      } catch {
        continue;
      }
      if (E.eq(b))
        return m;
    }
    throw new Error("Unable to find valid recovery factor");
  }, Mu;
}
var Ru, $1;
function wx() {
  if ($1)
    return Ru;
  $1 = 1;
  var e = Or(), t = e.assert, n = e.parseBytes, i = e.cachedProperty;
  function s(r, o) {
    this.eddsa = r, this._secret = n(o.secret), r.isPoint(o.pub) ? this._pub = o.pub : this._pubBytes = n(o.pub);
  }
  return s.fromPublic = function(o, u) {
    return u instanceof s ? u : new s(o, { pub: u });
  }, s.fromSecret = function(o, u) {
    return u instanceof s ? u : new s(o, { secret: u });
  }, s.prototype.secret = function() {
    return this._secret;
  }, i(s, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), i(s, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), i(s, "privBytes", function() {
    var o = this.eddsa, u = this.hash(), c = o.encodingLength - 1, h = u.slice(0, o.encodingLength);
    return h[0] &= 248, h[c] &= 127, h[c] |= 64, h;
  }), i(s, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), i(s, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), i(s, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), s.prototype.sign = function(o) {
    return t(this._secret, "KeyPair can only verify"), this.eddsa.sign(o, this);
  }, s.prototype.verify = function(o, u) {
    return this.eddsa.verify(o, u, this);
  }, s.prototype.getSecret = function(o) {
    return t(this._secret, "KeyPair is public only"), e.encode(this.secret(), o);
  }, s.prototype.getPublic = function(o) {
    return e.encode(this.pubBytes(), o);
  }, Ru = s, Ru;
}
var Bu, U1;
function xx() {
  if (U1)
    return Bu;
  U1 = 1;
  var e = Wt, t = Or(), n = t.assert, i = t.cachedProperty, s = t.parseBytes;
  function r(o, u) {
    this.eddsa = o, typeof u != "object" && (u = s(u)), Array.isArray(u) && (u = {
      R: u.slice(0, o.encodingLength),
      S: u.slice(o.encodingLength)
    }), n(u.R && u.S, "Signature without R or S"), o.isPoint(u.R) && (this._R = u.R), u.S instanceof e && (this._S = u.S), this._Rencoded = Array.isArray(u.R) ? u.R : u.Rencoded, this._Sencoded = Array.isArray(u.S) ? u.S : u.Sencoded;
  }
  return i(r, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), i(r, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), i(r, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), i(r, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), r.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, r.prototype.toHex = function() {
    return t.encode(this.toBytes(), "hex").toUpperCase();
  }, Bu = r, Bu;
}
var Iu, F1;
function Ex() {
  if (F1)
    return Iu;
  F1 = 1;
  var e = m0(), t = _0(), n = Or(), i = n.assert, s = n.parseBytes, r = wx(), o = xx();
  function u(c) {
    if (i(c === "ed25519", "only tested with ed25519 so far"), !(this instanceof u))
      return new u(c);
    c = t[c].curve, this.curve = c, this.g = c.g, this.g.precompute(c.n.bitLength() + 1), this.pointClass = c.point().constructor, this.encodingLength = Math.ceil(c.n.bitLength() / 8), this.hash = e.sha512;
  }
  return Iu = u, u.prototype.sign = function(h, f) {
    h = s(h);
    var b = this.keyFromSecret(f), v = this.hashInt(b.messagePrefix(), h), m = this.g.mul(v), E = this.encodePoint(m), M = this.hashInt(E, b.pubBytes(), h).mul(b.priv()), B = v.add(M).umod(this.curve.n);
    return this.makeSignature({ R: m, S: B, Rencoded: E });
  }, u.prototype.verify = function(h, f, b) {
    h = s(h), f = this.makeSignature(f);
    var v = this.keyFromPublic(b), m = this.hashInt(f.Rencoded(), v.pubBytes(), h), E = this.g.mul(f.S()), M = f.R().add(v.pub().mul(m));
    return M.eq(E);
  }, u.prototype.hashInt = function() {
    for (var h = this.hash(), f = 0; f < arguments.length; f++)
      h.update(arguments[f]);
    return n.intFromLE(h.digest()).umod(this.curve.n);
  }, u.prototype.keyFromPublic = function(h) {
    return r.fromPublic(this, h);
  }, u.prototype.keyFromSecret = function(h) {
    return r.fromSecret(this, h);
  }, u.prototype.makeSignature = function(h) {
    return h instanceof o ? h : new o(this, h);
  }, u.prototype.encodePoint = function(h) {
    var f = h.getY().toArray("le", this.encodingLength);
    return f[this.encodingLength - 1] |= h.getX().isOdd() ? 128 : 0, f;
  }, u.prototype.decodePoint = function(h) {
    h = n.parseBytes(h);
    var f = h.length - 1, b = h.slice(0, f).concat(h[f] & -129), v = (h[f] & 128) !== 0, m = n.intFromLE(b);
    return this.curve.pointFromY(m, v);
  }, u.prototype.encodeInt = function(h) {
    return h.toArray("le", this.encodingLength);
  }, u.prototype.decodeInt = function(h) {
    return n.intFromLE(h);
  }, u.prototype.isPoint = function(h) {
    return h instanceof this.pointClass;
  }, Iu;
}
var H1;
function w0() {
  return H1 || (H1 = 1, function(e) {
    var t = e;
    t.version = fx.version, t.utils = Or(), t.rand = y0(), t.curve = hy(), t.curves = _0(), t.ec = _x(), t.eddsa = Ex();
  }(iu)), iu;
}
var va = { exports: {} };
va.exports;
var z1;
function vy() {
  return z1 || (z1 = 1, function(e) {
    (function(t, n) {
      function i(p, a) {
        if (!p)
          throw new Error(a || "Assertion failed");
      }
      function s(p, a) {
        p.super_ = a;
        var l = function() {
        };
        l.prototype = a.prototype, p.prototype = new l(), p.prototype.constructor = p;
      }
      function r(p, a, l) {
        if (r.isBN(p))
          return p;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, p !== null && ((a === "le" || a === "be") && (l = a, a = 10), this._init(p || 0, a || 10, l || "be"));
      }
      typeof t == "object" ? t.exports = r : n.BN = r, r.BN = r, r.wordSize = 26;
      var o;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = dr.Buffer;
      } catch {
      }
      r.isBN = function(a) {
        return a instanceof r ? !0 : a !== null && typeof a == "object" && a.constructor.wordSize === r.wordSize && Array.isArray(a.words);
      }, r.max = function(a, l) {
        return a.cmp(l) > 0 ? a : l;
      }, r.min = function(a, l) {
        return a.cmp(l) < 0 ? a : l;
      }, r.prototype._init = function(a, l, _) {
        if (typeof a == "number")
          return this._initNumber(a, l, _);
        if (typeof a == "object")
          return this._initArray(a, l, _);
        l === "hex" && (l = 16), i(l === (l | 0) && l >= 2 && l <= 36), a = a.toString().replace(/\s+/g, "");
        var x = 0;
        a[0] === "-" && (x++, this.negative = 1), x < a.length && (l === 16 ? this._parseHex(a, x, _) : (this._parseBase(a, l, x), _ === "le" && this._initArray(this.toArray(), l, _)));
      }, r.prototype._initNumber = function(a, l, _) {
        a < 0 && (this.negative = 1, a = -a), a < 67108864 ? (this.words = [a & 67108863], this.length = 1) : a < 4503599627370496 ? (this.words = [
          a & 67108863,
          a / 67108864 & 67108863
        ], this.length = 2) : (i(a < 9007199254740992), this.words = [
          a & 67108863,
          a / 67108864 & 67108863,
          1
        ], this.length = 3), _ === "le" && this._initArray(this.toArray(), l, _);
      }, r.prototype._initArray = function(a, l, _) {
        if (i(typeof a.length == "number"), a.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(a.length / 3), this.words = new Array(this.length);
        for (var x = 0; x < this.length; x++)
          this.words[x] = 0;
        var A, S, g = 0;
        if (_ === "be")
          for (x = a.length - 1, A = 0; x >= 0; x -= 3)
            S = a[x] | a[x - 1] << 8 | a[x - 2] << 16, this.words[A] |= S << g & 67108863, this.words[A + 1] = S >>> 26 - g & 67108863, g += 24, g >= 26 && (g -= 26, A++);
        else if (_ === "le")
          for (x = 0, A = 0; x < a.length; x += 3)
            S = a[x] | a[x + 1] << 8 | a[x + 2] << 16, this.words[A] |= S << g & 67108863, this.words[A + 1] = S >>> 26 - g & 67108863, g += 24, g >= 26 && (g -= 26, A++);
        return this._strip();
      };
      function u(p, a) {
        var l = p.charCodeAt(a);
        if (l >= 48 && l <= 57)
          return l - 48;
        if (l >= 65 && l <= 70)
          return l - 55;
        if (l >= 97 && l <= 102)
          return l - 87;
        i(!1, "Invalid character in " + p);
      }
      function c(p, a, l) {
        var _ = u(p, l);
        return l - 1 >= a && (_ |= u(p, l - 1) << 4), _;
      }
      r.prototype._parseHex = function(a, l, _) {
        this.length = Math.ceil((a.length - l) / 6), this.words = new Array(this.length);
        for (var x = 0; x < this.length; x++)
          this.words[x] = 0;
        var A = 0, S = 0, g;
        if (_ === "be")
          for (x = a.length - 1; x >= l; x -= 2)
            g = c(a, l, x) << A, this.words[S] |= g & 67108863, A >= 18 ? (A -= 18, S += 1, this.words[S] |= g >>> 26) : A += 8;
        else {
          var w = a.length - l;
          for (x = w % 2 === 0 ? l + 1 : l; x < a.length; x += 2)
            g = c(a, l, x) << A, this.words[S] |= g & 67108863, A >= 18 ? (A -= 18, S += 1, this.words[S] |= g >>> 26) : A += 8;
        }
        this._strip();
      };
      function h(p, a, l, _) {
        for (var x = 0, A = 0, S = Math.min(p.length, l), g = a; g < S; g++) {
          var w = p.charCodeAt(g) - 48;
          x *= _, w >= 49 ? A = w - 49 + 10 : w >= 17 ? A = w - 17 + 10 : A = w, i(w >= 0 && A < _, "Invalid character"), x += A;
        }
        return x;
      }
      r.prototype._parseBase = function(a, l, _) {
        this.words = [0], this.length = 1;
        for (var x = 0, A = 1; A <= 67108863; A *= l)
          x++;
        x--, A = A / l | 0;
        for (var S = a.length - _, g = S % x, w = Math.min(S, S - g) + _, d = 0, R = _; R < w; R += x)
          d = h(a, R, R + x, l), this.imuln(A), this.words[0] + d < 67108864 ? this.words[0] += d : this._iaddn(d);
        if (g !== 0) {
          var G = 1;
          for (d = h(a, R, a.length, l), R = 0; R < g; R++)
            G *= l;
          this.imuln(G), this.words[0] + d < 67108864 ? this.words[0] += d : this._iaddn(d);
        }
        this._strip();
      }, r.prototype.copy = function(a) {
        a.words = new Array(this.length);
        for (var l = 0; l < this.length; l++)
          a.words[l] = this.words[l];
        a.length = this.length, a.negative = this.negative, a.red = this.red;
      };
      function f(p, a) {
        p.words = a.words, p.length = a.length, p.negative = a.negative, p.red = a.red;
      }
      if (r.prototype._move = function(a) {
        f(a, this);
      }, r.prototype.clone = function() {
        var a = new r(null);
        return this.copy(a), a;
      }, r.prototype._expand = function(a) {
        for (; this.length < a; )
          this.words[this.length++] = 0;
        return this;
      }, r.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, r.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          r.prototype[Symbol.for("nodejs.util.inspect.custom")] = b;
        } catch {
          r.prototype.inspect = b;
        }
      else
        r.prototype.inspect = b;
      function b() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var v = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], m = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], E = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      r.prototype.toString = function(a, l) {
        a = a || 10, l = l | 0 || 1;
        var _;
        if (a === 16 || a === "hex") {
          _ = "";
          for (var x = 0, A = 0, S = 0; S < this.length; S++) {
            var g = this.words[S], w = ((g << x | A) & 16777215).toString(16);
            A = g >>> 24 - x & 16777215, x += 2, x >= 26 && (x -= 26, S--), A !== 0 || S !== this.length - 1 ? _ = v[6 - w.length] + w + _ : _ = w + _;
          }
          for (A !== 0 && (_ = A.toString(16) + _); _.length % l !== 0; )
            _ = "0" + _;
          return this.negative !== 0 && (_ = "-" + _), _;
        }
        if (a === (a | 0) && a >= 2 && a <= 36) {
          var d = m[a], R = E[a];
          _ = "";
          var G = this.clone();
          for (G.negative = 0; !G.isZero(); ) {
            var fe = G.modrn(R).toString(a);
            G = G.idivn(R), G.isZero() ? _ = fe + _ : _ = v[d - fe.length] + fe + _;
          }
          for (this.isZero() && (_ = "0" + _); _.length % l !== 0; )
            _ = "0" + _;
          return this.negative !== 0 && (_ = "-" + _), _;
        }
        i(!1, "Base should be between 2 and 36");
      }, r.prototype.toNumber = function() {
        var a = this.words[0];
        return this.length === 2 ? a += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? a += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -a : a;
      }, r.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, o && (r.prototype.toBuffer = function(a, l) {
        return this.toArrayLike(o, a, l);
      }), r.prototype.toArray = function(a, l) {
        return this.toArrayLike(Array, a, l);
      };
      var M = function(a, l) {
        return a.allocUnsafe ? a.allocUnsafe(l) : new a(l);
      };
      r.prototype.toArrayLike = function(a, l, _) {
        this._strip();
        var x = this.byteLength(), A = _ || Math.max(1, x);
        i(x <= A, "byte array longer than desired length"), i(A > 0, "Requested array length <= 0");
        var S = M(a, A), g = l === "le" ? "LE" : "BE";
        return this["_toArrayLike" + g](S, x), S;
      }, r.prototype._toArrayLikeLE = function(a, l) {
        for (var _ = 0, x = 0, A = 0, S = 0; A < this.length; A++) {
          var g = this.words[A] << S | x;
          a[_++] = g & 255, _ < a.length && (a[_++] = g >> 8 & 255), _ < a.length && (a[_++] = g >> 16 & 255), S === 6 ? (_ < a.length && (a[_++] = g >> 24 & 255), x = 0, S = 0) : (x = g >>> 24, S += 2);
        }
        if (_ < a.length)
          for (a[_++] = x; _ < a.length; )
            a[_++] = 0;
      }, r.prototype._toArrayLikeBE = function(a, l) {
        for (var _ = a.length - 1, x = 0, A = 0, S = 0; A < this.length; A++) {
          var g = this.words[A] << S | x;
          a[_--] = g & 255, _ >= 0 && (a[_--] = g >> 8 & 255), _ >= 0 && (a[_--] = g >> 16 & 255), S === 6 ? (_ >= 0 && (a[_--] = g >> 24 & 255), x = 0, S = 0) : (x = g >>> 24, S += 2);
        }
        if (_ >= 0)
          for (a[_--] = x; _ >= 0; )
            a[_--] = 0;
      }, Math.clz32 ? r.prototype._countBits = function(a) {
        return 32 - Math.clz32(a);
      } : r.prototype._countBits = function(a) {
        var l = a, _ = 0;
        return l >= 4096 && (_ += 13, l >>>= 13), l >= 64 && (_ += 7, l >>>= 7), l >= 8 && (_ += 4, l >>>= 4), l >= 2 && (_ += 2, l >>>= 2), _ + l;
      }, r.prototype._zeroBits = function(a) {
        if (a === 0)
          return 26;
        var l = a, _ = 0;
        return l & 8191 || (_ += 13, l >>>= 13), l & 127 || (_ += 7, l >>>= 7), l & 15 || (_ += 4, l >>>= 4), l & 3 || (_ += 2, l >>>= 2), l & 1 || _++, _;
      }, r.prototype.bitLength = function() {
        var a = this.words[this.length - 1], l = this._countBits(a);
        return (this.length - 1) * 26 + l;
      };
      function B(p) {
        for (var a = new Array(p.bitLength()), l = 0; l < a.length; l++) {
          var _ = l / 26 | 0, x = l % 26;
          a[l] = p.words[_] >>> x & 1;
        }
        return a;
      }
      r.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var a = 0, l = 0; l < this.length; l++) {
          var _ = this._zeroBits(this.words[l]);
          if (a += _, _ !== 26)
            break;
        }
        return a;
      }, r.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, r.prototype.toTwos = function(a) {
        return this.negative !== 0 ? this.abs().inotn(a).iaddn(1) : this.clone();
      }, r.prototype.fromTwos = function(a) {
        return this.testn(a - 1) ? this.notn(a).iaddn(1).ineg() : this.clone();
      }, r.prototype.isNeg = function() {
        return this.negative !== 0;
      }, r.prototype.neg = function() {
        return this.clone().ineg();
      }, r.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, r.prototype.iuor = function(a) {
        for (; this.length < a.length; )
          this.words[this.length++] = 0;
        for (var l = 0; l < a.length; l++)
          this.words[l] = this.words[l] | a.words[l];
        return this._strip();
      }, r.prototype.ior = function(a) {
        return i((this.negative | a.negative) === 0), this.iuor(a);
      }, r.prototype.or = function(a) {
        return this.length > a.length ? this.clone().ior(a) : a.clone().ior(this);
      }, r.prototype.uor = function(a) {
        return this.length > a.length ? this.clone().iuor(a) : a.clone().iuor(this);
      }, r.prototype.iuand = function(a) {
        var l;
        this.length > a.length ? l = a : l = this;
        for (var _ = 0; _ < l.length; _++)
          this.words[_] = this.words[_] & a.words[_];
        return this.length = l.length, this._strip();
      }, r.prototype.iand = function(a) {
        return i((this.negative | a.negative) === 0), this.iuand(a);
      }, r.prototype.and = function(a) {
        return this.length > a.length ? this.clone().iand(a) : a.clone().iand(this);
      }, r.prototype.uand = function(a) {
        return this.length > a.length ? this.clone().iuand(a) : a.clone().iuand(this);
      }, r.prototype.iuxor = function(a) {
        var l, _;
        this.length > a.length ? (l = this, _ = a) : (l = a, _ = this);
        for (var x = 0; x < _.length; x++)
          this.words[x] = l.words[x] ^ _.words[x];
        if (this !== l)
          for (; x < l.length; x++)
            this.words[x] = l.words[x];
        return this.length = l.length, this._strip();
      }, r.prototype.ixor = function(a) {
        return i((this.negative | a.negative) === 0), this.iuxor(a);
      }, r.prototype.xor = function(a) {
        return this.length > a.length ? this.clone().ixor(a) : a.clone().ixor(this);
      }, r.prototype.uxor = function(a) {
        return this.length > a.length ? this.clone().iuxor(a) : a.clone().iuxor(this);
      }, r.prototype.inotn = function(a) {
        i(typeof a == "number" && a >= 0);
        var l = Math.ceil(a / 26) | 0, _ = a % 26;
        this._expand(l), _ > 0 && l--;
        for (var x = 0; x < l; x++)
          this.words[x] = ~this.words[x] & 67108863;
        return _ > 0 && (this.words[x] = ~this.words[x] & 67108863 >> 26 - _), this._strip();
      }, r.prototype.notn = function(a) {
        return this.clone().inotn(a);
      }, r.prototype.setn = function(a, l) {
        i(typeof a == "number" && a >= 0);
        var _ = a / 26 | 0, x = a % 26;
        return this._expand(_ + 1), l ? this.words[_] = this.words[_] | 1 << x : this.words[_] = this.words[_] & ~(1 << x), this._strip();
      }, r.prototype.iadd = function(a) {
        var l;
        if (this.negative !== 0 && a.negative === 0)
          return this.negative = 0, l = this.isub(a), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && a.negative !== 0)
          return a.negative = 0, l = this.isub(a), a.negative = 1, l._normSign();
        var _, x;
        this.length > a.length ? (_ = this, x = a) : (_ = a, x = this);
        for (var A = 0, S = 0; S < x.length; S++)
          l = (_.words[S] | 0) + (x.words[S] | 0) + A, this.words[S] = l & 67108863, A = l >>> 26;
        for (; A !== 0 && S < _.length; S++)
          l = (_.words[S] | 0) + A, this.words[S] = l & 67108863, A = l >>> 26;
        if (this.length = _.length, A !== 0)
          this.words[this.length] = A, this.length++;
        else if (_ !== this)
          for (; S < _.length; S++)
            this.words[S] = _.words[S];
        return this;
      }, r.prototype.add = function(a) {
        var l;
        return a.negative !== 0 && this.negative === 0 ? (a.negative = 0, l = this.sub(a), a.negative ^= 1, l) : a.negative === 0 && this.negative !== 0 ? (this.negative = 0, l = a.sub(this), this.negative = 1, l) : this.length > a.length ? this.clone().iadd(a) : a.clone().iadd(this);
      }, r.prototype.isub = function(a) {
        if (a.negative !== 0) {
          a.negative = 0;
          var l = this.iadd(a);
          return a.negative = 1, l._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(a), this.negative = 1, this._normSign();
        var _ = this.cmp(a);
        if (_ === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var x, A;
        _ > 0 ? (x = this, A = a) : (x = a, A = this);
        for (var S = 0, g = 0; g < A.length; g++)
          l = (x.words[g] | 0) - (A.words[g] | 0) + S, S = l >> 26, this.words[g] = l & 67108863;
        for (; S !== 0 && g < x.length; g++)
          l = (x.words[g] | 0) + S, S = l >> 26, this.words[g] = l & 67108863;
        if (S === 0 && g < x.length && x !== this)
          for (; g < x.length; g++)
            this.words[g] = x.words[g];
        return this.length = Math.max(this.length, g), x !== this && (this.negative = 1), this._strip();
      }, r.prototype.sub = function(a) {
        return this.clone().isub(a);
      };
      function I(p, a, l) {
        l.negative = a.negative ^ p.negative;
        var _ = p.length + a.length | 0;
        l.length = _, _ = _ - 1 | 0;
        var x = p.words[0] | 0, A = a.words[0] | 0, S = x * A, g = S & 67108863, w = S / 67108864 | 0;
        l.words[0] = g;
        for (var d = 1; d < _; d++) {
          for (var R = w >>> 26, G = w & 67108863, fe = Math.min(d, a.length - 1), z = Math.max(0, d - p.length + 1); z <= fe; z++) {
            var V = d - z | 0;
            x = p.words[V] | 0, A = a.words[z] | 0, S = x * A + G, R += S / 67108864 | 0, G = S & 67108863;
          }
          l.words[d] = G | 0, w = R | 0;
        }
        return w !== 0 ? l.words[d] = w | 0 : l.length--, l._strip();
      }
      var T = function(a, l, _) {
        var x = a.words, A = l.words, S = _.words, g = 0, w, d, R, G = x[0] | 0, fe = G & 8191, z = G >>> 13, V = x[1] | 0, F = V & 8191, ee = V >>> 13, he = x[2] | 0, Z = he & 8191, K = he >>> 13, ce = x[3] | 0, ve = ce & 8191, Be = ce >>> 13, Q = x[4] | 0, C = Q & 8191, L = Q >>> 13, W = x[5] | 0, de = W & 8191, me = W >>> 13, Te = x[6] | 0, Fe = Te & 8191, H = Te >>> 13, ue = x[7] | 0, se = ue & 8191, we = ue >>> 13, Ce = x[8] | 0, ze = Ce & 8191, Le = Ce >>> 13, Y = x[9] | 0, Se = Y & 8191, Ae = Y >>> 13, je = A[0] | 0, pe = je & 8191, Ee = je >>> 13, J = A[1] | 0, Ie = J & 8191, ke = J >>> 13, P = A[2] | 0, Me = P & 8191, be = P >>> 13, ie = A[3] | 0, le = ie & 8191, ge = ie >>> 13, Ge = A[4] | 0, De = Ge & 8191, Ne = Ge >>> 13, rt = A[5] | 0, ft = rt & 8191, We = rt >>> 13, at = A[6] | 0, $ = at & 8191, X = at >>> 13, ne = A[7] | 0, O = ne & 8191, ae = ne >>> 13, _e = A[8] | 0, xe = _e & 8191, Re = _e >>> 13, qe = A[9] | 0, He = qe & 8191, $e = qe >>> 13;
        _.negative = a.negative ^ l.negative, _.length = 19, w = Math.imul(fe, pe), d = Math.imul(fe, Ee), d = d + Math.imul(z, pe) | 0, R = Math.imul(z, Ee);
        var vt = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, w = Math.imul(F, pe), d = Math.imul(F, Ee), d = d + Math.imul(ee, pe) | 0, R = Math.imul(ee, Ee), w = w + Math.imul(fe, Ie) | 0, d = d + Math.imul(fe, ke) | 0, d = d + Math.imul(z, Ie) | 0, R = R + Math.imul(z, ke) | 0;
        var Qe = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, w = Math.imul(Z, pe), d = Math.imul(Z, Ee), d = d + Math.imul(K, pe) | 0, R = Math.imul(K, Ee), w = w + Math.imul(F, Ie) | 0, d = d + Math.imul(F, ke) | 0, d = d + Math.imul(ee, Ie) | 0, R = R + Math.imul(ee, ke) | 0, w = w + Math.imul(fe, Me) | 0, d = d + Math.imul(fe, be) | 0, d = d + Math.imul(z, Me) | 0, R = R + Math.imul(z, be) | 0;
        var ot = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, w = Math.imul(ve, pe), d = Math.imul(ve, Ee), d = d + Math.imul(Be, pe) | 0, R = Math.imul(Be, Ee), w = w + Math.imul(Z, Ie) | 0, d = d + Math.imul(Z, ke) | 0, d = d + Math.imul(K, Ie) | 0, R = R + Math.imul(K, ke) | 0, w = w + Math.imul(F, Me) | 0, d = d + Math.imul(F, be) | 0, d = d + Math.imul(ee, Me) | 0, R = R + Math.imul(ee, be) | 0, w = w + Math.imul(fe, le) | 0, d = d + Math.imul(fe, ge) | 0, d = d + Math.imul(z, le) | 0, R = R + Math.imul(z, ge) | 0;
        var st = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, w = Math.imul(C, pe), d = Math.imul(C, Ee), d = d + Math.imul(L, pe) | 0, R = Math.imul(L, Ee), w = w + Math.imul(ve, Ie) | 0, d = d + Math.imul(ve, ke) | 0, d = d + Math.imul(Be, Ie) | 0, R = R + Math.imul(Be, ke) | 0, w = w + Math.imul(Z, Me) | 0, d = d + Math.imul(Z, be) | 0, d = d + Math.imul(K, Me) | 0, R = R + Math.imul(K, be) | 0, w = w + Math.imul(F, le) | 0, d = d + Math.imul(F, ge) | 0, d = d + Math.imul(ee, le) | 0, R = R + Math.imul(ee, ge) | 0, w = w + Math.imul(fe, De) | 0, d = d + Math.imul(fe, Ne) | 0, d = d + Math.imul(z, De) | 0, R = R + Math.imul(z, Ne) | 0;
        var dt = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, w = Math.imul(de, pe), d = Math.imul(de, Ee), d = d + Math.imul(me, pe) | 0, R = Math.imul(me, Ee), w = w + Math.imul(C, Ie) | 0, d = d + Math.imul(C, ke) | 0, d = d + Math.imul(L, Ie) | 0, R = R + Math.imul(L, ke) | 0, w = w + Math.imul(ve, Me) | 0, d = d + Math.imul(ve, be) | 0, d = d + Math.imul(Be, Me) | 0, R = R + Math.imul(Be, be) | 0, w = w + Math.imul(Z, le) | 0, d = d + Math.imul(Z, ge) | 0, d = d + Math.imul(K, le) | 0, R = R + Math.imul(K, ge) | 0, w = w + Math.imul(F, De) | 0, d = d + Math.imul(F, Ne) | 0, d = d + Math.imul(ee, De) | 0, R = R + Math.imul(ee, Ne) | 0, w = w + Math.imul(fe, ft) | 0, d = d + Math.imul(fe, We) | 0, d = d + Math.imul(z, ft) | 0, R = R + Math.imul(z, We) | 0;
        var lt = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (lt >>> 26) | 0, lt &= 67108863, w = Math.imul(Fe, pe), d = Math.imul(Fe, Ee), d = d + Math.imul(H, pe) | 0, R = Math.imul(H, Ee), w = w + Math.imul(de, Ie) | 0, d = d + Math.imul(de, ke) | 0, d = d + Math.imul(me, Ie) | 0, R = R + Math.imul(me, ke) | 0, w = w + Math.imul(C, Me) | 0, d = d + Math.imul(C, be) | 0, d = d + Math.imul(L, Me) | 0, R = R + Math.imul(L, be) | 0, w = w + Math.imul(ve, le) | 0, d = d + Math.imul(ve, ge) | 0, d = d + Math.imul(Be, le) | 0, R = R + Math.imul(Be, ge) | 0, w = w + Math.imul(Z, De) | 0, d = d + Math.imul(Z, Ne) | 0, d = d + Math.imul(K, De) | 0, R = R + Math.imul(K, Ne) | 0, w = w + Math.imul(F, ft) | 0, d = d + Math.imul(F, We) | 0, d = d + Math.imul(ee, ft) | 0, R = R + Math.imul(ee, We) | 0, w = w + Math.imul(fe, $) | 0, d = d + Math.imul(fe, X) | 0, d = d + Math.imul(z, $) | 0, R = R + Math.imul(z, X) | 0;
        var ut = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, w = Math.imul(se, pe), d = Math.imul(se, Ee), d = d + Math.imul(we, pe) | 0, R = Math.imul(we, Ee), w = w + Math.imul(Fe, Ie) | 0, d = d + Math.imul(Fe, ke) | 0, d = d + Math.imul(H, Ie) | 0, R = R + Math.imul(H, ke) | 0, w = w + Math.imul(de, Me) | 0, d = d + Math.imul(de, be) | 0, d = d + Math.imul(me, Me) | 0, R = R + Math.imul(me, be) | 0, w = w + Math.imul(C, le) | 0, d = d + Math.imul(C, ge) | 0, d = d + Math.imul(L, le) | 0, R = R + Math.imul(L, ge) | 0, w = w + Math.imul(ve, De) | 0, d = d + Math.imul(ve, Ne) | 0, d = d + Math.imul(Be, De) | 0, R = R + Math.imul(Be, Ne) | 0, w = w + Math.imul(Z, ft) | 0, d = d + Math.imul(Z, We) | 0, d = d + Math.imul(K, ft) | 0, R = R + Math.imul(K, We) | 0, w = w + Math.imul(F, $) | 0, d = d + Math.imul(F, X) | 0, d = d + Math.imul(ee, $) | 0, R = R + Math.imul(ee, X) | 0, w = w + Math.imul(fe, O) | 0, d = d + Math.imul(fe, ae) | 0, d = d + Math.imul(z, O) | 0, R = R + Math.imul(z, ae) | 0;
        var ht = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, w = Math.imul(ze, pe), d = Math.imul(ze, Ee), d = d + Math.imul(Le, pe) | 0, R = Math.imul(Le, Ee), w = w + Math.imul(se, Ie) | 0, d = d + Math.imul(se, ke) | 0, d = d + Math.imul(we, Ie) | 0, R = R + Math.imul(we, ke) | 0, w = w + Math.imul(Fe, Me) | 0, d = d + Math.imul(Fe, be) | 0, d = d + Math.imul(H, Me) | 0, R = R + Math.imul(H, be) | 0, w = w + Math.imul(de, le) | 0, d = d + Math.imul(de, ge) | 0, d = d + Math.imul(me, le) | 0, R = R + Math.imul(me, ge) | 0, w = w + Math.imul(C, De) | 0, d = d + Math.imul(C, Ne) | 0, d = d + Math.imul(L, De) | 0, R = R + Math.imul(L, Ne) | 0, w = w + Math.imul(ve, ft) | 0, d = d + Math.imul(ve, We) | 0, d = d + Math.imul(Be, ft) | 0, R = R + Math.imul(Be, We) | 0, w = w + Math.imul(Z, $) | 0, d = d + Math.imul(Z, X) | 0, d = d + Math.imul(K, $) | 0, R = R + Math.imul(K, X) | 0, w = w + Math.imul(F, O) | 0, d = d + Math.imul(F, ae) | 0, d = d + Math.imul(ee, O) | 0, R = R + Math.imul(ee, ae) | 0, w = w + Math.imul(fe, xe) | 0, d = d + Math.imul(fe, Re) | 0, d = d + Math.imul(z, xe) | 0, R = R + Math.imul(z, Re) | 0;
        var ct = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, w = Math.imul(Se, pe), d = Math.imul(Se, Ee), d = d + Math.imul(Ae, pe) | 0, R = Math.imul(Ae, Ee), w = w + Math.imul(ze, Ie) | 0, d = d + Math.imul(ze, ke) | 0, d = d + Math.imul(Le, Ie) | 0, R = R + Math.imul(Le, ke) | 0, w = w + Math.imul(se, Me) | 0, d = d + Math.imul(se, be) | 0, d = d + Math.imul(we, Me) | 0, R = R + Math.imul(we, be) | 0, w = w + Math.imul(Fe, le) | 0, d = d + Math.imul(Fe, ge) | 0, d = d + Math.imul(H, le) | 0, R = R + Math.imul(H, ge) | 0, w = w + Math.imul(de, De) | 0, d = d + Math.imul(de, Ne) | 0, d = d + Math.imul(me, De) | 0, R = R + Math.imul(me, Ne) | 0, w = w + Math.imul(C, ft) | 0, d = d + Math.imul(C, We) | 0, d = d + Math.imul(L, ft) | 0, R = R + Math.imul(L, We) | 0, w = w + Math.imul(ve, $) | 0, d = d + Math.imul(ve, X) | 0, d = d + Math.imul(Be, $) | 0, R = R + Math.imul(Be, X) | 0, w = w + Math.imul(Z, O) | 0, d = d + Math.imul(Z, ae) | 0, d = d + Math.imul(K, O) | 0, R = R + Math.imul(K, ae) | 0, w = w + Math.imul(F, xe) | 0, d = d + Math.imul(F, Re) | 0, d = d + Math.imul(ee, xe) | 0, R = R + Math.imul(ee, Re) | 0, w = w + Math.imul(fe, He) | 0, d = d + Math.imul(fe, $e) | 0, d = d + Math.imul(z, He) | 0, R = R + Math.imul(z, $e) | 0;
        var et = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, w = Math.imul(Se, Ie), d = Math.imul(Se, ke), d = d + Math.imul(Ae, Ie) | 0, R = Math.imul(Ae, ke), w = w + Math.imul(ze, Me) | 0, d = d + Math.imul(ze, be) | 0, d = d + Math.imul(Le, Me) | 0, R = R + Math.imul(Le, be) | 0, w = w + Math.imul(se, le) | 0, d = d + Math.imul(se, ge) | 0, d = d + Math.imul(we, le) | 0, R = R + Math.imul(we, ge) | 0, w = w + Math.imul(Fe, De) | 0, d = d + Math.imul(Fe, Ne) | 0, d = d + Math.imul(H, De) | 0, R = R + Math.imul(H, Ne) | 0, w = w + Math.imul(de, ft) | 0, d = d + Math.imul(de, We) | 0, d = d + Math.imul(me, ft) | 0, R = R + Math.imul(me, We) | 0, w = w + Math.imul(C, $) | 0, d = d + Math.imul(C, X) | 0, d = d + Math.imul(L, $) | 0, R = R + Math.imul(L, X) | 0, w = w + Math.imul(ve, O) | 0, d = d + Math.imul(ve, ae) | 0, d = d + Math.imul(Be, O) | 0, R = R + Math.imul(Be, ae) | 0, w = w + Math.imul(Z, xe) | 0, d = d + Math.imul(Z, Re) | 0, d = d + Math.imul(K, xe) | 0, R = R + Math.imul(K, Re) | 0, w = w + Math.imul(F, He) | 0, d = d + Math.imul(F, $e) | 0, d = d + Math.imul(ee, He) | 0, R = R + Math.imul(ee, $e) | 0;
        var it = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, w = Math.imul(Se, Me), d = Math.imul(Se, be), d = d + Math.imul(Ae, Me) | 0, R = Math.imul(Ae, be), w = w + Math.imul(ze, le) | 0, d = d + Math.imul(ze, ge) | 0, d = d + Math.imul(Le, le) | 0, R = R + Math.imul(Le, ge) | 0, w = w + Math.imul(se, De) | 0, d = d + Math.imul(se, Ne) | 0, d = d + Math.imul(we, De) | 0, R = R + Math.imul(we, Ne) | 0, w = w + Math.imul(Fe, ft) | 0, d = d + Math.imul(Fe, We) | 0, d = d + Math.imul(H, ft) | 0, R = R + Math.imul(H, We) | 0, w = w + Math.imul(de, $) | 0, d = d + Math.imul(de, X) | 0, d = d + Math.imul(me, $) | 0, R = R + Math.imul(me, X) | 0, w = w + Math.imul(C, O) | 0, d = d + Math.imul(C, ae) | 0, d = d + Math.imul(L, O) | 0, R = R + Math.imul(L, ae) | 0, w = w + Math.imul(ve, xe) | 0, d = d + Math.imul(ve, Re) | 0, d = d + Math.imul(Be, xe) | 0, R = R + Math.imul(Be, Re) | 0, w = w + Math.imul(Z, He) | 0, d = d + Math.imul(Z, $e) | 0, d = d + Math.imul(K, He) | 0, R = R + Math.imul(K, $e) | 0;
        var Ye = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, w = Math.imul(Se, le), d = Math.imul(Se, ge), d = d + Math.imul(Ae, le) | 0, R = Math.imul(Ae, ge), w = w + Math.imul(ze, De) | 0, d = d + Math.imul(ze, Ne) | 0, d = d + Math.imul(Le, De) | 0, R = R + Math.imul(Le, Ne) | 0, w = w + Math.imul(se, ft) | 0, d = d + Math.imul(se, We) | 0, d = d + Math.imul(we, ft) | 0, R = R + Math.imul(we, We) | 0, w = w + Math.imul(Fe, $) | 0, d = d + Math.imul(Fe, X) | 0, d = d + Math.imul(H, $) | 0, R = R + Math.imul(H, X) | 0, w = w + Math.imul(de, O) | 0, d = d + Math.imul(de, ae) | 0, d = d + Math.imul(me, O) | 0, R = R + Math.imul(me, ae) | 0, w = w + Math.imul(C, xe) | 0, d = d + Math.imul(C, Re) | 0, d = d + Math.imul(L, xe) | 0, R = R + Math.imul(L, Re) | 0, w = w + Math.imul(ve, He) | 0, d = d + Math.imul(ve, $e) | 0, d = d + Math.imul(Be, He) | 0, R = R + Math.imul(Be, $e) | 0;
        var tt = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, w = Math.imul(Se, De), d = Math.imul(Se, Ne), d = d + Math.imul(Ae, De) | 0, R = Math.imul(Ae, Ne), w = w + Math.imul(ze, ft) | 0, d = d + Math.imul(ze, We) | 0, d = d + Math.imul(Le, ft) | 0, R = R + Math.imul(Le, We) | 0, w = w + Math.imul(se, $) | 0, d = d + Math.imul(se, X) | 0, d = d + Math.imul(we, $) | 0, R = R + Math.imul(we, X) | 0, w = w + Math.imul(Fe, O) | 0, d = d + Math.imul(Fe, ae) | 0, d = d + Math.imul(H, O) | 0, R = R + Math.imul(H, ae) | 0, w = w + Math.imul(de, xe) | 0, d = d + Math.imul(de, Re) | 0, d = d + Math.imul(me, xe) | 0, R = R + Math.imul(me, Re) | 0, w = w + Math.imul(C, He) | 0, d = d + Math.imul(C, $e) | 0, d = d + Math.imul(L, He) | 0, R = R + Math.imul(L, $e) | 0;
        var nt = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, w = Math.imul(Se, ft), d = Math.imul(Se, We), d = d + Math.imul(Ae, ft) | 0, R = Math.imul(Ae, We), w = w + Math.imul(ze, $) | 0, d = d + Math.imul(ze, X) | 0, d = d + Math.imul(Le, $) | 0, R = R + Math.imul(Le, X) | 0, w = w + Math.imul(se, O) | 0, d = d + Math.imul(se, ae) | 0, d = d + Math.imul(we, O) | 0, R = R + Math.imul(we, ae) | 0, w = w + Math.imul(Fe, xe) | 0, d = d + Math.imul(Fe, Re) | 0, d = d + Math.imul(H, xe) | 0, R = R + Math.imul(H, Re) | 0, w = w + Math.imul(de, He) | 0, d = d + Math.imul(de, $e) | 0, d = d + Math.imul(me, He) | 0, R = R + Math.imul(me, $e) | 0;
        var Xe = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, w = Math.imul(Se, $), d = Math.imul(Se, X), d = d + Math.imul(Ae, $) | 0, R = Math.imul(Ae, X), w = w + Math.imul(ze, O) | 0, d = d + Math.imul(ze, ae) | 0, d = d + Math.imul(Le, O) | 0, R = R + Math.imul(Le, ae) | 0, w = w + Math.imul(se, xe) | 0, d = d + Math.imul(se, Re) | 0, d = d + Math.imul(we, xe) | 0, R = R + Math.imul(we, Re) | 0, w = w + Math.imul(Fe, He) | 0, d = d + Math.imul(Fe, $e) | 0, d = d + Math.imul(H, He) | 0, R = R + Math.imul(H, $e) | 0;
        var Oe = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, w = Math.imul(Se, O), d = Math.imul(Se, ae), d = d + Math.imul(Ae, O) | 0, R = Math.imul(Ae, ae), w = w + Math.imul(ze, xe) | 0, d = d + Math.imul(ze, Re) | 0, d = d + Math.imul(Le, xe) | 0, R = R + Math.imul(Le, Re) | 0, w = w + Math.imul(se, He) | 0, d = d + Math.imul(se, $e) | 0, d = d + Math.imul(we, He) | 0, R = R + Math.imul(we, $e) | 0;
        var Pe = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, w = Math.imul(Se, xe), d = Math.imul(Se, Re), d = d + Math.imul(Ae, xe) | 0, R = Math.imul(Ae, Re), w = w + Math.imul(ze, He) | 0, d = d + Math.imul(ze, $e) | 0, d = d + Math.imul(Le, He) | 0, R = R + Math.imul(Le, $e) | 0;
        var Ke = (g + w | 0) + ((d & 8191) << 13) | 0;
        g = (R + (d >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, w = Math.imul(Se, He), d = Math.imul(Se, $e), d = d + Math.imul(Ae, He) | 0, R = Math.imul(Ae, $e);
        var Ue = (g + w | 0) + ((d & 8191) << 13) | 0;
        return g = (R + (d >>> 13) | 0) + (Ue >>> 26) | 0, Ue &= 67108863, S[0] = vt, S[1] = Qe, S[2] = ot, S[3] = st, S[4] = dt, S[5] = lt, S[6] = ut, S[7] = ht, S[8] = ct, S[9] = et, S[10] = it, S[11] = Ye, S[12] = tt, S[13] = nt, S[14] = Xe, S[15] = Oe, S[16] = Pe, S[17] = Ke, S[18] = Ue, g !== 0 && (S[19] = g, _.length++), _;
      };
      Math.imul || (T = I);
      function k(p, a, l) {
        l.negative = a.negative ^ p.negative, l.length = p.length + a.length;
        for (var _ = 0, x = 0, A = 0; A < l.length - 1; A++) {
          var S = x;
          x = 0;
          for (var g = _ & 67108863, w = Math.min(A, a.length - 1), d = Math.max(0, A - p.length + 1); d <= w; d++) {
            var R = A - d, G = p.words[R] | 0, fe = a.words[d] | 0, z = G * fe, V = z & 67108863;
            S = S + (z / 67108864 | 0) | 0, V = V + g | 0, g = V & 67108863, S = S + (V >>> 26) | 0, x += S >>> 26, S &= 67108863;
          }
          l.words[A] = g, _ = S, S = x;
        }
        return _ !== 0 ? l.words[A] = _ : l.length--, l._strip();
      }
      function j(p, a, l) {
        return k(p, a, l);
      }
      r.prototype.mulTo = function(a, l) {
        var _, x = this.length + a.length;
        return this.length === 10 && a.length === 10 ? _ = T(this, a, l) : x < 63 ? _ = I(this, a, l) : x < 1024 ? _ = k(this, a, l) : _ = j(this, a, l), _;
      }, r.prototype.mul = function(a) {
        var l = new r(null);
        return l.words = new Array(this.length + a.length), this.mulTo(a, l);
      }, r.prototype.mulf = function(a) {
        var l = new r(null);
        return l.words = new Array(this.length + a.length), j(this, a, l);
      }, r.prototype.imul = function(a) {
        return this.clone().mulTo(a, this);
      }, r.prototype.imuln = function(a) {
        var l = a < 0;
        l && (a = -a), i(typeof a == "number"), i(a < 67108864);
        for (var _ = 0, x = 0; x < this.length; x++) {
          var A = (this.words[x] | 0) * a, S = (A & 67108863) + (_ & 67108863);
          _ >>= 26, _ += A / 67108864 | 0, _ += S >>> 26, this.words[x] = S & 67108863;
        }
        return _ !== 0 && (this.words[x] = _, this.length++), l ? this.ineg() : this;
      }, r.prototype.muln = function(a) {
        return this.clone().imuln(a);
      }, r.prototype.sqr = function() {
        return this.mul(this);
      }, r.prototype.isqr = function() {
        return this.imul(this.clone());
      }, r.prototype.pow = function(a) {
        var l = B(a);
        if (l.length === 0)
          return new r(1);
        for (var _ = this, x = 0; x < l.length && l[x] === 0; x++, _ = _.sqr())
          ;
        if (++x < l.length)
          for (var A = _.sqr(); x < l.length; x++, A = A.sqr())
            l[x] !== 0 && (_ = _.mul(A));
        return _;
      }, r.prototype.iushln = function(a) {
        i(typeof a == "number" && a >= 0);
        var l = a % 26, _ = (a - l) / 26, x = 67108863 >>> 26 - l << 26 - l, A;
        if (l !== 0) {
          var S = 0;
          for (A = 0; A < this.length; A++) {
            var g = this.words[A] & x, w = (this.words[A] | 0) - g << l;
            this.words[A] = w | S, S = g >>> 26 - l;
          }
          S && (this.words[A] = S, this.length++);
        }
        if (_ !== 0) {
          for (A = this.length - 1; A >= 0; A--)
            this.words[A + _] = this.words[A];
          for (A = 0; A < _; A++)
            this.words[A] = 0;
          this.length += _;
        }
        return this._strip();
      }, r.prototype.ishln = function(a) {
        return i(this.negative === 0), this.iushln(a);
      }, r.prototype.iushrn = function(a, l, _) {
        i(typeof a == "number" && a >= 0);
        var x;
        l ? x = (l - l % 26) / 26 : x = 0;
        var A = a % 26, S = Math.min((a - A) / 26, this.length), g = 67108863 ^ 67108863 >>> A << A, w = _;
        if (x -= S, x = Math.max(0, x), w) {
          for (var d = 0; d < S; d++)
            w.words[d] = this.words[d];
          w.length = S;
        }
        if (S !== 0)
          if (this.length > S)
            for (this.length -= S, d = 0; d < this.length; d++)
              this.words[d] = this.words[d + S];
          else
            this.words[0] = 0, this.length = 1;
        var R = 0;
        for (d = this.length - 1; d >= 0 && (R !== 0 || d >= x); d--) {
          var G = this.words[d] | 0;
          this.words[d] = R << 26 - A | G >>> A, R = G & g;
        }
        return w && R !== 0 && (w.words[w.length++] = R), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, r.prototype.ishrn = function(a, l, _) {
        return i(this.negative === 0), this.iushrn(a, l, _);
      }, r.prototype.shln = function(a) {
        return this.clone().ishln(a);
      }, r.prototype.ushln = function(a) {
        return this.clone().iushln(a);
      }, r.prototype.shrn = function(a) {
        return this.clone().ishrn(a);
      }, r.prototype.ushrn = function(a) {
        return this.clone().iushrn(a);
      }, r.prototype.testn = function(a) {
        i(typeof a == "number" && a >= 0);
        var l = a % 26, _ = (a - l) / 26, x = 1 << l;
        if (this.length <= _)
          return !1;
        var A = this.words[_];
        return !!(A & x);
      }, r.prototype.imaskn = function(a) {
        i(typeof a == "number" && a >= 0);
        var l = a % 26, _ = (a - l) / 26;
        if (i(this.negative === 0, "imaskn works only with positive numbers"), this.length <= _)
          return this;
        if (l !== 0 && _++, this.length = Math.min(_, this.length), l !== 0) {
          var x = 67108863 ^ 67108863 >>> l << l;
          this.words[this.length - 1] &= x;
        }
        return this._strip();
      }, r.prototype.maskn = function(a) {
        return this.clone().imaskn(a);
      }, r.prototype.iaddn = function(a) {
        return i(typeof a == "number"), i(a < 67108864), a < 0 ? this.isubn(-a) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= a ? (this.words[0] = a - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(a), this.negative = 1, this) : this._iaddn(a);
      }, r.prototype._iaddn = function(a) {
        this.words[0] += a;
        for (var l = 0; l < this.length && this.words[l] >= 67108864; l++)
          this.words[l] -= 67108864, l === this.length - 1 ? this.words[l + 1] = 1 : this.words[l + 1]++;
        return this.length = Math.max(this.length, l + 1), this;
      }, r.prototype.isubn = function(a) {
        if (i(typeof a == "number"), i(a < 67108864), a < 0)
          return this.iaddn(-a);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(a), this.negative = 1, this;
        if (this.words[0] -= a, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var l = 0; l < this.length && this.words[l] < 0; l++)
            this.words[l] += 67108864, this.words[l + 1] -= 1;
        return this._strip();
      }, r.prototype.addn = function(a) {
        return this.clone().iaddn(a);
      }, r.prototype.subn = function(a) {
        return this.clone().isubn(a);
      }, r.prototype.iabs = function() {
        return this.negative = 0, this;
      }, r.prototype.abs = function() {
        return this.clone().iabs();
      }, r.prototype._ishlnsubmul = function(a, l, _) {
        var x = a.length + _, A;
        this._expand(x);
        var S, g = 0;
        for (A = 0; A < a.length; A++) {
          S = (this.words[A + _] | 0) + g;
          var w = (a.words[A] | 0) * l;
          S -= w & 67108863, g = (S >> 26) - (w / 67108864 | 0), this.words[A + _] = S & 67108863;
        }
        for (; A < this.length - _; A++)
          S = (this.words[A + _] | 0) + g, g = S >> 26, this.words[A + _] = S & 67108863;
        if (g === 0)
          return this._strip();
        for (i(g === -1), g = 0, A = 0; A < this.length; A++)
          S = -(this.words[A] | 0) + g, g = S >> 26, this.words[A] = S & 67108863;
        return this.negative = 1, this._strip();
      }, r.prototype._wordDiv = function(a, l) {
        var _ = this.length - a.length, x = this.clone(), A = a, S = A.words[A.length - 1] | 0, g = this._countBits(S);
        _ = 26 - g, _ !== 0 && (A = A.ushln(_), x.iushln(_), S = A.words[A.length - 1] | 0);
        var w = x.length - A.length, d;
        if (l !== "mod") {
          d = new r(null), d.length = w + 1, d.words = new Array(d.length);
          for (var R = 0; R < d.length; R++)
            d.words[R] = 0;
        }
        var G = x.clone()._ishlnsubmul(A, 1, w);
        G.negative === 0 && (x = G, d && (d.words[w] = 1));
        for (var fe = w - 1; fe >= 0; fe--) {
          var z = (x.words[A.length + fe] | 0) * 67108864 + (x.words[A.length + fe - 1] | 0);
          for (z = Math.min(z / S | 0, 67108863), x._ishlnsubmul(A, z, fe); x.negative !== 0; )
            z--, x.negative = 0, x._ishlnsubmul(A, 1, fe), x.isZero() || (x.negative ^= 1);
          d && (d.words[fe] = z);
        }
        return d && d._strip(), x._strip(), l !== "div" && _ !== 0 && x.iushrn(_), {
          div: d || null,
          mod: x
        };
      }, r.prototype.divmod = function(a, l, _) {
        if (i(!a.isZero()), this.isZero())
          return {
            div: new r(0),
            mod: new r(0)
          };
        var x, A, S;
        return this.negative !== 0 && a.negative === 0 ? (S = this.neg().divmod(a, l), l !== "mod" && (x = S.div.neg()), l !== "div" && (A = S.mod.neg(), _ && A.negative !== 0 && A.iadd(a)), {
          div: x,
          mod: A
        }) : this.negative === 0 && a.negative !== 0 ? (S = this.divmod(a.neg(), l), l !== "mod" && (x = S.div.neg()), {
          div: x,
          mod: S.mod
        }) : this.negative & a.negative ? (S = this.neg().divmod(a.neg(), l), l !== "div" && (A = S.mod.neg(), _ && A.negative !== 0 && A.isub(a)), {
          div: S.div,
          mod: A
        }) : a.length > this.length || this.cmp(a) < 0 ? {
          div: new r(0),
          mod: this
        } : a.length === 1 ? l === "div" ? {
          div: this.divn(a.words[0]),
          mod: null
        } : l === "mod" ? {
          div: null,
          mod: new r(this.modrn(a.words[0]))
        } : {
          div: this.divn(a.words[0]),
          mod: new r(this.modrn(a.words[0]))
        } : this._wordDiv(a, l);
      }, r.prototype.div = function(a) {
        return this.divmod(a, "div", !1).div;
      }, r.prototype.mod = function(a) {
        return this.divmod(a, "mod", !1).mod;
      }, r.prototype.umod = function(a) {
        return this.divmod(a, "mod", !0).mod;
      }, r.prototype.divRound = function(a) {
        var l = this.divmod(a);
        if (l.mod.isZero())
          return l.div;
        var _ = l.div.negative !== 0 ? l.mod.isub(a) : l.mod, x = a.ushrn(1), A = a.andln(1), S = _.cmp(x);
        return S < 0 || A === 1 && S === 0 ? l.div : l.div.negative !== 0 ? l.div.isubn(1) : l.div.iaddn(1);
      }, r.prototype.modrn = function(a) {
        var l = a < 0;
        l && (a = -a), i(a <= 67108863);
        for (var _ = (1 << 26) % a, x = 0, A = this.length - 1; A >= 0; A--)
          x = (_ * x + (this.words[A] | 0)) % a;
        return l ? -x : x;
      }, r.prototype.modn = function(a) {
        return this.modrn(a);
      }, r.prototype.idivn = function(a) {
        var l = a < 0;
        l && (a = -a), i(a <= 67108863);
        for (var _ = 0, x = this.length - 1; x >= 0; x--) {
          var A = (this.words[x] | 0) + _ * 67108864;
          this.words[x] = A / a | 0, _ = A % a;
        }
        return this._strip(), l ? this.ineg() : this;
      }, r.prototype.divn = function(a) {
        return this.clone().idivn(a);
      }, r.prototype.egcd = function(a) {
        i(a.negative === 0), i(!a.isZero());
        var l = this, _ = a.clone();
        l.negative !== 0 ? l = l.umod(a) : l = l.clone();
        for (var x = new r(1), A = new r(0), S = new r(0), g = new r(1), w = 0; l.isEven() && _.isEven(); )
          l.iushrn(1), _.iushrn(1), ++w;
        for (var d = _.clone(), R = l.clone(); !l.isZero(); ) {
          for (var G = 0, fe = 1; !(l.words[0] & fe) && G < 26; ++G, fe <<= 1)
            ;
          if (G > 0)
            for (l.iushrn(G); G-- > 0; )
              (x.isOdd() || A.isOdd()) && (x.iadd(d), A.isub(R)), x.iushrn(1), A.iushrn(1);
          for (var z = 0, V = 1; !(_.words[0] & V) && z < 26; ++z, V <<= 1)
            ;
          if (z > 0)
            for (_.iushrn(z); z-- > 0; )
              (S.isOdd() || g.isOdd()) && (S.iadd(d), g.isub(R)), S.iushrn(1), g.iushrn(1);
          l.cmp(_) >= 0 ? (l.isub(_), x.isub(S), A.isub(g)) : (_.isub(l), S.isub(x), g.isub(A));
        }
        return {
          a: S,
          b: g,
          gcd: _.iushln(w)
        };
      }, r.prototype._invmp = function(a) {
        i(a.negative === 0), i(!a.isZero());
        var l = this, _ = a.clone();
        l.negative !== 0 ? l = l.umod(a) : l = l.clone();
        for (var x = new r(1), A = new r(0), S = _.clone(); l.cmpn(1) > 0 && _.cmpn(1) > 0; ) {
          for (var g = 0, w = 1; !(l.words[0] & w) && g < 26; ++g, w <<= 1)
            ;
          if (g > 0)
            for (l.iushrn(g); g-- > 0; )
              x.isOdd() && x.iadd(S), x.iushrn(1);
          for (var d = 0, R = 1; !(_.words[0] & R) && d < 26; ++d, R <<= 1)
            ;
          if (d > 0)
            for (_.iushrn(d); d-- > 0; )
              A.isOdd() && A.iadd(S), A.iushrn(1);
          l.cmp(_) >= 0 ? (l.isub(_), x.isub(A)) : (_.isub(l), A.isub(x));
        }
        var G;
        return l.cmpn(1) === 0 ? G = x : G = A, G.cmpn(0) < 0 && G.iadd(a), G;
      }, r.prototype.gcd = function(a) {
        if (this.isZero())
          return a.abs();
        if (a.isZero())
          return this.abs();
        var l = this.clone(), _ = a.clone();
        l.negative = 0, _.negative = 0;
        for (var x = 0; l.isEven() && _.isEven(); x++)
          l.iushrn(1), _.iushrn(1);
        do {
          for (; l.isEven(); )
            l.iushrn(1);
          for (; _.isEven(); )
            _.iushrn(1);
          var A = l.cmp(_);
          if (A < 0) {
            var S = l;
            l = _, _ = S;
          } else if (A === 0 || _.cmpn(1) === 0)
            break;
          l.isub(_);
        } while (!0);
        return _.iushln(x);
      }, r.prototype.invm = function(a) {
        return this.egcd(a).a.umod(a);
      }, r.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, r.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, r.prototype.andln = function(a) {
        return this.words[0] & a;
      }, r.prototype.bincn = function(a) {
        i(typeof a == "number");
        var l = a % 26, _ = (a - l) / 26, x = 1 << l;
        if (this.length <= _)
          return this._expand(_ + 1), this.words[_] |= x, this;
        for (var A = x, S = _; A !== 0 && S < this.length; S++) {
          var g = this.words[S] | 0;
          g += A, A = g >>> 26, g &= 67108863, this.words[S] = g;
        }
        return A !== 0 && (this.words[S] = A, this.length++), this;
      }, r.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, r.prototype.cmpn = function(a) {
        var l = a < 0;
        if (this.negative !== 0 && !l)
          return -1;
        if (this.negative === 0 && l)
          return 1;
        this._strip();
        var _;
        if (this.length > 1)
          _ = 1;
        else {
          l && (a = -a), i(a <= 67108863, "Number is too big");
          var x = this.words[0] | 0;
          _ = x === a ? 0 : x < a ? -1 : 1;
        }
        return this.negative !== 0 ? -_ | 0 : _;
      }, r.prototype.cmp = function(a) {
        if (this.negative !== 0 && a.negative === 0)
          return -1;
        if (this.negative === 0 && a.negative !== 0)
          return 1;
        var l = this.ucmp(a);
        return this.negative !== 0 ? -l | 0 : l;
      }, r.prototype.ucmp = function(a) {
        if (this.length > a.length)
          return 1;
        if (this.length < a.length)
          return -1;
        for (var l = 0, _ = this.length - 1; _ >= 0; _--) {
          var x = this.words[_] | 0, A = a.words[_] | 0;
          if (x !== A) {
            x < A ? l = -1 : x > A && (l = 1);
            break;
          }
        }
        return l;
      }, r.prototype.gtn = function(a) {
        return this.cmpn(a) === 1;
      }, r.prototype.gt = function(a) {
        return this.cmp(a) === 1;
      }, r.prototype.gten = function(a) {
        return this.cmpn(a) >= 0;
      }, r.prototype.gte = function(a) {
        return this.cmp(a) >= 0;
      }, r.prototype.ltn = function(a) {
        return this.cmpn(a) === -1;
      }, r.prototype.lt = function(a) {
        return this.cmp(a) === -1;
      }, r.prototype.lten = function(a) {
        return this.cmpn(a) <= 0;
      }, r.prototype.lte = function(a) {
        return this.cmp(a) <= 0;
      }, r.prototype.eqn = function(a) {
        return this.cmpn(a) === 0;
      }, r.prototype.eq = function(a) {
        return this.cmp(a) === 0;
      }, r.red = function(a) {
        return new U(a);
      }, r.prototype.toRed = function(a) {
        return i(!this.red, "Already a number in reduction context"), i(this.negative === 0, "red works only with positives"), a.convertTo(this)._forceRed(a);
      }, r.prototype.fromRed = function() {
        return i(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, r.prototype._forceRed = function(a) {
        return this.red = a, this;
      }, r.prototype.forceRed = function(a) {
        return i(!this.red, "Already a number in reduction context"), this._forceRed(a);
      }, r.prototype.redAdd = function(a) {
        return i(this.red, "redAdd works only with red numbers"), this.red.add(this, a);
      }, r.prototype.redIAdd = function(a) {
        return i(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, a);
      }, r.prototype.redSub = function(a) {
        return i(this.red, "redSub works only with red numbers"), this.red.sub(this, a);
      }, r.prototype.redISub = function(a) {
        return i(this.red, "redISub works only with red numbers"), this.red.isub(this, a);
      }, r.prototype.redShl = function(a) {
        return i(this.red, "redShl works only with red numbers"), this.red.shl(this, a);
      }, r.prototype.redMul = function(a) {
        return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.mul(this, a);
      }, r.prototype.redIMul = function(a) {
        return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.imul(this, a);
      }, r.prototype.redSqr = function() {
        return i(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, r.prototype.redISqr = function() {
        return i(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, r.prototype.redSqrt = function() {
        return i(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, r.prototype.redInvm = function() {
        return i(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, r.prototype.redNeg = function() {
        return i(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, r.prototype.redPow = function(a) {
        return i(this.red && !a.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, a);
      };
      var N = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function q(p, a) {
        this.name = p, this.p = new r(a, 16), this.n = this.p.bitLength(), this.k = new r(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      q.prototype._tmp = function() {
        var a = new r(null);
        return a.words = new Array(Math.ceil(this.n / 13)), a;
      }, q.prototype.ireduce = function(a) {
        var l = a, _;
        do
          this.split(l, this.tmp), l = this.imulK(l), l = l.iadd(this.tmp), _ = l.bitLength();
        while (_ > this.n);
        var x = _ < this.n ? -1 : l.ucmp(this.p);
        return x === 0 ? (l.words[0] = 0, l.length = 1) : x > 0 ? l.isub(this.p) : l.strip !== void 0 ? l.strip() : l._strip(), l;
      }, q.prototype.split = function(a, l) {
        a.iushrn(this.n, 0, l);
      }, q.prototype.imulK = function(a) {
        return a.imul(this.k);
      };
      function D() {
        q.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      s(D, q), D.prototype.split = function(a, l) {
        for (var _ = 4194303, x = Math.min(a.length, 9), A = 0; A < x; A++)
          l.words[A] = a.words[A];
        if (l.length = x, a.length <= 9) {
          a.words[0] = 0, a.length = 1;
          return;
        }
        var S = a.words[9];
        for (l.words[l.length++] = S & _, A = 10; A < a.length; A++) {
          var g = a.words[A] | 0;
          a.words[A - 10] = (g & _) << 4 | S >>> 22, S = g;
        }
        S >>>= 22, a.words[A - 10] = S, S === 0 && a.length > 10 ? a.length -= 10 : a.length -= 9;
      }, D.prototype.imulK = function(a) {
        a.words[a.length] = 0, a.words[a.length + 1] = 0, a.length += 2;
        for (var l = 0, _ = 0; _ < a.length; _++) {
          var x = a.words[_] | 0;
          l += x * 977, a.words[_] = l & 67108863, l = x * 64 + (l / 67108864 | 0);
        }
        return a.words[a.length - 1] === 0 && (a.length--, a.words[a.length - 1] === 0 && a.length--), a;
      };
      function re() {
        q.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      s(re, q);
      function te() {
        q.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      s(te, q);
      function oe() {
        q.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      s(oe, q), oe.prototype.imulK = function(a) {
        for (var l = 0, _ = 0; _ < a.length; _++) {
          var x = (a.words[_] | 0) * 19 + l, A = x & 67108863;
          x >>>= 26, a.words[_] = A, l = x;
        }
        return l !== 0 && (a.words[a.length++] = l), a;
      }, r._prime = function(a) {
        if (N[a])
          return N[a];
        var l;
        if (a === "k256")
          l = new D();
        else if (a === "p224")
          l = new re();
        else if (a === "p192")
          l = new te();
        else if (a === "p25519")
          l = new oe();
        else
          throw new Error("Unknown prime " + a);
        return N[a] = l, l;
      };
      function U(p) {
        if (typeof p == "string") {
          var a = r._prime(p);
          this.m = a.p, this.prime = a;
        } else
          i(p.gtn(1), "modulus must be greater than 1"), this.m = p, this.prime = null;
      }
      U.prototype._verify1 = function(a) {
        i(a.negative === 0, "red works only with positives"), i(a.red, "red works only with red numbers");
      }, U.prototype._verify2 = function(a, l) {
        i((a.negative | l.negative) === 0, "red works only with positives"), i(
          a.red && a.red === l.red,
          "red works only with red numbers"
        );
      }, U.prototype.imod = function(a) {
        return this.prime ? this.prime.ireduce(a)._forceRed(this) : (f(a, a.umod(this.m)._forceRed(this)), a);
      }, U.prototype.neg = function(a) {
        return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this);
      }, U.prototype.add = function(a, l) {
        this._verify2(a, l);
        var _ = a.add(l);
        return _.cmp(this.m) >= 0 && _.isub(this.m), _._forceRed(this);
      }, U.prototype.iadd = function(a, l) {
        this._verify2(a, l);
        var _ = a.iadd(l);
        return _.cmp(this.m) >= 0 && _.isub(this.m), _;
      }, U.prototype.sub = function(a, l) {
        this._verify2(a, l);
        var _ = a.sub(l);
        return _.cmpn(0) < 0 && _.iadd(this.m), _._forceRed(this);
      }, U.prototype.isub = function(a, l) {
        this._verify2(a, l);
        var _ = a.isub(l);
        return _.cmpn(0) < 0 && _.iadd(this.m), _;
      }, U.prototype.shl = function(a, l) {
        return this._verify1(a), this.imod(a.ushln(l));
      }, U.prototype.imul = function(a, l) {
        return this._verify2(a, l), this.imod(a.imul(l));
      }, U.prototype.mul = function(a, l) {
        return this._verify2(a, l), this.imod(a.mul(l));
      }, U.prototype.isqr = function(a) {
        return this.imul(a, a.clone());
      }, U.prototype.sqr = function(a) {
        return this.mul(a, a);
      }, U.prototype.sqrt = function(a) {
        if (a.isZero())
          return a.clone();
        var l = this.m.andln(3);
        if (i(l % 2 === 1), l === 3) {
          var _ = this.m.add(new r(1)).iushrn(2);
          return this.pow(a, _);
        }
        for (var x = this.m.subn(1), A = 0; !x.isZero() && x.andln(1) === 0; )
          A++, x.iushrn(1);
        i(!x.isZero());
        var S = new r(1).toRed(this), g = S.redNeg(), w = this.m.subn(1).iushrn(1), d = this.m.bitLength();
        for (d = new r(2 * d * d).toRed(this); this.pow(d, w).cmp(g) !== 0; )
          d.redIAdd(g);
        for (var R = this.pow(d, x), G = this.pow(a, x.addn(1).iushrn(1)), fe = this.pow(a, x), z = A; fe.cmp(S) !== 0; ) {
          for (var V = fe, F = 0; V.cmp(S) !== 0; F++)
            V = V.redSqr();
          i(F < z);
          var ee = this.pow(R, new r(1).iushln(z - F - 1));
          G = G.redMul(ee), R = ee.redSqr(), fe = fe.redMul(R), z = F;
        }
        return G;
      }, U.prototype.invm = function(a) {
        var l = a._invmp(this.m);
        return l.negative !== 0 ? (l.negative = 0, this.imod(l).redNeg()) : this.imod(l);
      }, U.prototype.pow = function(a, l) {
        if (l.isZero())
          return new r(1).toRed(this);
        if (l.cmpn(1) === 0)
          return a.clone();
        var _ = 4, x = new Array(1 << _);
        x[0] = new r(1).toRed(this), x[1] = a;
        for (var A = 2; A < x.length; A++)
          x[A] = this.mul(x[A - 1], a);
        var S = x[0], g = 0, w = 0, d = l.bitLength() % 26;
        for (d === 0 && (d = 26), A = l.length - 1; A >= 0; A--) {
          for (var R = l.words[A], G = d - 1; G >= 0; G--) {
            var fe = R >> G & 1;
            if (S !== x[0] && (S = this.sqr(S)), fe === 0 && g === 0) {
              w = 0;
              continue;
            }
            g <<= 1, g |= fe, w++, !(w !== _ && (A !== 0 || G !== 0)) && (S = this.mul(S, x[g]), w = 0, g = 0);
          }
          d = 26;
        }
        return S;
      }, U.prototype.convertTo = function(a) {
        var l = a.umod(this.m);
        return l === a ? l.clone() : l;
      }, U.prototype.convertFrom = function(a) {
        var l = a.clone();
        return l.red = null, l;
      }, r.mont = function(a) {
        return new y(a);
      };
      function y(p) {
        U.call(this, p), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new r(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      s(y, U), y.prototype.convertTo = function(a) {
        return this.imod(a.ushln(this.shift));
      }, y.prototype.convertFrom = function(a) {
        var l = this.imod(a.mul(this.rinv));
        return l.red = null, l;
      }, y.prototype.imul = function(a, l) {
        if (a.isZero() || l.isZero())
          return a.words[0] = 0, a.length = 1, a;
        var _ = a.imul(l), x = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = _.isub(x).iushrn(this.shift), S = A;
        return A.cmp(this.m) >= 0 ? S = A.isub(this.m) : A.cmpn(0) < 0 && (S = A.iadd(this.m)), S._forceRed(this);
      }, y.prototype.mul = function(a, l) {
        if (a.isZero() || l.isZero())
          return new r(0)._forceRed(this);
        var _ = a.mul(l), x = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = _.isub(x).iushrn(this.shift), S = A;
        return A.cmp(this.m) >= 0 ? S = A.isub(this.m) : A.cmpn(0) < 0 && (S = A.iadd(this.m)), S._forceRed(this);
      }, y.prototype.invm = function(a) {
        var l = this.imod(a._invmp(this.m).mul(this.r2));
        return l._forceRed(this);
      };
    })(e, Ze);
  }(va)), va.exports;
}
var _r = {}, Tu = {}, Ou = {}, Pu = {}, Cu, V1;
function x0() {
  if (V1)
    return Cu;
  V1 = 1;
  var e = dr, t = e.Buffer, n = {}, i;
  for (i in e)
    e.hasOwnProperty(i) && (i === "SlowBuffer" || i === "Buffer" || (n[i] = e[i]));
  var s = n.Buffer = {};
  for (i in t)
    t.hasOwnProperty(i) && (i === "allocUnsafe" || i === "allocUnsafeSlow" || (s[i] = t[i]));
  if (n.Buffer.prototype = t.prototype, (!s.from || s.from === Uint8Array.from) && (s.from = function(r, o, u) {
    if (typeof r == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof r);
    if (r && typeof r.length > "u")
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r);
    return t(r, o, u);
  }), s.alloc || (s.alloc = function(r, o, u) {
    if (typeof r != "number")
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof r);
    if (r < 0 || r >= 2 * (1 << 30))
      throw new RangeError('The value "' + r + '" is invalid for option "size"');
    var c = t(r);
    return !o || o.length === 0 ? c.fill(0) : typeof u == "string" ? c.fill(o, u) : c.fill(o), c;
  }), !n.kStringMaxLength)
    try {
      n.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch {
    }
  return n.constants || (n.constants = {
    MAX_LENGTH: n.kMaxLength
  }, n.kStringMaxLength && (n.constants.MAX_STRING_LENGTH = n.kStringMaxLength)), Cu = n, Cu;
}
var Nu = {}, K1;
function E0() {
  if (K1)
    return Nu;
  K1 = 1;
  const e = mt();
  function t(i) {
    this._reporterState = {
      obj: null,
      path: [],
      options: i || {},
      errors: []
    };
  }
  Nu.Reporter = t, t.prototype.isError = function(s) {
    return s instanceof n;
  }, t.prototype.save = function() {
    const s = this._reporterState;
    return { obj: s.obj, pathLen: s.path.length };
  }, t.prototype.restore = function(s) {
    const r = this._reporterState;
    r.obj = s.obj, r.path = r.path.slice(0, s.pathLen);
  }, t.prototype.enterKey = function(s) {
    return this._reporterState.path.push(s);
  }, t.prototype.exitKey = function(s) {
    const r = this._reporterState;
    r.path = r.path.slice(0, s - 1);
  }, t.prototype.leaveKey = function(s, r, o) {
    const u = this._reporterState;
    this.exitKey(s), u.obj !== null && (u.obj[r] = o);
  }, t.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, t.prototype.enterObject = function() {
    const s = this._reporterState, r = s.obj;
    return s.obj = {}, r;
  }, t.prototype.leaveObject = function(s) {
    const r = this._reporterState, o = r.obj;
    return r.obj = s, o;
  }, t.prototype.error = function(s) {
    let r;
    const o = this._reporterState, u = s instanceof n;
    if (u ? r = s : r = new n(o.path.map(function(c) {
      return "[" + JSON.stringify(c) + "]";
    }).join(""), s.message || s, s.stack), !o.options.partial)
      throw r;
    return u || o.errors.push(r), r;
  }, t.prototype.wrapResult = function(s) {
    const r = this._reporterState;
    return r.options.partial ? {
      result: this.isError(s) ? null : s,
      errors: r.errors
    } : s;
  };
  function n(i, s) {
    this.path = i, this.rethrow(s);
  }
  return e(n, Error), n.prototype.rethrow = function(s) {
    if (this.message = s + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, n), !this.stack)
      try {
        throw new Error(this.message);
      } catch (r) {
        this.stack = r.stack;
      }
    return this;
  }, Nu;
}
var la = {}, Z1;
function Ii() {
  if (Z1)
    return la;
  Z1 = 1;
  const e = mt(), t = E0().Reporter, n = x0().Buffer;
  function i(r, o) {
    if (t.call(this, o), !n.isBuffer(r)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = r, this.offset = 0, this.length = r.length;
  }
  e(i, t), la.DecoderBuffer = i, i.isDecoderBuffer = function(o) {
    return o instanceof i ? !0 : typeof o == "object" && n.isBuffer(o.base) && o.constructor.name === "DecoderBuffer" && typeof o.offset == "number" && typeof o.length == "number" && typeof o.save == "function" && typeof o.restore == "function" && typeof o.isEmpty == "function" && typeof o.readUInt8 == "function" && typeof o.skip == "function" && typeof o.raw == "function";
  }, i.prototype.save = function() {
    return { offset: this.offset, reporter: t.prototype.save.call(this) };
  }, i.prototype.restore = function(o) {
    const u = new i(this.base);
    return u.offset = o.offset, u.length = this.offset, this.offset = o.offset, t.prototype.restore.call(this, o.reporter), u;
  }, i.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, i.prototype.readUInt8 = function(o) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(o || "DecoderBuffer overrun");
  }, i.prototype.skip = function(o, u) {
    if (!(this.offset + o <= this.length))
      return this.error(u || "DecoderBuffer overrun");
    const c = new i(this.base);
    return c._reporterState = this._reporterState, c.offset = this.offset, c.length = this.offset + o, this.offset += o, c;
  }, i.prototype.raw = function(o) {
    return this.base.slice(o ? o.offset : this.offset, this.length);
  };
  function s(r, o) {
    if (Array.isArray(r))
      this.length = 0, this.value = r.map(function(u) {
        return s.isEncoderBuffer(u) || (u = new s(u, o)), this.length += u.length, u;
      }, this);
    else if (typeof r == "number") {
      if (!(0 <= r && r <= 255))
        return o.error("non-byte EncoderBuffer value");
      this.value = r, this.length = 1;
    } else if (typeof r == "string")
      this.value = r, this.length = n.byteLength(r);
    else if (n.isBuffer(r))
      this.value = r, this.length = r.length;
    else
      return o.error("Unsupported type: " + typeof r);
  }
  return la.EncoderBuffer = s, s.isEncoderBuffer = function(o) {
    return o instanceof s ? !0 : typeof o == "object" && o.constructor.name === "EncoderBuffer" && typeof o.length == "number" && typeof o.join == "function";
  }, s.prototype.join = function(o, u) {
    return o || (o = n.alloc(this.length)), u || (u = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(c) {
      c.join(o, u), u += c.length;
    }) : (typeof this.value == "number" ? o[u] = this.value : typeof this.value == "string" ? o.write(this.value, u) : n.isBuffer(this.value) && this.value.copy(o, u), u += this.length)), o;
  }, la;
}
var Lu, G1;
function S0() {
  if (G1)
    return Lu;
  G1 = 1;
  const e = E0().Reporter, t = Ii().EncoderBuffer, n = Ii().DecoderBuffer, i = Tr(), s = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], r = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(s), o = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function u(h, f, b) {
    const v = {};
    this._baseState = v, v.name = b, v.enc = h, v.parent = f || null, v.children = null, v.tag = null, v.args = null, v.reverseArgs = null, v.choice = null, v.optional = !1, v.any = !1, v.obj = !1, v.use = null, v.useDecoder = null, v.key = null, v.default = null, v.explicit = null, v.implicit = null, v.contains = null, v.parent || (v.children = [], this._wrap());
  }
  Lu = u;
  const c = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return u.prototype.clone = function() {
    const f = this._baseState, b = {};
    c.forEach(function(m) {
      b[m] = f[m];
    });
    const v = new this.constructor(b.parent);
    return v._baseState = b, v;
  }, u.prototype._wrap = function() {
    const f = this._baseState;
    r.forEach(function(b) {
      this[b] = function() {
        const m = new this.constructor(this);
        return f.children.push(m), m[b].apply(m, arguments);
      };
    }, this);
  }, u.prototype._init = function(f) {
    const b = this._baseState;
    i(b.parent === null), f.call(this), b.children = b.children.filter(function(v) {
      return v._baseState.parent === this;
    }, this), i.equal(b.children.length, 1, "Root node can have only one child");
  }, u.prototype._useArgs = function(f) {
    const b = this._baseState, v = f.filter(function(m) {
      return m instanceof this.constructor;
    }, this);
    f = f.filter(function(m) {
      return !(m instanceof this.constructor);
    }, this), v.length !== 0 && (i(b.children === null), b.children = v, v.forEach(function(m) {
      m._baseState.parent = this;
    }, this)), f.length !== 0 && (i(b.args === null), b.args = f, b.reverseArgs = f.map(function(m) {
      if (typeof m != "object" || m.constructor !== Object)
        return m;
      const E = {};
      return Object.keys(m).forEach(function(M) {
        M == (M | 0) && (M |= 0);
        const B = m[M];
        E[B] = M;
      }), E;
    }));
  }, o.forEach(function(h) {
    u.prototype[h] = function() {
      const b = this._baseState;
      throw new Error(h + " not implemented for encoding: " + b.enc);
    };
  }), s.forEach(function(h) {
    u.prototype[h] = function() {
      const b = this._baseState, v = Array.prototype.slice.call(arguments);
      return i(b.tag === null), b.tag = h, this._useArgs(v), this;
    };
  }), u.prototype.use = function(f) {
    i(f);
    const b = this._baseState;
    return i(b.use === null), b.use = f, this;
  }, u.prototype.optional = function() {
    const f = this._baseState;
    return f.optional = !0, this;
  }, u.prototype.def = function(f) {
    const b = this._baseState;
    return i(b.default === null), b.default = f, b.optional = !0, this;
  }, u.prototype.explicit = function(f) {
    const b = this._baseState;
    return i(b.explicit === null && b.implicit === null), b.explicit = f, this;
  }, u.prototype.implicit = function(f) {
    const b = this._baseState;
    return i(b.explicit === null && b.implicit === null), b.implicit = f, this;
  }, u.prototype.obj = function() {
    const f = this._baseState, b = Array.prototype.slice.call(arguments);
    return f.obj = !0, b.length !== 0 && this._useArgs(b), this;
  }, u.prototype.key = function(f) {
    const b = this._baseState;
    return i(b.key === null), b.key = f, this;
  }, u.prototype.any = function() {
    const f = this._baseState;
    return f.any = !0, this;
  }, u.prototype.choice = function(f) {
    const b = this._baseState;
    return i(b.choice === null), b.choice = f, this._useArgs(Object.keys(f).map(function(v) {
      return f[v];
    })), this;
  }, u.prototype.contains = function(f) {
    const b = this._baseState;
    return i(b.use === null), b.contains = f, this;
  }, u.prototype._decode = function(f, b) {
    const v = this._baseState;
    if (v.parent === null)
      return f.wrapResult(v.children[0]._decode(f, b));
    let m = v.default, E = !0, M = null;
    if (v.key !== null && (M = f.enterKey(v.key)), v.optional) {
      let I = null;
      if (v.explicit !== null ? I = v.explicit : v.implicit !== null ? I = v.implicit : v.tag !== null && (I = v.tag), I === null && !v.any) {
        const T = f.save();
        try {
          v.choice === null ? this._decodeGeneric(v.tag, f, b) : this._decodeChoice(f, b), E = !0;
        } catch {
          E = !1;
        }
        f.restore(T);
      } else if (E = this._peekTag(f, I, v.any), f.isError(E))
        return E;
    }
    let B;
    if (v.obj && E && (B = f.enterObject()), E) {
      if (v.explicit !== null) {
        const T = this._decodeTag(f, v.explicit);
        if (f.isError(T))
          return T;
        f = T;
      }
      const I = f.offset;
      if (v.use === null && v.choice === null) {
        let T;
        v.any && (T = f.save());
        const k = this._decodeTag(
          f,
          v.implicit !== null ? v.implicit : v.tag,
          v.any
        );
        if (f.isError(k))
          return k;
        v.any ? m = f.raw(T) : f = k;
      }
      if (b && b.track && v.tag !== null && b.track(f.path(), I, f.length, "tagged"), b && b.track && v.tag !== null && b.track(f.path(), f.offset, f.length, "content"), v.any || (v.choice === null ? m = this._decodeGeneric(v.tag, f, b) : m = this._decodeChoice(f, b)), f.isError(m))
        return m;
      if (!v.any && v.choice === null && v.children !== null && v.children.forEach(function(k) {
        k._decode(f, b);
      }), v.contains && (v.tag === "octstr" || v.tag === "bitstr")) {
        const T = new n(m);
        m = this._getUse(v.contains, f._reporterState.obj)._decode(T, b);
      }
    }
    return v.obj && E && (m = f.leaveObject(B)), v.key !== null && (m !== null || E === !0) ? f.leaveKey(M, v.key, m) : M !== null && f.exitKey(M), m;
  }, u.prototype._decodeGeneric = function(f, b, v) {
    const m = this._baseState;
    return f === "seq" || f === "set" ? null : f === "seqof" || f === "setof" ? this._decodeList(b, f, m.args[0], v) : /str$/.test(f) ? this._decodeStr(b, f, v) : f === "objid" && m.args ? this._decodeObjid(b, m.args[0], m.args[1], v) : f === "objid" ? this._decodeObjid(b, null, null, v) : f === "gentime" || f === "utctime" ? this._decodeTime(b, f, v) : f === "null_" ? this._decodeNull(b, v) : f === "bool" ? this._decodeBool(b, v) : f === "objDesc" ? this._decodeStr(b, f, v) : f === "int" || f === "enum" ? this._decodeInt(b, m.args && m.args[0], v) : m.use !== null ? this._getUse(m.use, b._reporterState.obj)._decode(b, v) : b.error("unknown tag: " + f);
  }, u.prototype._getUse = function(f, b) {
    const v = this._baseState;
    return v.useDecoder = this._use(f, b), i(v.useDecoder._baseState.parent === null), v.useDecoder = v.useDecoder._baseState.children[0], v.implicit !== v.useDecoder._baseState.implicit && (v.useDecoder = v.useDecoder.clone(), v.useDecoder._baseState.implicit = v.implicit), v.useDecoder;
  }, u.prototype._decodeChoice = function(f, b) {
    const v = this._baseState;
    let m = null, E = !1;
    return Object.keys(v.choice).some(function(M) {
      const B = f.save(), I = v.choice[M];
      try {
        const T = I._decode(f, b);
        if (f.isError(T))
          return !1;
        m = { type: M, value: T }, E = !0;
      } catch {
        return f.restore(B), !1;
      }
      return !0;
    }, this), E ? m : f.error("Choice not matched");
  }, u.prototype._createEncoderBuffer = function(f) {
    return new t(f, this.reporter);
  }, u.prototype._encode = function(f, b, v) {
    const m = this._baseState;
    if (m.default !== null && m.default === f)
      return;
    const E = this._encodeValue(f, b, v);
    if (E !== void 0 && !this._skipDefault(E, b, v))
      return E;
  }, u.prototype._encodeValue = function(f, b, v) {
    const m = this._baseState;
    if (m.parent === null)
      return m.children[0]._encode(f, b || new e());
    let E = null;
    if (this.reporter = b, m.optional && f === void 0)
      if (m.default !== null)
        f = m.default;
      else
        return;
    let M = null, B = !1;
    if (m.any)
      E = this._createEncoderBuffer(f);
    else if (m.choice)
      E = this._encodeChoice(f, b);
    else if (m.contains)
      M = this._getUse(m.contains, v)._encode(f, b), B = !0;
    else if (m.children)
      M = m.children.map(function(I) {
        if (I._baseState.tag === "null_")
          return I._encode(null, b, f);
        if (I._baseState.key === null)
          return b.error("Child should have a key");
        const T = b.enterKey(I._baseState.key);
        if (typeof f != "object")
          return b.error("Child expected, but input is not object");
        const k = I._encode(f[I._baseState.key], b, f);
        return b.leaveKey(T), k;
      }, this).filter(function(I) {
        return I;
      }), M = this._createEncoderBuffer(M);
    else if (m.tag === "seqof" || m.tag === "setof") {
      if (!(m.args && m.args.length === 1))
        return b.error("Too many args for : " + m.tag);
      if (!Array.isArray(f))
        return b.error("seqof/setof, but data is not Array");
      const I = this.clone();
      I._baseState.implicit = null, M = this._createEncoderBuffer(f.map(function(T) {
        const k = this._baseState;
        return this._getUse(k.args[0], f)._encode(T, b);
      }, I));
    } else
      m.use !== null ? E = this._getUse(m.use, v)._encode(f, b) : (M = this._encodePrimitive(m.tag, f), B = !0);
    if (!m.any && m.choice === null) {
      const I = m.implicit !== null ? m.implicit : m.tag, T = m.implicit === null ? "universal" : "context";
      I === null ? m.use === null && b.error("Tag could be omitted only for .use()") : m.use === null && (E = this._encodeComposite(I, B, T, M));
    }
    return m.explicit !== null && (E = this._encodeComposite(m.explicit, !1, "context", E)), E;
  }, u.prototype._encodeChoice = function(f, b) {
    const v = this._baseState, m = v.choice[f.type];
    return m || i(
      !1,
      f.type + " not found in " + JSON.stringify(Object.keys(v.choice))
    ), m._encode(f.value, b);
  }, u.prototype._encodePrimitive = function(f, b) {
    const v = this._baseState;
    if (/str$/.test(f))
      return this._encodeStr(b, f);
    if (f === "objid" && v.args)
      return this._encodeObjid(b, v.reverseArgs[0], v.args[1]);
    if (f === "objid")
      return this._encodeObjid(b, null, null);
    if (f === "gentime" || f === "utctime")
      return this._encodeTime(b, f);
    if (f === "null_")
      return this._encodeNull();
    if (f === "int" || f === "enum")
      return this._encodeInt(b, v.args && v.reverseArgs[0]);
    if (f === "bool")
      return this._encodeBool(b);
    if (f === "objDesc")
      return this._encodeStr(b, f);
    throw new Error("Unsupported tag: " + f);
  }, u.prototype._isNumstr = function(f) {
    return /^[0-9 ]*$/.test(f);
  }, u.prototype._isPrintstr = function(f) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(f);
  }, Lu;
}
var ku = {}, W1;
function A0() {
  return W1 || (W1 = 1, function(e) {
    function t(n) {
      const i = {};
      return Object.keys(n).forEach(function(s) {
        (s | 0) == s && (s = s | 0);
        const r = n[s];
        i[r] = s;
      }), i;
    }
    e.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, e.tagClassByName = t(e.tagClass), e.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, e.tagByName = t(e.tag);
  }(ku)), ku;
}
var ju, J1;
function by() {
  if (J1)
    return ju;
  J1 = 1;
  const e = mt(), t = x0().Buffer, n = S0(), i = A0();
  function s(c) {
    this.enc = "der", this.name = c.name, this.entity = c, this.tree = new r(), this.tree._init(c.body);
  }
  ju = s, s.prototype.encode = function(h, f) {
    return this.tree._encode(h, f).join();
  };
  function r(c) {
    n.call(this, "der", c);
  }
  e(r, n), r.prototype._encodeComposite = function(h, f, b, v) {
    const m = u(h, f, b, this.reporter);
    if (v.length < 128) {
      const B = t.alloc(2);
      return B[0] = m, B[1] = v.length, this._createEncoderBuffer([B, v]);
    }
    let E = 1;
    for (let B = v.length; B >= 256; B >>= 8)
      E++;
    const M = t.alloc(1 + 1 + E);
    M[0] = m, M[1] = 128 | E;
    for (let B = 1 + E, I = v.length; I > 0; B--, I >>= 8)
      M[B] = I & 255;
    return this._createEncoderBuffer([M, v]);
  }, r.prototype._encodeStr = function(h, f) {
    if (f === "bitstr")
      return this._createEncoderBuffer([h.unused | 0, h.data]);
    if (f === "bmpstr") {
      const b = t.alloc(h.length * 2);
      for (let v = 0; v < h.length; v++)
        b.writeUInt16BE(h.charCodeAt(v), v * 2);
      return this._createEncoderBuffer(b);
    } else
      return f === "numstr" ? this._isNumstr(h) ? this._createEncoderBuffer(h) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : f === "printstr" ? this._isPrintstr(h) ? this._createEncoderBuffer(h) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(f) ? this._createEncoderBuffer(h) : f === "objDesc" ? this._createEncoderBuffer(h) : this.reporter.error("Encoding of string type: " + f + " unsupported");
  }, r.prototype._encodeObjid = function(h, f, b) {
    if (typeof h == "string") {
      if (!f)
        return this.reporter.error("string objid given, but no values map found");
      if (!f.hasOwnProperty(h))
        return this.reporter.error("objid not found in values map");
      h = f[h].split(/[\s.]+/g);
      for (let M = 0; M < h.length; M++)
        h[M] |= 0;
    } else if (Array.isArray(h)) {
      h = h.slice();
      for (let M = 0; M < h.length; M++)
        h[M] |= 0;
    }
    if (!Array.isArray(h))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(h));
    if (!b) {
      if (h[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      h.splice(0, 2, h[0] * 40 + h[1]);
    }
    let v = 0;
    for (let M = 0; M < h.length; M++) {
      let B = h[M];
      for (v++; B >= 128; B >>= 7)
        v++;
    }
    const m = t.alloc(v);
    let E = m.length - 1;
    for (let M = h.length - 1; M >= 0; M--) {
      let B = h[M];
      for (m[E--] = B & 127; (B >>= 7) > 0; )
        m[E--] = 128 | B & 127;
    }
    return this._createEncoderBuffer(m);
  };
  function o(c) {
    return c < 10 ? "0" + c : c;
  }
  r.prototype._encodeTime = function(h, f) {
    let b;
    const v = new Date(h);
    return f === "gentime" ? b = [
      o(v.getUTCFullYear()),
      o(v.getUTCMonth() + 1),
      o(v.getUTCDate()),
      o(v.getUTCHours()),
      o(v.getUTCMinutes()),
      o(v.getUTCSeconds()),
      "Z"
    ].join("") : f === "utctime" ? b = [
      o(v.getUTCFullYear() % 100),
      o(v.getUTCMonth() + 1),
      o(v.getUTCDate()),
      o(v.getUTCHours()),
      o(v.getUTCMinutes()),
      o(v.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + f + " time is not supported yet"), this._encodeStr(b, "octstr");
  }, r.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, r.prototype._encodeInt = function(h, f) {
    if (typeof h == "string") {
      if (!f)
        return this.reporter.error("String int or enum given, but no values map");
      if (!f.hasOwnProperty(h))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(h));
      h = f[h];
    }
    if (typeof h != "number" && !t.isBuffer(h)) {
      const m = h.toArray();
      !h.sign && m[0] & 128 && m.unshift(0), h = t.from(m);
    }
    if (t.isBuffer(h)) {
      let m = h.length;
      h.length === 0 && m++;
      const E = t.alloc(m);
      return h.copy(E), h.length === 0 && (E[0] = 0), this._createEncoderBuffer(E);
    }
    if (h < 128)
      return this._createEncoderBuffer(h);
    if (h < 256)
      return this._createEncoderBuffer([0, h]);
    let b = 1;
    for (let m = h; m >= 256; m >>= 8)
      b++;
    const v = new Array(b);
    for (let m = v.length - 1; m >= 0; m--)
      v[m] = h & 255, h >>= 8;
    return v[0] & 128 && v.unshift(0), this._createEncoderBuffer(t.from(v));
  }, r.prototype._encodeBool = function(h) {
    return this._createEncoderBuffer(h ? 255 : 0);
  }, r.prototype._use = function(h, f) {
    return typeof h == "function" && (h = h(f)), h._getEncoder("der").tree;
  }, r.prototype._skipDefault = function(h, f, b) {
    const v = this._baseState;
    let m;
    if (v.default === null)
      return !1;
    const E = h.join();
    if (v.defaultBuffer === void 0 && (v.defaultBuffer = this._encodeValue(v.default, f, b).join()), E.length !== v.defaultBuffer.length)
      return !1;
    for (m = 0; m < E.length; m++)
      if (E[m] !== v.defaultBuffer[m])
        return !1;
    return !0;
  };
  function u(c, h, f, b) {
    let v;
    if (c === "seqof" ? c = "seq" : c === "setof" && (c = "set"), i.tagByName.hasOwnProperty(c))
      v = i.tagByName[c];
    else if (typeof c == "number" && (c | 0) === c)
      v = c;
    else
      return b.error("Unknown tag: " + c);
    return v >= 31 ? b.error("Multi-octet tag encoding unsupported") : (h || (v |= 32), v |= i.tagClassByName[f || "universal"] << 6, v);
  }
  return ju;
}
var qu, X1;
function Sx() {
  if (X1)
    return qu;
  X1 = 1;
  const e = mt(), t = by();
  function n(i) {
    t.call(this, i), this.enc = "pem";
  }
  return e(n, t), qu = n, n.prototype.encode = function(s, r) {
    const u = t.prototype.encode.call(this, s).toString("base64"), c = ["-----BEGIN " + r.label + "-----"];
    for (let h = 0; h < u.length; h += 64)
      c.push(u.slice(h, h + 64));
    return c.push("-----END " + r.label + "-----"), c.join(`
`);
  }, qu;
}
var Y1;
function yy() {
  return Y1 || (Y1 = 1, function(e) {
    const t = e;
    t.der = by(), t.pem = Sx();
  }(Pu)), Pu;
}
var Du = {}, $u, Q1;
function gy() {
  if (Q1)
    return $u;
  Q1 = 1;
  const e = mt(), t = Wt, n = Ii().DecoderBuffer, i = S0(), s = A0();
  function r(h) {
    this.enc = "der", this.name = h.name, this.entity = h, this.tree = new o(), this.tree._init(h.body);
  }
  $u = r, r.prototype.decode = function(f, b) {
    return n.isDecoderBuffer(f) || (f = new n(f, b)), this.tree._decode(f, b);
  };
  function o(h) {
    i.call(this, "der", h);
  }
  e(o, i), o.prototype._peekTag = function(f, b, v) {
    if (f.isEmpty())
      return !1;
    const m = f.save(), E = u(f, 'Failed to peek tag: "' + b + '"');
    return f.isError(E) ? E : (f.restore(m), E.tag === b || E.tagStr === b || E.tagStr + "of" === b || v);
  }, o.prototype._decodeTag = function(f, b, v) {
    const m = u(
      f,
      'Failed to decode tag of "' + b + '"'
    );
    if (f.isError(m))
      return m;
    let E = c(
      f,
      m.primitive,
      'Failed to get length of "' + b + '"'
    );
    if (f.isError(E))
      return E;
    if (!v && m.tag !== b && m.tagStr !== b && m.tagStr + "of" !== b)
      return f.error('Failed to match tag: "' + b + '"');
    if (m.primitive || E !== null)
      return f.skip(E, 'Failed to match body of: "' + b + '"');
    const M = f.save(), B = this._skipUntilEnd(
      f,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return f.isError(B) ? B : (E = f.offset - M.offset, f.restore(M), f.skip(E, 'Failed to match body of: "' + b + '"'));
  }, o.prototype._skipUntilEnd = function(f, b) {
    for (; ; ) {
      const v = u(f, b);
      if (f.isError(v))
        return v;
      const m = c(f, v.primitive, b);
      if (f.isError(m))
        return m;
      let E;
      if (v.primitive || m !== null ? E = f.skip(m) : E = this._skipUntilEnd(f, b), f.isError(E))
        return E;
      if (v.tagStr === "end")
        break;
    }
  }, o.prototype._decodeList = function(f, b, v, m) {
    const E = [];
    for (; !f.isEmpty(); ) {
      const M = this._peekTag(f, "end");
      if (f.isError(M))
        return M;
      const B = v.decode(f, "der", m);
      if (f.isError(B) && M)
        break;
      E.push(B);
    }
    return E;
  }, o.prototype._decodeStr = function(f, b) {
    if (b === "bitstr") {
      const v = f.readUInt8();
      return f.isError(v) ? v : { unused: v, data: f.raw() };
    } else if (b === "bmpstr") {
      const v = f.raw();
      if (v.length % 2 === 1)
        return f.error("Decoding of string type: bmpstr length mismatch");
      let m = "";
      for (let E = 0; E < v.length / 2; E++)
        m += String.fromCharCode(v.readUInt16BE(E * 2));
      return m;
    } else if (b === "numstr") {
      const v = f.raw().toString("ascii");
      return this._isNumstr(v) ? v : f.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (b === "octstr")
        return f.raw();
      if (b === "objDesc")
        return f.raw();
      if (b === "printstr") {
        const v = f.raw().toString("ascii");
        return this._isPrintstr(v) ? v : f.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(b) ? f.raw().toString() : f.error("Decoding of string type: " + b + " unsupported");
    }
  }, o.prototype._decodeObjid = function(f, b, v) {
    let m;
    const E = [];
    let M = 0, B = 0;
    for (; !f.isEmpty(); )
      B = f.readUInt8(), M <<= 7, M |= B & 127, B & 128 || (E.push(M), M = 0);
    B & 128 && E.push(M);
    const I = E[0] / 40 | 0, T = E[0] % 40;
    if (v ? m = E : m = [I, T].concat(E.slice(1)), b) {
      let k = b[m.join(" ")];
      k === void 0 && (k = b[m.join(".")]), k !== void 0 && (m = k);
    }
    return m;
  }, o.prototype._decodeTime = function(f, b) {
    const v = f.raw().toString();
    let m, E, M, B, I, T;
    if (b === "gentime")
      m = v.slice(0, 4) | 0, E = v.slice(4, 6) | 0, M = v.slice(6, 8) | 0, B = v.slice(8, 10) | 0, I = v.slice(10, 12) | 0, T = v.slice(12, 14) | 0;
    else if (b === "utctime")
      m = v.slice(0, 2) | 0, E = v.slice(2, 4) | 0, M = v.slice(4, 6) | 0, B = v.slice(6, 8) | 0, I = v.slice(8, 10) | 0, T = v.slice(10, 12) | 0, m < 70 ? m = 2e3 + m : m = 1900 + m;
    else
      return f.error("Decoding " + b + " time is not supported yet");
    return Date.UTC(m, E - 1, M, B, I, T, 0);
  }, o.prototype._decodeNull = function() {
    return null;
  }, o.prototype._decodeBool = function(f) {
    const b = f.readUInt8();
    return f.isError(b) ? b : b !== 0;
  }, o.prototype._decodeInt = function(f, b) {
    const v = f.raw();
    let m = new t(v);
    return b && (m = b[m.toString(10)] || m), m;
  }, o.prototype._use = function(f, b) {
    return typeof f == "function" && (f = f(b)), f._getDecoder("der").tree;
  };
  function u(h, f) {
    let b = h.readUInt8(f);
    if (h.isError(b))
      return b;
    const v = s.tagClass[b >> 6], m = (b & 32) === 0;
    if ((b & 31) === 31) {
      let M = b;
      for (b = 0; (M & 128) === 128; ) {
        if (M = h.readUInt8(f), h.isError(M))
          return M;
        b <<= 7, b |= M & 127;
      }
    } else
      b &= 31;
    const E = s.tag[b];
    return {
      cls: v,
      primitive: m,
      tag: b,
      tagStr: E
    };
  }
  function c(h, f, b) {
    let v = h.readUInt8(b);
    if (h.isError(v))
      return v;
    if (!f && v === 128)
      return null;
    if (!(v & 128))
      return v;
    const m = v & 127;
    if (m > 4)
      return h.error("length octect is too long");
    v = 0;
    for (let E = 0; E < m; E++) {
      v <<= 8;
      const M = h.readUInt8(b);
      if (h.isError(M))
        return M;
      v |= M;
    }
    return v;
  }
  return $u;
}
var Uu, ep;
function Ax() {
  if (ep)
    return Uu;
  ep = 1;
  const e = mt(), t = x0().Buffer, n = gy();
  function i(s) {
    n.call(this, s), this.enc = "pem";
  }
  return e(i, n), Uu = i, i.prototype.decode = function(r, o) {
    const u = r.toString().split(/[\r\n]+/g), c = o.label.toUpperCase(), h = /^-----(BEGIN|END) ([^-]+)-----$/;
    let f = -1, b = -1;
    for (let E = 0; E < u.length; E++) {
      const M = u[E].match(h);
      if (M !== null && M[2] === c)
        if (f === -1) {
          if (M[1] !== "BEGIN")
            break;
          f = E;
        } else {
          if (M[1] !== "END")
            break;
          b = E;
          break;
        }
    }
    if (f === -1 || b === -1)
      throw new Error("PEM section not found for: " + c);
    const v = u.slice(f + 1, b).join("");
    v.replace(/[^a-z0-9+/=]+/gi, "");
    const m = t.from(v, "base64");
    return n.prototype.decode.call(this, m, o);
  }, Uu;
}
var tp;
function my() {
  return tp || (tp = 1, function(e) {
    const t = e;
    t.der = gy(), t.pem = Ax();
  }(Du)), Du;
}
var rp;
function Mx() {
  return rp || (rp = 1, function(e) {
    const t = yy(), n = my(), i = mt(), s = e;
    s.define = function(u, c) {
      return new r(u, c);
    };
    function r(o, u) {
      this.name = o, this.body = u, this.decoders = {}, this.encoders = {};
    }
    r.prototype._createNamed = function(u) {
      const c = this.name;
      function h(f) {
        this._initNamed(f, c);
      }
      return i(h, u), h.prototype._initNamed = function(b, v) {
        u.call(this, b, v);
      }, new h(this);
    }, r.prototype._getDecoder = function(u) {
      return u = u || "der", this.decoders.hasOwnProperty(u) || (this.decoders[u] = this._createNamed(n[u])), this.decoders[u];
    }, r.prototype.decode = function(u, c, h) {
      return this._getDecoder(c).decode(u, h);
    }, r.prototype._getEncoder = function(u) {
      return u = u || "der", this.encoders.hasOwnProperty(u) || (this.encoders[u] = this._createNamed(t[u])), this.encoders[u];
    }, r.prototype.encode = function(u, c, h) {
      return this._getEncoder(c).encode(u, h);
    };
  }(Ou)), Ou;
}
var Fu = {}, np;
function Rx() {
  return np || (np = 1, function(e) {
    const t = e;
    t.Reporter = E0().Reporter, t.DecoderBuffer = Ii().DecoderBuffer, t.EncoderBuffer = Ii().EncoderBuffer, t.Node = S0();
  }(Fu)), Fu;
}
var Hu = {}, ip;
function Bx() {
  return ip || (ip = 1, function(e) {
    const t = e;
    t._reverse = function(i) {
      const s = {};
      return Object.keys(i).forEach(function(r) {
        (r | 0) == r && (r = r | 0);
        const o = i[r];
        s[o] = r;
      }), s;
    }, t.der = A0();
  }(Hu)), Hu;
}
var ap;
function _y() {
  return ap || (ap = 1, function(e) {
    const t = e;
    t.bignum = Wt, t.define = Mx().define, t.base = Rx(), t.constants = Bx(), t.decoders = my(), t.encoders = yy();
  }(Tu)), Tu;
}
var zu, fp;
function Ix() {
  if (fp)
    return zu;
  fp = 1;
  var e = _y(), t = e.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), n = e.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), i = e.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), s = e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(i),
      this.key("subjectPublicKey").bitstr()
    );
  }), r = e.define("RelativeDistinguishedName", function() {
    this.setof(n);
  }), o = e.define("RDNSequence", function() {
    this.seqof(r);
  }), u = e.define("Name", function() {
    this.choice({
      rdnSequence: this.use(o)
    });
  }), c = e.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(t),
      this.key("notAfter").use(t)
    );
  }), h = e.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), f = e.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(i),
      this.key("issuer").use(u),
      this.key("validity").use(c),
      this.key("subject").use(u),
      this.key("subjectPublicKeyInfo").use(s),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(h).optional()
    );
  }), b = e.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(f),
      this.key("signatureAlgorithm").use(i),
      this.key("signatureValue").bitstr()
    );
  });
  return zu = b, zu;
}
var op;
function Tx() {
  if (op)
    return _r;
  op = 1;
  var e = _y();
  _r.certificate = Ix();
  var t = e.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  _r.RSAPrivateKey = t;
  var n = e.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  _r.RSAPublicKey = n;
  var i = e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(s),
      this.key("subjectPublicKey").bitstr()
    );
  });
  _r.PublicKey = i;
  var s = e.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), r = e.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(s),
      this.key("subjectPrivateKey").octstr()
    );
  });
  _r.PrivateKey = r;
  var o = e.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  _r.EncryptedPrivateKey = o;
  var u = e.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  _r.DSAPrivateKey = u, _r.DSAparam = e.define("DSAparam", function() {
    this.int();
  });
  var c = e.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(h),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  _r.ECPrivateKey = c;
  var h = e.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  });
  return _r.signature = e.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), _r;
}
const Ox = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var Vu, sp;
function Px() {
  if (sp)
    return Vu;
  sp = 1;
  var e = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, t = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, n = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, i = _f(), s = b0(), r = At().Buffer;
  return Vu = function(o, u) {
    var c = o.toString(), h = c.match(e), f;
    if (h) {
      var v = "aes" + h[1], m = r.from(h[2], "hex"), E = r.from(h[3].replace(/[\r\n]/g, ""), "base64"), M = i(u, m.slice(0, 8), parseInt(h[1], 10)).key, B = [], I = s.createDecipheriv(v, M, m);
      B.push(I.update(E)), B.push(I.final()), f = r.concat(B);
    } else {
      var b = c.match(n);
      f = r.from(b[2].replace(/[\r\n]/g, ""), "base64");
    }
    var T = c.match(t)[1];
    return {
      tag: T,
      data: f
    };
  }, Vu;
}
var Ku, up;
function xf() {
  if (up)
    return Ku;
  up = 1;
  var e = Tx(), t = Ox, n = Px(), i = b0(), s = ty(), r = At().Buffer;
  Ku = o;
  function o(c) {
    var h;
    typeof c == "object" && !r.isBuffer(c) && (h = c.passphrase, c = c.key), typeof c == "string" && (c = r.from(c));
    var f = n(c, h), b = f.tag, v = f.data, m, E;
    switch (b) {
      case "CERTIFICATE":
        E = e.certificate.decode(v, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (E || (E = e.PublicKey.decode(v, "der")), m = E.algorithm.algorithm.join("."), m) {
          case "1.2.840.113549.1.1.1":
            return e.RSAPublicKey.decode(E.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return E.subjectPrivateKey = E.subjectPublicKey, {
              type: "ec",
              data: E
            };
          case "1.2.840.10040.4.1":
            return E.algorithm.params.pub_key = e.DSAparam.decode(E.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: E.algorithm.params
            };
          default:
            throw new Error("unknown key id " + m);
        }
      case "ENCRYPTED PRIVATE KEY":
        v = e.EncryptedPrivateKey.decode(v, "der"), v = u(v, h);
      case "PRIVATE KEY":
        switch (E = e.PrivateKey.decode(v, "der"), m = E.algorithm.algorithm.join("."), m) {
          case "1.2.840.113549.1.1.1":
            return e.RSAPrivateKey.decode(E.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: E.algorithm.curve,
              privateKey: e.ECPrivateKey.decode(E.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return E.algorithm.params.priv_key = e.DSAparam.decode(E.subjectPrivateKey, "der"), {
              type: "dsa",
              params: E.algorithm.params
            };
          default:
            throw new Error("unknown key id " + m);
        }
      case "RSA PUBLIC KEY":
        return e.RSAPublicKey.decode(v, "der");
      case "RSA PRIVATE KEY":
        return e.RSAPrivateKey.decode(v, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: e.DSAPrivateKey.decode(v, "der")
        };
      case "EC PRIVATE KEY":
        return v = e.ECPrivateKey.decode(v, "der"), {
          curve: v.parameters.value,
          privateKey: v.privateKey
        };
      default:
        throw new Error("unknown key type " + b);
    }
  }
  o.signature = e.signature;
  function u(c, h) {
    var f = c.algorithm.decrypt.kde.kdeparams.salt, b = parseInt(c.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), v = t[c.algorithm.decrypt.cipher.algo.join(".")], m = c.algorithm.decrypt.cipher.iv, E = c.subjectPrivateKey, M = parseInt(v.split("-")[1], 10) / 8, B = s.pbkdf2Sync(h, f, b, M, "sha1"), I = i.createDecipheriv(v, B, m), T = [];
    return T.push(I.update(E)), T.push(I.final()), r.concat(T);
  }
  return Ku;
}
const wy = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var cp;
function Cx() {
  if (cp)
    return gi.exports;
  cp = 1;
  var e = At().Buffer, t = Wb(), n = g0(), i = w0().ec, s = vy(), r = xf(), o = wy;
  function u(B, I, T, k, j) {
    var N = r(I);
    if (N.curve) {
      if (k !== "ecdsa" && k !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return c(B, N);
    } else if (N.type === "dsa") {
      if (k !== "dsa")
        throw new Error("wrong private key type");
      return h(B, N, T);
    } else if (k !== "rsa" && k !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    B = e.concat([j, B]);
    for (var q = N.modulus.byteLength(), D = [0, 1]; B.length + D.length + 1 < q; )
      D.push(255);
    D.push(0);
    for (var re = -1; ++re < B.length; )
      D.push(B[re]);
    var te = n(D, N);
    return te;
  }
  function c(B, I) {
    var T = o[I.curve.join(".")];
    if (!T)
      throw new Error("unknown curve " + I.curve.join("."));
    var k = new i(T), j = k.keyFromPrivate(I.privateKey), N = j.sign(B);
    return e.from(N.toDER());
  }
  function h(B, I, T) {
    for (var k = I.params.priv_key, j = I.params.p, N = I.params.q, q = I.params.g, D = new s(0), re, te = v(B, N).mod(N), oe = !1, U = b(k, N, B, T); oe === !1; )
      re = E(N, U, T), D = M(q, re, j, N), oe = re.invm(N).imul(te.add(k.mul(D))).mod(N), oe.cmpn(0) === 0 && (oe = !1, D = new s(0));
    return f(D, oe);
  }
  function f(B, I) {
    B = B.toArray(), I = I.toArray(), B[0] & 128 && (B = [0].concat(B)), I[0] & 128 && (I = [0].concat(I));
    var T = B.length + I.length + 4, k = [48, T, 2, B.length];
    return k = k.concat(B, [2, I.length], I), e.from(k);
  }
  function b(B, I, T, k) {
    if (B = e.from(B.toArray()), B.length < I.byteLength()) {
      var j = e.alloc(I.byteLength() - B.length);
      B = e.concat([j, B]);
    }
    var N = T.length, q = m(T, I), D = e.alloc(N);
    D.fill(1);
    var re = e.alloc(N);
    return re = t(k, re).update(D).update(e.from([0])).update(B).update(q).digest(), D = t(k, re).update(D).digest(), re = t(k, re).update(D).update(e.from([1])).update(B).update(q).digest(), D = t(k, re).update(D).digest(), { k: re, v: D };
  }
  function v(B, I) {
    var T = new s(B), k = (B.length << 3) - I.bitLength();
    return k > 0 && T.ishrn(k), T;
  }
  function m(B, I) {
    B = v(B, I), B = B.mod(I);
    var T = e.from(B.toArray());
    if (T.length < I.byteLength()) {
      var k = e.alloc(I.byteLength() - T.length);
      T = e.concat([k, T]);
    }
    return T;
  }
  function E(B, I, T) {
    var k, j;
    do {
      for (k = e.alloc(0); k.length * 8 < B.bitLength(); )
        I.v = t(T, I.k).update(I.v).digest(), k = e.concat([k, I.v]);
      j = v(k, B), I.k = t(T, I.k).update(I.v).update(e.from([0])).digest(), I.v = t(T, I.k).update(I.v).digest();
    } while (j.cmp(B) !== -1);
    return j;
  }
  function M(B, I, T, k) {
    return B.toRed(s.mont(T)).redPow(I).fromRed().mod(k);
  }
  return gi.exports = u, gi.exports.getKey = b, gi.exports.makeKey = E, gi.exports;
}
var Zu, hp;
function Nx() {
  if (hp)
    return Zu;
  hp = 1;
  var e = At().Buffer, t = vy(), n = w0().ec, i = xf(), s = wy;
  function r(h, f, b, v, m) {
    var E = i(b);
    if (E.type === "ec") {
      if (v !== "ecdsa" && v !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return o(h, f, E);
    } else if (E.type === "dsa") {
      if (v !== "dsa")
        throw new Error("wrong public key type");
      return u(h, f, E);
    } else if (v !== "rsa" && v !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    f = e.concat([m, f]);
    for (var M = E.modulus.byteLength(), B = [1], I = 0; f.length + B.length + 2 < M; )
      B.push(255), I++;
    B.push(0);
    for (var T = -1; ++T < f.length; )
      B.push(f[T]);
    B = e.from(B);
    var k = t.mont(E.modulus);
    h = new t(h).toRed(k), h = h.redPow(new t(E.publicExponent)), h = e.from(h.fromRed().toArray());
    var j = I < 8 ? 1 : 0;
    for (M = Math.min(h.length, B.length), h.length !== B.length && (j = 1), T = -1; ++T < M; )
      j |= h[T] ^ B[T];
    return j === 0;
  }
  function o(h, f, b) {
    var v = s[b.data.algorithm.curve.join(".")];
    if (!v)
      throw new Error("unknown curve " + b.data.algorithm.curve.join("."));
    var m = new n(v), E = b.data.subjectPrivateKey.data;
    return m.verify(f, h, E);
  }
  function u(h, f, b) {
    var v = b.data.p, m = b.data.q, E = b.data.g, M = b.data.pub_key, B = i.signature.decode(h, "der"), I = B.s, T = B.r;
    c(I, m), c(T, m);
    var k = t.mont(v), j = I.invm(m), N = E.toRed(k).redPow(new t(f).mul(j).mod(m)).fromRed().mul(M.toRed(k).redPow(T.mul(j).mod(m)).fromRed()).mod(v).mod(m);
    return N.cmp(T) === 0;
  }
  function c(h, f) {
    if (h.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (h.cmp(f) >= f)
      throw new Error("invalid sig");
  }
  return Zu = r, Zu;
}
var Gu, lp;
function Lx() {
  if (lp)
    return Gu;
  lp = 1;
  var e = At().Buffer, t = Fi(), n = pf(), i = mt(), s = Cx(), r = Nx(), o = Jb;
  Object.keys(o).forEach(function(b) {
    o[b].id = e.from(o[b].id, "hex"), o[b.toLowerCase()] = o[b];
  });
  function u(b) {
    n.Writable.call(this);
    var v = o[b];
    if (!v)
      throw new Error("Unknown message digest");
    this._hashType = v.hash, this._hash = t(v.hash), this._tag = v.id, this._signType = v.sign;
  }
  i(u, n.Writable), u.prototype._write = function(v, m, E) {
    this._hash.update(v), E();
  }, u.prototype.update = function(v, m) {
    return typeof v == "string" && (v = e.from(v, m)), this._hash.update(v), this;
  }, u.prototype.sign = function(v, m) {
    this.end();
    var E = this._hash.digest(), M = s(E, v, this._hashType, this._signType, this._tag);
    return m ? M.toString(m) : M;
  };
  function c(b) {
    n.Writable.call(this);
    var v = o[b];
    if (!v)
      throw new Error("Unknown message digest");
    this._hash = t(v.hash), this._tag = v.id, this._signType = v.sign;
  }
  i(c, n.Writable), c.prototype._write = function(v, m, E) {
    this._hash.update(v), E();
  }, c.prototype.update = function(v, m) {
    return typeof v == "string" && (v = e.from(v, m)), this._hash.update(v), this;
  }, c.prototype.verify = function(v, m, E) {
    typeof m == "string" && (m = e.from(m, E)), this.end();
    var M = this._hash.digest();
    return r(m, M, v, this._signType, this._tag);
  };
  function h(b) {
    return new u(b);
  }
  function f(b) {
    return new c(b);
  }
  return Gu = {
    Sign: h,
    Verify: f,
    createSign: h,
    createVerify: f
  }, Gu;
}
var Wu, dp;
function kx() {
  if (dp)
    return Wu;
  dp = 1;
  var e = w0(), t = Wt;
  Wu = function(o) {
    return new i(o);
  };
  var n = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  n.p224 = n.secp224r1, n.p256 = n.secp256r1 = n.prime256v1, n.p192 = n.secp192r1 = n.prime192v1, n.p384 = n.secp384r1, n.p521 = n.secp521r1;
  function i(r) {
    this.curveType = n[r], this.curveType || (this.curveType = {
      name: r
    }), this.curve = new e.ec(this.curveType.name), this.keys = void 0;
  }
  i.prototype.generateKeys = function(r, o) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(r, o);
  }, i.prototype.computeSecret = function(r, o, u) {
    o = o || "utf8", Buffer.isBuffer(r) || (r = new Buffer(r, o));
    var c = this.curve.keyFromPublic(r).getPublic(), h = c.mul(this.keys.getPrivate()).getX();
    return s(h, u, this.curveType.byteLength);
  }, i.prototype.getPublicKey = function(r, o) {
    var u = this.keys.getPublic(o === "compressed", !0);
    return o === "hybrid" && (u[u.length - 1] % 2 ? u[0] = 7 : u[0] = 6), s(u, r);
  }, i.prototype.getPrivateKey = function(r) {
    return s(this.keys.getPrivate(), r);
  }, i.prototype.setPublicKey = function(r, o) {
    return o = o || "utf8", Buffer.isBuffer(r) || (r = new Buffer(r, o)), this.keys._importPublic(r), this;
  }, i.prototype.setPrivateKey = function(r, o) {
    o = o || "utf8", Buffer.isBuffer(r) || (r = new Buffer(r, o));
    var u = new t(r);
    return u = u.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(u), this;
  };
  function s(r, o, u) {
    Array.isArray(r) || (r = r.toArray());
    var c = new Buffer(r);
    if (u && c.length < u) {
      var h = new Buffer(u - c.length);
      h.fill(0), c = Buffer.concat([h, c]);
    }
    return o ? c.toString(o) : c;
  }
  return Wu;
}
var Ju = {}, Xu, pp;
function xy() {
  if (pp)
    return Xu;
  pp = 1;
  var e = Fi(), t = At().Buffer;
  Xu = function(i, s) {
    for (var r = t.alloc(0), o = 0, u; r.length < s; )
      u = n(o++), r = t.concat([r, e("sha1").update(i).update(u).digest()]);
    return r.slice(0, s);
  };
  function n(i) {
    var s = t.allocUnsafe(4);
    return s.writeUInt32BE(i, 0), s;
  }
  return Xu;
}
var Yu, vp;
function Ey() {
  return vp || (vp = 1, Yu = function(t, n) {
    for (var i = t.length, s = -1; ++s < i; )
      t[s] ^= n[s];
    return t;
  }), Yu;
}
var Qu, bp;
function Sy() {
  if (bp)
    return Qu;
  bp = 1;
  var e = Wt, t = At().Buffer;
  function n(i, s) {
    return t.from(i.toRed(e.mont(s.modulus)).redPow(new e(s.publicExponent)).fromRed().toArray());
  }
  return Qu = n, Qu;
}
var ec, yp;
function jx() {
  if (yp)
    return ec;
  yp = 1;
  var e = xf(), t = ci(), n = Fi(), i = xy(), s = Ey(), r = Wt, o = Sy(), u = g0(), c = At().Buffer;
  ec = function(m, E, M) {
    var B;
    m.padding ? B = m.padding : M ? B = 1 : B = 4;
    var I = e(m), T;
    if (B === 4)
      T = h(I, E);
    else if (B === 1)
      T = f(I, E, M);
    else if (B === 3) {
      if (T = new r(E), T.cmp(I.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return M ? u(T, I) : o(T, I);
  };
  function h(v, m) {
    var E = v.modulus.byteLength(), M = m.length, B = n("sha1").update(c.alloc(0)).digest(), I = B.length, T = 2 * I;
    if (M > E - T - 2)
      throw new Error("message too long");
    var k = c.alloc(E - M - T - 2), j = E - I - 1, N = t(I), q = s(c.concat([B, k, c.alloc(1, 1), m], j), i(N, j)), D = s(N, i(q, I));
    return new r(c.concat([c.alloc(1), D, q], E));
  }
  function f(v, m, E) {
    var M = m.length, B = v.modulus.byteLength();
    if (M > B - 11)
      throw new Error("message too long");
    var I;
    return E ? I = c.alloc(B - M - 3, 255) : I = b(B - M - 3), new r(c.concat([c.from([0, E ? 1 : 2]), I, c.alloc(1), m], B));
  }
  function b(v) {
    for (var m = c.allocUnsafe(v), E = 0, M = t(v * 2), B = 0, I; E < v; )
      B === M.length && (M = t(v * 2), B = 0), I = M[B++], I && (m[E++] = I);
    return m;
  }
  return ec;
}
var tc, gp;
function qx() {
  if (gp)
    return tc;
  gp = 1;
  var e = xf(), t = xy(), n = Ey(), i = Wt, s = g0(), r = Fi(), o = Sy(), u = At().Buffer;
  tc = function(v, m, E) {
    var M;
    v.padding ? M = v.padding : E ? M = 1 : M = 4;
    var B = e(v), I = B.modulus.byteLength();
    if (m.length > I || new i(m).cmp(B.modulus) >= 0)
      throw new Error("decryption error");
    var T;
    E ? T = o(new i(m), B) : T = s(m, B);
    var k = u.alloc(I - T.length);
    if (T = u.concat([k, T], I), M === 4)
      return c(B, T);
    if (M === 1)
      return h(B, T, E);
    if (M === 3)
      return T;
    throw new Error("unknown padding");
  };
  function c(b, v) {
    var m = b.modulus.byteLength(), E = r("sha1").update(u.alloc(0)).digest(), M = E.length;
    if (v[0] !== 0)
      throw new Error("decryption error");
    var B = v.slice(1, M + 1), I = v.slice(M + 1), T = n(B, t(I, M)), k = n(I, t(T, m - M - 1));
    if (f(E, k.slice(0, M)))
      throw new Error("decryption error");
    for (var j = M; k[j] === 0; )
      j++;
    if (k[j++] !== 1)
      throw new Error("decryption error");
    return k.slice(j);
  }
  function h(b, v, m) {
    for (var E = v.slice(0, 2), M = 2, B = 0; v[M++] !== 0; )
      if (M >= v.length) {
        B++;
        break;
      }
    var I = v.slice(2, M - 1);
    if ((E.toString("hex") !== "0002" && !m || E.toString("hex") !== "0001" && m) && B++, I.length < 8 && B++, B)
      throw new Error("decryption error");
    return v.slice(M);
  }
  function f(b, v) {
    b = u.from(b), v = u.from(v);
    var m = 0, E = b.length;
    b.length !== v.length && (m++, E = Math.min(b.length, v.length));
    for (var M = -1; ++M < E; )
      m += b[M] ^ v[M];
    return m;
  }
  return tc;
}
var mp;
function Dx() {
  return mp || (mp = 1, function(e) {
    e.publicEncrypt = jx(), e.privateDecrypt = qx(), e.privateEncrypt = function(n, i) {
      return e.publicEncrypt(n, i, !0);
    }, e.publicDecrypt = function(n, i) {
      return e.privateDecrypt(n, i, !0);
    };
  }(Ju)), Ju;
}
var Un = {}, _p;
function $x() {
  if (_p)
    return Un;
  _p = 1;
  function e() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var t = At(), n = ci(), i = t.Buffer, s = t.kMaxLength, r = Ze.crypto || Ze.msCrypto, o = Math.pow(2, 32) - 1;
  function u(v, m) {
    if (typeof v != "number" || v !== v)
      throw new TypeError("offset must be a number");
    if (v > o || v < 0)
      throw new TypeError("offset must be a uint32");
    if (v > s || v > m)
      throw new RangeError("offset out of range");
  }
  function c(v, m, E) {
    if (typeof v != "number" || v !== v)
      throw new TypeError("size must be a number");
    if (v > o || v < 0)
      throw new TypeError("size must be a uint32");
    if (v + m > E || v > s)
      throw new RangeError("buffer too small");
  }
  r && r.getRandomValues || !process.browser ? (Un.randomFill = h, Un.randomFillSync = b) : (Un.randomFill = e, Un.randomFillSync = e);
  function h(v, m, E, M) {
    if (!i.isBuffer(v) && !(v instanceof Ze.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof m == "function")
      M = m, m = 0, E = v.length;
    else if (typeof E == "function")
      M = E, E = v.length - m;
    else if (typeof M != "function")
      throw new TypeError('"cb" argument must be a function');
    return u(m, v.length), c(E, m, v.length), f(v, m, E, M);
  }
  function f(v, m, E, M) {
    if (process.browser) {
      var B = v.buffer, I = new Uint8Array(B, m, E);
      if (r.getRandomValues(I), M) {
        process.nextTick(function() {
          M(null, v);
        });
        return;
      }
      return v;
    }
    if (M) {
      n(E, function(k, j) {
        if (k)
          return M(k);
        j.copy(v, m), M(null, v);
      });
      return;
    }
    var T = n(E);
    return T.copy(v, m), v;
  }
  function b(v, m, E) {
    if (typeof m > "u" && (m = 0), !i.isBuffer(v) && !(v instanceof Ze.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return u(m, v.length), E === void 0 && (E = v.length - m), c(E, m, v.length), f(v, m, E);
  }
  return Un;
}
var wp;
function Ay() {
  if (wp)
    return wt;
  wp = 1, wt.randomBytes = wt.rng = wt.pseudoRandomBytes = wt.prng = ci(), wt.createHash = wt.Hash = Fi(), wt.createHmac = wt.Hmac = Wb();
  var e = p5(), t = Object.keys(e), n = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(t);
  wt.getHashes = function() {
    return n;
  };
  var i = ty();
  wt.pbkdf2 = i.pbkdf2, wt.pbkdf2Sync = i.pbkdf2Sync;
  var s = C5();
  wt.Cipher = s.Cipher, wt.createCipher = s.createCipher, wt.Cipheriv = s.Cipheriv, wt.createCipheriv = s.createCipheriv, wt.Decipher = s.Decipher, wt.createDecipher = s.createDecipher, wt.Decipheriv = s.Decipheriv, wt.createDecipheriv = s.createDecipheriv, wt.getCiphers = s.getCiphers, wt.listCiphers = s.listCiphers;
  var r = z5();
  wt.DiffieHellmanGroup = r.DiffieHellmanGroup, wt.createDiffieHellmanGroup = r.createDiffieHellmanGroup, wt.getDiffieHellman = r.getDiffieHellman, wt.createDiffieHellman = r.createDiffieHellman, wt.DiffieHellman = r.DiffieHellman;
  var o = Lx();
  wt.createSign = o.createSign, wt.Sign = o.Sign, wt.createVerify = o.createVerify, wt.Verify = o.Verify, wt.createECDH = kx();
  var u = Dx();
  wt.publicEncrypt = u.publicEncrypt, wt.privateEncrypt = u.privateEncrypt, wt.publicDecrypt = u.publicDecrypt, wt.privateDecrypt = u.privateDecrypt;
  var c = $x();
  return wt.randomFill = c.randomFill, wt.randomFillSync = c.randomFillSync, wt.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, wt.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, wt;
}
(function(e) {
  (function(t) {
    var n = function($) {
      var X, ne = new Float64Array(16);
      if ($)
        for (X = 0; X < $.length; X++)
          ne[X] = $[X];
      return ne;
    }, i = function() {
      throw new Error("no PRNG");
    }, s = new Uint8Array(16), r = new Uint8Array(32);
    r[0] = 9;
    var o = n(), u = n([1]), c = n([56129, 1]), h = n([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), f = n([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), b = n([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), v = n([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), m = n([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function E($, X, ne, O) {
      $[X] = ne >> 24 & 255, $[X + 1] = ne >> 16 & 255, $[X + 2] = ne >> 8 & 255, $[X + 3] = ne & 255, $[X + 4] = O >> 24 & 255, $[X + 5] = O >> 16 & 255, $[X + 6] = O >> 8 & 255, $[X + 7] = O & 255;
    }
    function M($, X, ne, O, ae) {
      var _e, xe = 0;
      for (_e = 0; _e < ae; _e++)
        xe |= $[X + _e] ^ ne[O + _e];
      return (1 & xe - 1 >>> 8) - 1;
    }
    function B($, X, ne, O) {
      return M($, X, ne, O, 16);
    }
    function I($, X, ne, O) {
      return M($, X, ne, O, 32);
    }
    function T($, X, ne, O) {
      for (var ae = O[0] & 255 | (O[1] & 255) << 8 | (O[2] & 255) << 16 | (O[3] & 255) << 24, _e = ne[0] & 255 | (ne[1] & 255) << 8 | (ne[2] & 255) << 16 | (ne[3] & 255) << 24, xe = ne[4] & 255 | (ne[5] & 255) << 8 | (ne[6] & 255) << 16 | (ne[7] & 255) << 24, Re = ne[8] & 255 | (ne[9] & 255) << 8 | (ne[10] & 255) << 16 | (ne[11] & 255) << 24, qe = ne[12] & 255 | (ne[13] & 255) << 8 | (ne[14] & 255) << 16 | (ne[15] & 255) << 24, He = O[4] & 255 | (O[5] & 255) << 8 | (O[6] & 255) << 16 | (O[7] & 255) << 24, $e = X[0] & 255 | (X[1] & 255) << 8 | (X[2] & 255) << 16 | (X[3] & 255) << 24, vt = X[4] & 255 | (X[5] & 255) << 8 | (X[6] & 255) << 16 | (X[7] & 255) << 24, Qe = X[8] & 255 | (X[9] & 255) << 8 | (X[10] & 255) << 16 | (X[11] & 255) << 24, ot = X[12] & 255 | (X[13] & 255) << 8 | (X[14] & 255) << 16 | (X[15] & 255) << 24, st = O[8] & 255 | (O[9] & 255) << 8 | (O[10] & 255) << 16 | (O[11] & 255) << 24, dt = ne[16] & 255 | (ne[17] & 255) << 8 | (ne[18] & 255) << 16 | (ne[19] & 255) << 24, lt = ne[20] & 255 | (ne[21] & 255) << 8 | (ne[22] & 255) << 16 | (ne[23] & 255) << 24, ut = ne[24] & 255 | (ne[25] & 255) << 8 | (ne[26] & 255) << 16 | (ne[27] & 255) << 24, ht = ne[28] & 255 | (ne[29] & 255) << 8 | (ne[30] & 255) << 16 | (ne[31] & 255) << 24, ct = O[12] & 255 | (O[13] & 255) << 8 | (O[14] & 255) << 16 | (O[15] & 255) << 24, et = ae, it = _e, Ye = xe, tt = Re, nt = qe, Xe = He, Oe = $e, Pe = vt, Ke = Qe, Ue = ot, Ve = st, Je = dt, pt = lt, yt = ut, _t = ht, gt = ct, ye, Et = 0; Et < 20; Et += 2)
        ye = et + pt | 0, nt ^= ye << 7 | ye >>> 32 - 7, ye = nt + et | 0, Ke ^= ye << 9 | ye >>> 32 - 9, ye = Ke + nt | 0, pt ^= ye << 13 | ye >>> 32 - 13, ye = pt + Ke | 0, et ^= ye << 18 | ye >>> 32 - 18, ye = Xe + it | 0, Ue ^= ye << 7 | ye >>> 32 - 7, ye = Ue + Xe | 0, yt ^= ye << 9 | ye >>> 32 - 9, ye = yt + Ue | 0, it ^= ye << 13 | ye >>> 32 - 13, ye = it + yt | 0, Xe ^= ye << 18 | ye >>> 32 - 18, ye = Ve + Oe | 0, _t ^= ye << 7 | ye >>> 32 - 7, ye = _t + Ve | 0, Ye ^= ye << 9 | ye >>> 32 - 9, ye = Ye + _t | 0, Oe ^= ye << 13 | ye >>> 32 - 13, ye = Oe + Ye | 0, Ve ^= ye << 18 | ye >>> 32 - 18, ye = gt + Je | 0, tt ^= ye << 7 | ye >>> 32 - 7, ye = tt + gt | 0, Pe ^= ye << 9 | ye >>> 32 - 9, ye = Pe + tt | 0, Je ^= ye << 13 | ye >>> 32 - 13, ye = Je + Pe | 0, gt ^= ye << 18 | ye >>> 32 - 18, ye = et + tt | 0, it ^= ye << 7 | ye >>> 32 - 7, ye = it + et | 0, Ye ^= ye << 9 | ye >>> 32 - 9, ye = Ye + it | 0, tt ^= ye << 13 | ye >>> 32 - 13, ye = tt + Ye | 0, et ^= ye << 18 | ye >>> 32 - 18, ye = Xe + nt | 0, Oe ^= ye << 7 | ye >>> 32 - 7, ye = Oe + Xe | 0, Pe ^= ye << 9 | ye >>> 32 - 9, ye = Pe + Oe | 0, nt ^= ye << 13 | ye >>> 32 - 13, ye = nt + Pe | 0, Xe ^= ye << 18 | ye >>> 32 - 18, ye = Ve + Ue | 0, Je ^= ye << 7 | ye >>> 32 - 7, ye = Je + Ve | 0, Ke ^= ye << 9 | ye >>> 32 - 9, ye = Ke + Je | 0, Ue ^= ye << 13 | ye >>> 32 - 13, ye = Ue + Ke | 0, Ve ^= ye << 18 | ye >>> 32 - 18, ye = gt + _t | 0, pt ^= ye << 7 | ye >>> 32 - 7, ye = pt + gt | 0, yt ^= ye << 9 | ye >>> 32 - 9, ye = yt + pt | 0, _t ^= ye << 13 | ye >>> 32 - 13, ye = _t + yt | 0, gt ^= ye << 18 | ye >>> 32 - 18;
      et = et + ae | 0, it = it + _e | 0, Ye = Ye + xe | 0, tt = tt + Re | 0, nt = nt + qe | 0, Xe = Xe + He | 0, Oe = Oe + $e | 0, Pe = Pe + vt | 0, Ke = Ke + Qe | 0, Ue = Ue + ot | 0, Ve = Ve + st | 0, Je = Je + dt | 0, pt = pt + lt | 0, yt = yt + ut | 0, _t = _t + ht | 0, gt = gt + ct | 0, $[0] = et >>> 0 & 255, $[1] = et >>> 8 & 255, $[2] = et >>> 16 & 255, $[3] = et >>> 24 & 255, $[4] = it >>> 0 & 255, $[5] = it >>> 8 & 255, $[6] = it >>> 16 & 255, $[7] = it >>> 24 & 255, $[8] = Ye >>> 0 & 255, $[9] = Ye >>> 8 & 255, $[10] = Ye >>> 16 & 255, $[11] = Ye >>> 24 & 255, $[12] = tt >>> 0 & 255, $[13] = tt >>> 8 & 255, $[14] = tt >>> 16 & 255, $[15] = tt >>> 24 & 255, $[16] = nt >>> 0 & 255, $[17] = nt >>> 8 & 255, $[18] = nt >>> 16 & 255, $[19] = nt >>> 24 & 255, $[20] = Xe >>> 0 & 255, $[21] = Xe >>> 8 & 255, $[22] = Xe >>> 16 & 255, $[23] = Xe >>> 24 & 255, $[24] = Oe >>> 0 & 255, $[25] = Oe >>> 8 & 255, $[26] = Oe >>> 16 & 255, $[27] = Oe >>> 24 & 255, $[28] = Pe >>> 0 & 255, $[29] = Pe >>> 8 & 255, $[30] = Pe >>> 16 & 255, $[31] = Pe >>> 24 & 255, $[32] = Ke >>> 0 & 255, $[33] = Ke >>> 8 & 255, $[34] = Ke >>> 16 & 255, $[35] = Ke >>> 24 & 255, $[36] = Ue >>> 0 & 255, $[37] = Ue >>> 8 & 255, $[38] = Ue >>> 16 & 255, $[39] = Ue >>> 24 & 255, $[40] = Ve >>> 0 & 255, $[41] = Ve >>> 8 & 255, $[42] = Ve >>> 16 & 255, $[43] = Ve >>> 24 & 255, $[44] = Je >>> 0 & 255, $[45] = Je >>> 8 & 255, $[46] = Je >>> 16 & 255, $[47] = Je >>> 24 & 255, $[48] = pt >>> 0 & 255, $[49] = pt >>> 8 & 255, $[50] = pt >>> 16 & 255, $[51] = pt >>> 24 & 255, $[52] = yt >>> 0 & 255, $[53] = yt >>> 8 & 255, $[54] = yt >>> 16 & 255, $[55] = yt >>> 24 & 255, $[56] = _t >>> 0 & 255, $[57] = _t >>> 8 & 255, $[58] = _t >>> 16 & 255, $[59] = _t >>> 24 & 255, $[60] = gt >>> 0 & 255, $[61] = gt >>> 8 & 255, $[62] = gt >>> 16 & 255, $[63] = gt >>> 24 & 255;
    }
    function k($, X, ne, O) {
      for (var ae = O[0] & 255 | (O[1] & 255) << 8 | (O[2] & 255) << 16 | (O[3] & 255) << 24, _e = ne[0] & 255 | (ne[1] & 255) << 8 | (ne[2] & 255) << 16 | (ne[3] & 255) << 24, xe = ne[4] & 255 | (ne[5] & 255) << 8 | (ne[6] & 255) << 16 | (ne[7] & 255) << 24, Re = ne[8] & 255 | (ne[9] & 255) << 8 | (ne[10] & 255) << 16 | (ne[11] & 255) << 24, qe = ne[12] & 255 | (ne[13] & 255) << 8 | (ne[14] & 255) << 16 | (ne[15] & 255) << 24, He = O[4] & 255 | (O[5] & 255) << 8 | (O[6] & 255) << 16 | (O[7] & 255) << 24, $e = X[0] & 255 | (X[1] & 255) << 8 | (X[2] & 255) << 16 | (X[3] & 255) << 24, vt = X[4] & 255 | (X[5] & 255) << 8 | (X[6] & 255) << 16 | (X[7] & 255) << 24, Qe = X[8] & 255 | (X[9] & 255) << 8 | (X[10] & 255) << 16 | (X[11] & 255) << 24, ot = X[12] & 255 | (X[13] & 255) << 8 | (X[14] & 255) << 16 | (X[15] & 255) << 24, st = O[8] & 255 | (O[9] & 255) << 8 | (O[10] & 255) << 16 | (O[11] & 255) << 24, dt = ne[16] & 255 | (ne[17] & 255) << 8 | (ne[18] & 255) << 16 | (ne[19] & 255) << 24, lt = ne[20] & 255 | (ne[21] & 255) << 8 | (ne[22] & 255) << 16 | (ne[23] & 255) << 24, ut = ne[24] & 255 | (ne[25] & 255) << 8 | (ne[26] & 255) << 16 | (ne[27] & 255) << 24, ht = ne[28] & 255 | (ne[29] & 255) << 8 | (ne[30] & 255) << 16 | (ne[31] & 255) << 24, ct = O[12] & 255 | (O[13] & 255) << 8 | (O[14] & 255) << 16 | (O[15] & 255) << 24, et = ae, it = _e, Ye = xe, tt = Re, nt = qe, Xe = He, Oe = $e, Pe = vt, Ke = Qe, Ue = ot, Ve = st, Je = dt, pt = lt, yt = ut, _t = ht, gt = ct, ye, Et = 0; Et < 20; Et += 2)
        ye = et + pt | 0, nt ^= ye << 7 | ye >>> 32 - 7, ye = nt + et | 0, Ke ^= ye << 9 | ye >>> 32 - 9, ye = Ke + nt | 0, pt ^= ye << 13 | ye >>> 32 - 13, ye = pt + Ke | 0, et ^= ye << 18 | ye >>> 32 - 18, ye = Xe + it | 0, Ue ^= ye << 7 | ye >>> 32 - 7, ye = Ue + Xe | 0, yt ^= ye << 9 | ye >>> 32 - 9, ye = yt + Ue | 0, it ^= ye << 13 | ye >>> 32 - 13, ye = it + yt | 0, Xe ^= ye << 18 | ye >>> 32 - 18, ye = Ve + Oe | 0, _t ^= ye << 7 | ye >>> 32 - 7, ye = _t + Ve | 0, Ye ^= ye << 9 | ye >>> 32 - 9, ye = Ye + _t | 0, Oe ^= ye << 13 | ye >>> 32 - 13, ye = Oe + Ye | 0, Ve ^= ye << 18 | ye >>> 32 - 18, ye = gt + Je | 0, tt ^= ye << 7 | ye >>> 32 - 7, ye = tt + gt | 0, Pe ^= ye << 9 | ye >>> 32 - 9, ye = Pe + tt | 0, Je ^= ye << 13 | ye >>> 32 - 13, ye = Je + Pe | 0, gt ^= ye << 18 | ye >>> 32 - 18, ye = et + tt | 0, it ^= ye << 7 | ye >>> 32 - 7, ye = it + et | 0, Ye ^= ye << 9 | ye >>> 32 - 9, ye = Ye + it | 0, tt ^= ye << 13 | ye >>> 32 - 13, ye = tt + Ye | 0, et ^= ye << 18 | ye >>> 32 - 18, ye = Xe + nt | 0, Oe ^= ye << 7 | ye >>> 32 - 7, ye = Oe + Xe | 0, Pe ^= ye << 9 | ye >>> 32 - 9, ye = Pe + Oe | 0, nt ^= ye << 13 | ye >>> 32 - 13, ye = nt + Pe | 0, Xe ^= ye << 18 | ye >>> 32 - 18, ye = Ve + Ue | 0, Je ^= ye << 7 | ye >>> 32 - 7, ye = Je + Ve | 0, Ke ^= ye << 9 | ye >>> 32 - 9, ye = Ke + Je | 0, Ue ^= ye << 13 | ye >>> 32 - 13, ye = Ue + Ke | 0, Ve ^= ye << 18 | ye >>> 32 - 18, ye = gt + _t | 0, pt ^= ye << 7 | ye >>> 32 - 7, ye = pt + gt | 0, yt ^= ye << 9 | ye >>> 32 - 9, ye = yt + pt | 0, _t ^= ye << 13 | ye >>> 32 - 13, ye = _t + yt | 0, gt ^= ye << 18 | ye >>> 32 - 18;
      $[0] = et >>> 0 & 255, $[1] = et >>> 8 & 255, $[2] = et >>> 16 & 255, $[3] = et >>> 24 & 255, $[4] = Xe >>> 0 & 255, $[5] = Xe >>> 8 & 255, $[6] = Xe >>> 16 & 255, $[7] = Xe >>> 24 & 255, $[8] = Ve >>> 0 & 255, $[9] = Ve >>> 8 & 255, $[10] = Ve >>> 16 & 255, $[11] = Ve >>> 24 & 255, $[12] = gt >>> 0 & 255, $[13] = gt >>> 8 & 255, $[14] = gt >>> 16 & 255, $[15] = gt >>> 24 & 255, $[16] = Oe >>> 0 & 255, $[17] = Oe >>> 8 & 255, $[18] = Oe >>> 16 & 255, $[19] = Oe >>> 24 & 255, $[20] = Pe >>> 0 & 255, $[21] = Pe >>> 8 & 255, $[22] = Pe >>> 16 & 255, $[23] = Pe >>> 24 & 255, $[24] = Ke >>> 0 & 255, $[25] = Ke >>> 8 & 255, $[26] = Ke >>> 16 & 255, $[27] = Ke >>> 24 & 255, $[28] = Ue >>> 0 & 255, $[29] = Ue >>> 8 & 255, $[30] = Ue >>> 16 & 255, $[31] = Ue >>> 24 & 255;
    }
    function j($, X, ne, O) {
      T($, X, ne, O);
    }
    function N($, X, ne, O) {
      k($, X, ne, O);
    }
    var q = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function D($, X, ne, O, ae, _e, xe) {
      var Re = new Uint8Array(16), qe = new Uint8Array(64), He, $e;
      for ($e = 0; $e < 16; $e++)
        Re[$e] = 0;
      for ($e = 0; $e < 8; $e++)
        Re[$e] = _e[$e];
      for (; ae >= 64; ) {
        for (j(qe, Re, xe, q), $e = 0; $e < 64; $e++)
          $[X + $e] = ne[O + $e] ^ qe[$e];
        for (He = 1, $e = 8; $e < 16; $e++)
          He = He + (Re[$e] & 255) | 0, Re[$e] = He & 255, He >>>= 8;
        ae -= 64, X += 64, O += 64;
      }
      if (ae > 0)
        for (j(qe, Re, xe, q), $e = 0; $e < ae; $e++)
          $[X + $e] = ne[O + $e] ^ qe[$e];
      return 0;
    }
    function re($, X, ne, O, ae) {
      var _e = new Uint8Array(16), xe = new Uint8Array(64), Re, qe;
      for (qe = 0; qe < 16; qe++)
        _e[qe] = 0;
      for (qe = 0; qe < 8; qe++)
        _e[qe] = O[qe];
      for (; ne >= 64; ) {
        for (j(xe, _e, ae, q), qe = 0; qe < 64; qe++)
          $[X + qe] = xe[qe];
        for (Re = 1, qe = 8; qe < 16; qe++)
          Re = Re + (_e[qe] & 255) | 0, _e[qe] = Re & 255, Re >>>= 8;
        ne -= 64, X += 64;
      }
      if (ne > 0)
        for (j(xe, _e, ae, q), qe = 0; qe < ne; qe++)
          $[X + qe] = xe[qe];
      return 0;
    }
    function te($, X, ne, O, ae) {
      var _e = new Uint8Array(32);
      N(_e, O, ae, q);
      for (var xe = new Uint8Array(8), Re = 0; Re < 8; Re++)
        xe[Re] = O[Re + 16];
      return re($, X, ne, xe, _e);
    }
    function oe($, X, ne, O, ae, _e, xe) {
      var Re = new Uint8Array(32);
      N(Re, _e, xe, q);
      for (var qe = new Uint8Array(8), He = 0; He < 8; He++)
        qe[He] = _e[He + 16];
      return D($, X, ne, O, ae, qe, Re);
    }
    var U = function($) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var X, ne, O, ae, _e, xe, Re, qe;
      X = $[0] & 255 | ($[1] & 255) << 8, this.r[0] = X & 8191, ne = $[2] & 255 | ($[3] & 255) << 8, this.r[1] = (X >>> 13 | ne << 3) & 8191, O = $[4] & 255 | ($[5] & 255) << 8, this.r[2] = (ne >>> 10 | O << 6) & 7939, ae = $[6] & 255 | ($[7] & 255) << 8, this.r[3] = (O >>> 7 | ae << 9) & 8191, _e = $[8] & 255 | ($[9] & 255) << 8, this.r[4] = (ae >>> 4 | _e << 12) & 255, this.r[5] = _e >>> 1 & 8190, xe = $[10] & 255 | ($[11] & 255) << 8, this.r[6] = (_e >>> 14 | xe << 2) & 8191, Re = $[12] & 255 | ($[13] & 255) << 8, this.r[7] = (xe >>> 11 | Re << 5) & 8065, qe = $[14] & 255 | ($[15] & 255) << 8, this.r[8] = (Re >>> 8 | qe << 8) & 8191, this.r[9] = qe >>> 5 & 127, this.pad[0] = $[16] & 255 | ($[17] & 255) << 8, this.pad[1] = $[18] & 255 | ($[19] & 255) << 8, this.pad[2] = $[20] & 255 | ($[21] & 255) << 8, this.pad[3] = $[22] & 255 | ($[23] & 255) << 8, this.pad[4] = $[24] & 255 | ($[25] & 255) << 8, this.pad[5] = $[26] & 255 | ($[27] & 255) << 8, this.pad[6] = $[28] & 255 | ($[29] & 255) << 8, this.pad[7] = $[30] & 255 | ($[31] & 255) << 8;
    };
    U.prototype.blocks = function($, X, ne) {
      for (var O = this.fin ? 0 : 2048, ae, _e, xe, Re, qe, He, $e, vt, Qe, ot, st, dt, lt, ut, ht, ct, et, it, Ye, tt = this.h[0], nt = this.h[1], Xe = this.h[2], Oe = this.h[3], Pe = this.h[4], Ke = this.h[5], Ue = this.h[6], Ve = this.h[7], Je = this.h[8], pt = this.h[9], yt = this.r[0], _t = this.r[1], gt = this.r[2], ye = this.r[3], Et = this.r[4], Bt = this.r[5], It = this.r[6], xt = this.r[7], Mt = this.r[8], Rt = this.r[9]; ne >= 16; )
        ae = $[X + 0] & 255 | ($[X + 1] & 255) << 8, tt += ae & 8191, _e = $[X + 2] & 255 | ($[X + 3] & 255) << 8, nt += (ae >>> 13 | _e << 3) & 8191, xe = $[X + 4] & 255 | ($[X + 5] & 255) << 8, Xe += (_e >>> 10 | xe << 6) & 8191, Re = $[X + 6] & 255 | ($[X + 7] & 255) << 8, Oe += (xe >>> 7 | Re << 9) & 8191, qe = $[X + 8] & 255 | ($[X + 9] & 255) << 8, Pe += (Re >>> 4 | qe << 12) & 8191, Ke += qe >>> 1 & 8191, He = $[X + 10] & 255 | ($[X + 11] & 255) << 8, Ue += (qe >>> 14 | He << 2) & 8191, $e = $[X + 12] & 255 | ($[X + 13] & 255) << 8, Ve += (He >>> 11 | $e << 5) & 8191, vt = $[X + 14] & 255 | ($[X + 15] & 255) << 8, Je += ($e >>> 8 | vt << 8) & 8191, pt += vt >>> 5 | O, Qe = 0, ot = Qe, ot += tt * yt, ot += nt * (5 * Rt), ot += Xe * (5 * Mt), ot += Oe * (5 * xt), ot += Pe * (5 * It), Qe = ot >>> 13, ot &= 8191, ot += Ke * (5 * Bt), ot += Ue * (5 * Et), ot += Ve * (5 * ye), ot += Je * (5 * gt), ot += pt * (5 * _t), Qe += ot >>> 13, ot &= 8191, st = Qe, st += tt * _t, st += nt * yt, st += Xe * (5 * Rt), st += Oe * (5 * Mt), st += Pe * (5 * xt), Qe = st >>> 13, st &= 8191, st += Ke * (5 * It), st += Ue * (5 * Bt), st += Ve * (5 * Et), st += Je * (5 * ye), st += pt * (5 * gt), Qe += st >>> 13, st &= 8191, dt = Qe, dt += tt * gt, dt += nt * _t, dt += Xe * yt, dt += Oe * (5 * Rt), dt += Pe * (5 * Mt), Qe = dt >>> 13, dt &= 8191, dt += Ke * (5 * xt), dt += Ue * (5 * It), dt += Ve * (5 * Bt), dt += Je * (5 * Et), dt += pt * (5 * ye), Qe += dt >>> 13, dt &= 8191, lt = Qe, lt += tt * ye, lt += nt * gt, lt += Xe * _t, lt += Oe * yt, lt += Pe * (5 * Rt), Qe = lt >>> 13, lt &= 8191, lt += Ke * (5 * Mt), lt += Ue * (5 * xt), lt += Ve * (5 * It), lt += Je * (5 * Bt), lt += pt * (5 * Et), Qe += lt >>> 13, lt &= 8191, ut = Qe, ut += tt * Et, ut += nt * ye, ut += Xe * gt, ut += Oe * _t, ut += Pe * yt, Qe = ut >>> 13, ut &= 8191, ut += Ke * (5 * Rt), ut += Ue * (5 * Mt), ut += Ve * (5 * xt), ut += Je * (5 * It), ut += pt * (5 * Bt), Qe += ut >>> 13, ut &= 8191, ht = Qe, ht += tt * Bt, ht += nt * Et, ht += Xe * ye, ht += Oe * gt, ht += Pe * _t, Qe = ht >>> 13, ht &= 8191, ht += Ke * yt, ht += Ue * (5 * Rt), ht += Ve * (5 * Mt), ht += Je * (5 * xt), ht += pt * (5 * It), Qe += ht >>> 13, ht &= 8191, ct = Qe, ct += tt * It, ct += nt * Bt, ct += Xe * Et, ct += Oe * ye, ct += Pe * gt, Qe = ct >>> 13, ct &= 8191, ct += Ke * _t, ct += Ue * yt, ct += Ve * (5 * Rt), ct += Je * (5 * Mt), ct += pt * (5 * xt), Qe += ct >>> 13, ct &= 8191, et = Qe, et += tt * xt, et += nt * It, et += Xe * Bt, et += Oe * Et, et += Pe * ye, Qe = et >>> 13, et &= 8191, et += Ke * gt, et += Ue * _t, et += Ve * yt, et += Je * (5 * Rt), et += pt * (5 * Mt), Qe += et >>> 13, et &= 8191, it = Qe, it += tt * Mt, it += nt * xt, it += Xe * It, it += Oe * Bt, it += Pe * Et, Qe = it >>> 13, it &= 8191, it += Ke * ye, it += Ue * gt, it += Ve * _t, it += Je * yt, it += pt * (5 * Rt), Qe += it >>> 13, it &= 8191, Ye = Qe, Ye += tt * Rt, Ye += nt * Mt, Ye += Xe * xt, Ye += Oe * It, Ye += Pe * Bt, Qe = Ye >>> 13, Ye &= 8191, Ye += Ke * Et, Ye += Ue * ye, Ye += Ve * gt, Ye += Je * _t, Ye += pt * yt, Qe += Ye >>> 13, Ye &= 8191, Qe = (Qe << 2) + Qe | 0, Qe = Qe + ot | 0, ot = Qe & 8191, Qe = Qe >>> 13, st += Qe, tt = ot, nt = st, Xe = dt, Oe = lt, Pe = ut, Ke = ht, Ue = ct, Ve = et, Je = it, pt = Ye, X += 16, ne -= 16;
      this.h[0] = tt, this.h[1] = nt, this.h[2] = Xe, this.h[3] = Oe, this.h[4] = Pe, this.h[5] = Ke, this.h[6] = Ue, this.h[7] = Ve, this.h[8] = Je, this.h[9] = pt;
    }, U.prototype.finish = function($, X) {
      var ne = new Uint16Array(10), O, ae, _e, xe;
      if (this.leftover) {
        for (xe = this.leftover, this.buffer[xe++] = 1; xe < 16; xe++)
          this.buffer[xe] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (O = this.h[1] >>> 13, this.h[1] &= 8191, xe = 2; xe < 10; xe++)
        this.h[xe] += O, O = this.h[xe] >>> 13, this.h[xe] &= 8191;
      for (this.h[0] += O * 5, O = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += O, O = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += O, ne[0] = this.h[0] + 5, O = ne[0] >>> 13, ne[0] &= 8191, xe = 1; xe < 10; xe++)
        ne[xe] = this.h[xe] + O, O = ne[xe] >>> 13, ne[xe] &= 8191;
      for (ne[9] -= 8192, ae = (O ^ 1) - 1, xe = 0; xe < 10; xe++)
        ne[xe] &= ae;
      for (ae = ~ae, xe = 0; xe < 10; xe++)
        this.h[xe] = this.h[xe] & ae | ne[xe];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, _e = this.h[0] + this.pad[0], this.h[0] = _e & 65535, xe = 1; xe < 8; xe++)
        _e = (this.h[xe] + this.pad[xe] | 0) + (_e >>> 16) | 0, this.h[xe] = _e & 65535;
      $[X + 0] = this.h[0] >>> 0 & 255, $[X + 1] = this.h[0] >>> 8 & 255, $[X + 2] = this.h[1] >>> 0 & 255, $[X + 3] = this.h[1] >>> 8 & 255, $[X + 4] = this.h[2] >>> 0 & 255, $[X + 5] = this.h[2] >>> 8 & 255, $[X + 6] = this.h[3] >>> 0 & 255, $[X + 7] = this.h[3] >>> 8 & 255, $[X + 8] = this.h[4] >>> 0 & 255, $[X + 9] = this.h[4] >>> 8 & 255, $[X + 10] = this.h[5] >>> 0 & 255, $[X + 11] = this.h[5] >>> 8 & 255, $[X + 12] = this.h[6] >>> 0 & 255, $[X + 13] = this.h[6] >>> 8 & 255, $[X + 14] = this.h[7] >>> 0 & 255, $[X + 15] = this.h[7] >>> 8 & 255;
    }, U.prototype.update = function($, X, ne) {
      var O, ae;
      if (this.leftover) {
        for (ae = 16 - this.leftover, ae > ne && (ae = ne), O = 0; O < ae; O++)
          this.buffer[this.leftover + O] = $[X + O];
        if (ne -= ae, X += ae, this.leftover += ae, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (ne >= 16 && (ae = ne - ne % 16, this.blocks($, X, ae), X += ae, ne -= ae), ne) {
        for (O = 0; O < ne; O++)
          this.buffer[this.leftover + O] = $[X + O];
        this.leftover += ne;
      }
    };
    function y($, X, ne, O, ae, _e) {
      var xe = new U(_e);
      return xe.update(ne, O, ae), xe.finish($, X), 0;
    }
    function p($, X, ne, O, ae, _e) {
      var xe = new Uint8Array(16);
      return y(xe, 0, ne, O, ae, _e), B($, X, xe, 0);
    }
    function a($, X, ne, O, ae) {
      var _e;
      if (ne < 32)
        return -1;
      for (oe($, 0, X, 0, ne, O, ae), y($, 16, $, 32, ne - 32, $), _e = 0; _e < 16; _e++)
        $[_e] = 0;
      return 0;
    }
    function l($, X, ne, O, ae) {
      var _e, xe = new Uint8Array(32);
      if (ne < 32 || (te(xe, 0, 32, O, ae), p(X, 16, X, 32, ne - 32, xe) !== 0))
        return -1;
      for (oe($, 0, X, 0, ne, O, ae), _e = 0; _e < 32; _e++)
        $[_e] = 0;
      return 0;
    }
    function _($, X) {
      var ne;
      for (ne = 0; ne < 16; ne++)
        $[ne] = X[ne] | 0;
    }
    function x($) {
      var X, ne, O = 1;
      for (X = 0; X < 16; X++)
        ne = $[X] + O + 65535, O = Math.floor(ne / 65536), $[X] = ne - O * 65536;
      $[0] += O - 1 + 37 * (O - 1);
    }
    function A($, X, ne) {
      for (var O, ae = ~(ne - 1), _e = 0; _e < 16; _e++)
        O = ae & ($[_e] ^ X[_e]), $[_e] ^= O, X[_e] ^= O;
    }
    function S($, X) {
      var ne, O, ae, _e = n(), xe = n();
      for (ne = 0; ne < 16; ne++)
        xe[ne] = X[ne];
      for (x(xe), x(xe), x(xe), O = 0; O < 2; O++) {
        for (_e[0] = xe[0] - 65517, ne = 1; ne < 15; ne++)
          _e[ne] = xe[ne] - 65535 - (_e[ne - 1] >> 16 & 1), _e[ne - 1] &= 65535;
        _e[15] = xe[15] - 32767 - (_e[14] >> 16 & 1), ae = _e[15] >> 16 & 1, _e[14] &= 65535, A(xe, _e, 1 - ae);
      }
      for (ne = 0; ne < 16; ne++)
        $[2 * ne] = xe[ne] & 255, $[2 * ne + 1] = xe[ne] >> 8;
    }
    function g($, X) {
      var ne = new Uint8Array(32), O = new Uint8Array(32);
      return S(ne, $), S(O, X), I(ne, 0, O, 0);
    }
    function w($) {
      var X = new Uint8Array(32);
      return S(X, $), X[0] & 1;
    }
    function d($, X) {
      var ne;
      for (ne = 0; ne < 16; ne++)
        $[ne] = X[2 * ne] + (X[2 * ne + 1] << 8);
      $[15] &= 32767;
    }
    function R($, X, ne) {
      for (var O = 0; O < 16; O++)
        $[O] = X[O] + ne[O];
    }
    function G($, X, ne) {
      for (var O = 0; O < 16; O++)
        $[O] = X[O] - ne[O];
    }
    function fe($, X, ne) {
      var O, ae, _e = 0, xe = 0, Re = 0, qe = 0, He = 0, $e = 0, vt = 0, Qe = 0, ot = 0, st = 0, dt = 0, lt = 0, ut = 0, ht = 0, ct = 0, et = 0, it = 0, Ye = 0, tt = 0, nt = 0, Xe = 0, Oe = 0, Pe = 0, Ke = 0, Ue = 0, Ve = 0, Je = 0, pt = 0, yt = 0, _t = 0, gt = 0, ye = ne[0], Et = ne[1], Bt = ne[2], It = ne[3], xt = ne[4], Mt = ne[5], Rt = ne[6], Ht = ne[7], Pt = ne[8], Dt = ne[9], $t = ne[10], Ut = ne[11], Kt = ne[12], tr = ne[13], rr = ne[14], nr = ne[15];
      O = X[0], _e += O * ye, xe += O * Et, Re += O * Bt, qe += O * It, He += O * xt, $e += O * Mt, vt += O * Rt, Qe += O * Ht, ot += O * Pt, st += O * Dt, dt += O * $t, lt += O * Ut, ut += O * Kt, ht += O * tr, ct += O * rr, et += O * nr, O = X[1], xe += O * ye, Re += O * Et, qe += O * Bt, He += O * It, $e += O * xt, vt += O * Mt, Qe += O * Rt, ot += O * Ht, st += O * Pt, dt += O * Dt, lt += O * $t, ut += O * Ut, ht += O * Kt, ct += O * tr, et += O * rr, it += O * nr, O = X[2], Re += O * ye, qe += O * Et, He += O * Bt, $e += O * It, vt += O * xt, Qe += O * Mt, ot += O * Rt, st += O * Ht, dt += O * Pt, lt += O * Dt, ut += O * $t, ht += O * Ut, ct += O * Kt, et += O * tr, it += O * rr, Ye += O * nr, O = X[3], qe += O * ye, He += O * Et, $e += O * Bt, vt += O * It, Qe += O * xt, ot += O * Mt, st += O * Rt, dt += O * Ht, lt += O * Pt, ut += O * Dt, ht += O * $t, ct += O * Ut, et += O * Kt, it += O * tr, Ye += O * rr, tt += O * nr, O = X[4], He += O * ye, $e += O * Et, vt += O * Bt, Qe += O * It, ot += O * xt, st += O * Mt, dt += O * Rt, lt += O * Ht, ut += O * Pt, ht += O * Dt, ct += O * $t, et += O * Ut, it += O * Kt, Ye += O * tr, tt += O * rr, nt += O * nr, O = X[5], $e += O * ye, vt += O * Et, Qe += O * Bt, ot += O * It, st += O * xt, dt += O * Mt, lt += O * Rt, ut += O * Ht, ht += O * Pt, ct += O * Dt, et += O * $t, it += O * Ut, Ye += O * Kt, tt += O * tr, nt += O * rr, Xe += O * nr, O = X[6], vt += O * ye, Qe += O * Et, ot += O * Bt, st += O * It, dt += O * xt, lt += O * Mt, ut += O * Rt, ht += O * Ht, ct += O * Pt, et += O * Dt, it += O * $t, Ye += O * Ut, tt += O * Kt, nt += O * tr, Xe += O * rr, Oe += O * nr, O = X[7], Qe += O * ye, ot += O * Et, st += O * Bt, dt += O * It, lt += O * xt, ut += O * Mt, ht += O * Rt, ct += O * Ht, et += O * Pt, it += O * Dt, Ye += O * $t, tt += O * Ut, nt += O * Kt, Xe += O * tr, Oe += O * rr, Pe += O * nr, O = X[8], ot += O * ye, st += O * Et, dt += O * Bt, lt += O * It, ut += O * xt, ht += O * Mt, ct += O * Rt, et += O * Ht, it += O * Pt, Ye += O * Dt, tt += O * $t, nt += O * Ut, Xe += O * Kt, Oe += O * tr, Pe += O * rr, Ke += O * nr, O = X[9], st += O * ye, dt += O * Et, lt += O * Bt, ut += O * It, ht += O * xt, ct += O * Mt, et += O * Rt, it += O * Ht, Ye += O * Pt, tt += O * Dt, nt += O * $t, Xe += O * Ut, Oe += O * Kt, Pe += O * tr, Ke += O * rr, Ue += O * nr, O = X[10], dt += O * ye, lt += O * Et, ut += O * Bt, ht += O * It, ct += O * xt, et += O * Mt, it += O * Rt, Ye += O * Ht, tt += O * Pt, nt += O * Dt, Xe += O * $t, Oe += O * Ut, Pe += O * Kt, Ke += O * tr, Ue += O * rr, Ve += O * nr, O = X[11], lt += O * ye, ut += O * Et, ht += O * Bt, ct += O * It, et += O * xt, it += O * Mt, Ye += O * Rt, tt += O * Ht, nt += O * Pt, Xe += O * Dt, Oe += O * $t, Pe += O * Ut, Ke += O * Kt, Ue += O * tr, Ve += O * rr, Je += O * nr, O = X[12], ut += O * ye, ht += O * Et, ct += O * Bt, et += O * It, it += O * xt, Ye += O * Mt, tt += O * Rt, nt += O * Ht, Xe += O * Pt, Oe += O * Dt, Pe += O * $t, Ke += O * Ut, Ue += O * Kt, Ve += O * tr, Je += O * rr, pt += O * nr, O = X[13], ht += O * ye, ct += O * Et, et += O * Bt, it += O * It, Ye += O * xt, tt += O * Mt, nt += O * Rt, Xe += O * Ht, Oe += O * Pt, Pe += O * Dt, Ke += O * $t, Ue += O * Ut, Ve += O * Kt, Je += O * tr, pt += O * rr, yt += O * nr, O = X[14], ct += O * ye, et += O * Et, it += O * Bt, Ye += O * It, tt += O * xt, nt += O * Mt, Xe += O * Rt, Oe += O * Ht, Pe += O * Pt, Ke += O * Dt, Ue += O * $t, Ve += O * Ut, Je += O * Kt, pt += O * tr, yt += O * rr, _t += O * nr, O = X[15], et += O * ye, it += O * Et, Ye += O * Bt, tt += O * It, nt += O * xt, Xe += O * Mt, Oe += O * Rt, Pe += O * Ht, Ke += O * Pt, Ue += O * Dt, Ve += O * $t, Je += O * Ut, pt += O * Kt, yt += O * tr, _t += O * rr, gt += O * nr, _e += 38 * it, xe += 38 * Ye, Re += 38 * tt, qe += 38 * nt, He += 38 * Xe, $e += 38 * Oe, vt += 38 * Pe, Qe += 38 * Ke, ot += 38 * Ue, st += 38 * Ve, dt += 38 * Je, lt += 38 * pt, ut += 38 * yt, ht += 38 * _t, ct += 38 * gt, ae = 1, O = _e + ae + 65535, ae = Math.floor(O / 65536), _e = O - ae * 65536, O = xe + ae + 65535, ae = Math.floor(O / 65536), xe = O - ae * 65536, O = Re + ae + 65535, ae = Math.floor(O / 65536), Re = O - ae * 65536, O = qe + ae + 65535, ae = Math.floor(O / 65536), qe = O - ae * 65536, O = He + ae + 65535, ae = Math.floor(O / 65536), He = O - ae * 65536, O = $e + ae + 65535, ae = Math.floor(O / 65536), $e = O - ae * 65536, O = vt + ae + 65535, ae = Math.floor(O / 65536), vt = O - ae * 65536, O = Qe + ae + 65535, ae = Math.floor(O / 65536), Qe = O - ae * 65536, O = ot + ae + 65535, ae = Math.floor(O / 65536), ot = O - ae * 65536, O = st + ae + 65535, ae = Math.floor(O / 65536), st = O - ae * 65536, O = dt + ae + 65535, ae = Math.floor(O / 65536), dt = O - ae * 65536, O = lt + ae + 65535, ae = Math.floor(O / 65536), lt = O - ae * 65536, O = ut + ae + 65535, ae = Math.floor(O / 65536), ut = O - ae * 65536, O = ht + ae + 65535, ae = Math.floor(O / 65536), ht = O - ae * 65536, O = ct + ae + 65535, ae = Math.floor(O / 65536), ct = O - ae * 65536, O = et + ae + 65535, ae = Math.floor(O / 65536), et = O - ae * 65536, _e += ae - 1 + 37 * (ae - 1), ae = 1, O = _e + ae + 65535, ae = Math.floor(O / 65536), _e = O - ae * 65536, O = xe + ae + 65535, ae = Math.floor(O / 65536), xe = O - ae * 65536, O = Re + ae + 65535, ae = Math.floor(O / 65536), Re = O - ae * 65536, O = qe + ae + 65535, ae = Math.floor(O / 65536), qe = O - ae * 65536, O = He + ae + 65535, ae = Math.floor(O / 65536), He = O - ae * 65536, O = $e + ae + 65535, ae = Math.floor(O / 65536), $e = O - ae * 65536, O = vt + ae + 65535, ae = Math.floor(O / 65536), vt = O - ae * 65536, O = Qe + ae + 65535, ae = Math.floor(O / 65536), Qe = O - ae * 65536, O = ot + ae + 65535, ae = Math.floor(O / 65536), ot = O - ae * 65536, O = st + ae + 65535, ae = Math.floor(O / 65536), st = O - ae * 65536, O = dt + ae + 65535, ae = Math.floor(O / 65536), dt = O - ae * 65536, O = lt + ae + 65535, ae = Math.floor(O / 65536), lt = O - ae * 65536, O = ut + ae + 65535, ae = Math.floor(O / 65536), ut = O - ae * 65536, O = ht + ae + 65535, ae = Math.floor(O / 65536), ht = O - ae * 65536, O = ct + ae + 65535, ae = Math.floor(O / 65536), ct = O - ae * 65536, O = et + ae + 65535, ae = Math.floor(O / 65536), et = O - ae * 65536, _e += ae - 1 + 37 * (ae - 1), $[0] = _e, $[1] = xe, $[2] = Re, $[3] = qe, $[4] = He, $[5] = $e, $[6] = vt, $[7] = Qe, $[8] = ot, $[9] = st, $[10] = dt, $[11] = lt, $[12] = ut, $[13] = ht, $[14] = ct, $[15] = et;
    }
    function z($, X) {
      fe($, X, X);
    }
    function V($, X) {
      var ne = n(), O;
      for (O = 0; O < 16; O++)
        ne[O] = X[O];
      for (O = 253; O >= 0; O--)
        z(ne, ne), O !== 2 && O !== 4 && fe(ne, ne, X);
      for (O = 0; O < 16; O++)
        $[O] = ne[O];
    }
    function F($, X) {
      var ne = n(), O;
      for (O = 0; O < 16; O++)
        ne[O] = X[O];
      for (O = 250; O >= 0; O--)
        z(ne, ne), O !== 1 && fe(ne, ne, X);
      for (O = 0; O < 16; O++)
        $[O] = ne[O];
    }
    function ee($, X, ne) {
      var O = new Uint8Array(32), ae = new Float64Array(80), _e, xe, Re = n(), qe = n(), He = n(), $e = n(), vt = n(), Qe = n();
      for (xe = 0; xe < 31; xe++)
        O[xe] = X[xe];
      for (O[31] = X[31] & 127 | 64, O[0] &= 248, d(ae, ne), xe = 0; xe < 16; xe++)
        qe[xe] = ae[xe], $e[xe] = Re[xe] = He[xe] = 0;
      for (Re[0] = $e[0] = 1, xe = 254; xe >= 0; --xe)
        _e = O[xe >>> 3] >>> (xe & 7) & 1, A(Re, qe, _e), A(He, $e, _e), R(vt, Re, He), G(Re, Re, He), R(He, qe, $e), G(qe, qe, $e), z($e, vt), z(Qe, Re), fe(Re, He, Re), fe(He, qe, vt), R(vt, Re, He), G(Re, Re, He), z(qe, Re), G(He, $e, Qe), fe(Re, He, c), R(Re, Re, $e), fe(He, He, Re), fe(Re, $e, Qe), fe($e, qe, ae), z(qe, vt), A(Re, qe, _e), A(He, $e, _e);
      for (xe = 0; xe < 16; xe++)
        ae[xe + 16] = Re[xe], ae[xe + 32] = He[xe], ae[xe + 48] = qe[xe], ae[xe + 64] = $e[xe];
      var ot = ae.subarray(32), st = ae.subarray(16);
      return V(ot, ot), fe(st, st, ot), S($, st), 0;
    }
    function he($, X) {
      return ee($, X, r);
    }
    function Z($, X) {
      return i(X, 32), he($, X);
    }
    function K($, X, ne) {
      var O = new Uint8Array(32);
      return ee(O, ne, X), N($, s, O, q);
    }
    var ce = a, ve = l;
    function Be($, X, ne, O, ae, _e) {
      var xe = new Uint8Array(32);
      return K(xe, ae, _e), ce($, X, ne, O, xe);
    }
    function Q($, X, ne, O, ae, _e) {
      var xe = new Uint8Array(32);
      return K(xe, ae, _e), ve($, X, ne, O, xe);
    }
    var C = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function L($, X, ne, O) {
      for (var ae = new Int32Array(16), _e = new Int32Array(16), xe, Re, qe, He, $e, vt, Qe, ot, st, dt, lt, ut, ht, ct, et, it, Ye, tt, nt, Xe, Oe, Pe, Ke, Ue, Ve, Je, pt = $[0], yt = $[1], _t = $[2], gt = $[3], ye = $[4], Et = $[5], Bt = $[6], It = $[7], xt = X[0], Mt = X[1], Rt = X[2], Ht = X[3], Pt = X[4], Dt = X[5], $t = X[6], Ut = X[7], Kt = 0; O >= 128; ) {
        for (nt = 0; nt < 16; nt++)
          Xe = 8 * nt + Kt, ae[nt] = ne[Xe + 0] << 24 | ne[Xe + 1] << 16 | ne[Xe + 2] << 8 | ne[Xe + 3], _e[nt] = ne[Xe + 4] << 24 | ne[Xe + 5] << 16 | ne[Xe + 6] << 8 | ne[Xe + 7];
        for (nt = 0; nt < 80; nt++)
          if (xe = pt, Re = yt, qe = _t, He = gt, $e = ye, vt = Et, Qe = Bt, ot = It, st = xt, dt = Mt, lt = Rt, ut = Ht, ht = Pt, ct = Dt, et = $t, it = Ut, Oe = It, Pe = Ut, Ke = Pe & 65535, Ue = Pe >>> 16, Ve = Oe & 65535, Je = Oe >>> 16, Oe = (ye >>> 14 | Pt << 32 - 14) ^ (ye >>> 18 | Pt << 32 - 18) ^ (Pt >>> 41 - 32 | ye << 32 - (41 - 32)), Pe = (Pt >>> 14 | ye << 32 - 14) ^ (Pt >>> 18 | ye << 32 - 18) ^ (ye >>> 41 - 32 | Pt << 32 - (41 - 32)), Ke += Pe & 65535, Ue += Pe >>> 16, Ve += Oe & 65535, Je += Oe >>> 16, Oe = ye & Et ^ ~ye & Bt, Pe = Pt & Dt ^ ~Pt & $t, Ke += Pe & 65535, Ue += Pe >>> 16, Ve += Oe & 65535, Je += Oe >>> 16, Oe = C[nt * 2], Pe = C[nt * 2 + 1], Ke += Pe & 65535, Ue += Pe >>> 16, Ve += Oe & 65535, Je += Oe >>> 16, Oe = ae[nt % 16], Pe = _e[nt % 16], Ke += Pe & 65535, Ue += Pe >>> 16, Ve += Oe & 65535, Je += Oe >>> 16, Ue += Ke >>> 16, Ve += Ue >>> 16, Je += Ve >>> 16, Ye = Ve & 65535 | Je << 16, tt = Ke & 65535 | Ue << 16, Oe = Ye, Pe = tt, Ke = Pe & 65535, Ue = Pe >>> 16, Ve = Oe & 65535, Je = Oe >>> 16, Oe = (pt >>> 28 | xt << 32 - 28) ^ (xt >>> 34 - 32 | pt << 32 - (34 - 32)) ^ (xt >>> 39 - 32 | pt << 32 - (39 - 32)), Pe = (xt >>> 28 | pt << 32 - 28) ^ (pt >>> 34 - 32 | xt << 32 - (34 - 32)) ^ (pt >>> 39 - 32 | xt << 32 - (39 - 32)), Ke += Pe & 65535, Ue += Pe >>> 16, Ve += Oe & 65535, Je += Oe >>> 16, Oe = pt & yt ^ pt & _t ^ yt & _t, Pe = xt & Mt ^ xt & Rt ^ Mt & Rt, Ke += Pe & 65535, Ue += Pe >>> 16, Ve += Oe & 65535, Je += Oe >>> 16, Ue += Ke >>> 16, Ve += Ue >>> 16, Je += Ve >>> 16, ot = Ve & 65535 | Je << 16, it = Ke & 65535 | Ue << 16, Oe = He, Pe = ut, Ke = Pe & 65535, Ue = Pe >>> 16, Ve = Oe & 65535, Je = Oe >>> 16, Oe = Ye, Pe = tt, Ke += Pe & 65535, Ue += Pe >>> 16, Ve += Oe & 65535, Je += Oe >>> 16, Ue += Ke >>> 16, Ve += Ue >>> 16, Je += Ve >>> 16, He = Ve & 65535 | Je << 16, ut = Ke & 65535 | Ue << 16, yt = xe, _t = Re, gt = qe, ye = He, Et = $e, Bt = vt, It = Qe, pt = ot, Mt = st, Rt = dt, Ht = lt, Pt = ut, Dt = ht, $t = ct, Ut = et, xt = it, nt % 16 === 15)
            for (Xe = 0; Xe < 16; Xe++)
              Oe = ae[Xe], Pe = _e[Xe], Ke = Pe & 65535, Ue = Pe >>> 16, Ve = Oe & 65535, Je = Oe >>> 16, Oe = ae[(Xe + 9) % 16], Pe = _e[(Xe + 9) % 16], Ke += Pe & 65535, Ue += Pe >>> 16, Ve += Oe & 65535, Je += Oe >>> 16, Ye = ae[(Xe + 1) % 16], tt = _e[(Xe + 1) % 16], Oe = (Ye >>> 1 | tt << 32 - 1) ^ (Ye >>> 8 | tt << 32 - 8) ^ Ye >>> 7, Pe = (tt >>> 1 | Ye << 32 - 1) ^ (tt >>> 8 | Ye << 32 - 8) ^ (tt >>> 7 | Ye << 32 - 7), Ke += Pe & 65535, Ue += Pe >>> 16, Ve += Oe & 65535, Je += Oe >>> 16, Ye = ae[(Xe + 14) % 16], tt = _e[(Xe + 14) % 16], Oe = (Ye >>> 19 | tt << 32 - 19) ^ (tt >>> 61 - 32 | Ye << 32 - (61 - 32)) ^ Ye >>> 6, Pe = (tt >>> 19 | Ye << 32 - 19) ^ (Ye >>> 61 - 32 | tt << 32 - (61 - 32)) ^ (tt >>> 6 | Ye << 32 - 6), Ke += Pe & 65535, Ue += Pe >>> 16, Ve += Oe & 65535, Je += Oe >>> 16, Ue += Ke >>> 16, Ve += Ue >>> 16, Je += Ve >>> 16, ae[Xe] = Ve & 65535 | Je << 16, _e[Xe] = Ke & 65535 | Ue << 16;
        Oe = pt, Pe = xt, Ke = Pe & 65535, Ue = Pe >>> 16, Ve = Oe & 65535, Je = Oe >>> 16, Oe = $[0], Pe = X[0], Ke += Pe & 65535, Ue += Pe >>> 16, Ve += Oe & 65535, Je += Oe >>> 16, Ue += Ke >>> 16, Ve += Ue >>> 16, Je += Ve >>> 16, $[0] = pt = Ve & 65535 | Je << 16, X[0] = xt = Ke & 65535 | Ue << 16, Oe = yt, Pe = Mt, Ke = Pe & 65535, Ue = Pe >>> 16, Ve = Oe & 65535, Je = Oe >>> 16, Oe = $[1], Pe = X[1], Ke += Pe & 65535, Ue += Pe >>> 16, Ve += Oe & 65535, Je += Oe >>> 16, Ue += Ke >>> 16, Ve += Ue >>> 16, Je += Ve >>> 16, $[1] = yt = Ve & 65535 | Je << 16, X[1] = Mt = Ke & 65535 | Ue << 16, Oe = _t, Pe = Rt, Ke = Pe & 65535, Ue = Pe >>> 16, Ve = Oe & 65535, Je = Oe >>> 16, Oe = $[2], Pe = X[2], Ke += Pe & 65535, Ue += Pe >>> 16, Ve += Oe & 65535, Je += Oe >>> 16, Ue += Ke >>> 16, Ve += Ue >>> 16, Je += Ve >>> 16, $[2] = _t = Ve & 65535 | Je << 16, X[2] = Rt = Ke & 65535 | Ue << 16, Oe = gt, Pe = Ht, Ke = Pe & 65535, Ue = Pe >>> 16, Ve = Oe & 65535, Je = Oe >>> 16, Oe = $[3], Pe = X[3], Ke += Pe & 65535, Ue += Pe >>> 16, Ve += Oe & 65535, Je += Oe >>> 16, Ue += Ke >>> 16, Ve += Ue >>> 16, Je += Ve >>> 16, $[3] = gt = Ve & 65535 | Je << 16, X[3] = Ht = Ke & 65535 | Ue << 16, Oe = ye, Pe = Pt, Ke = Pe & 65535, Ue = Pe >>> 16, Ve = Oe & 65535, Je = Oe >>> 16, Oe = $[4], Pe = X[4], Ke += Pe & 65535, Ue += Pe >>> 16, Ve += Oe & 65535, Je += Oe >>> 16, Ue += Ke >>> 16, Ve += Ue >>> 16, Je += Ve >>> 16, $[4] = ye = Ve & 65535 | Je << 16, X[4] = Pt = Ke & 65535 | Ue << 16, Oe = Et, Pe = Dt, Ke = Pe & 65535, Ue = Pe >>> 16, Ve = Oe & 65535, Je = Oe >>> 16, Oe = $[5], Pe = X[5], Ke += Pe & 65535, Ue += Pe >>> 16, Ve += Oe & 65535, Je += Oe >>> 16, Ue += Ke >>> 16, Ve += Ue >>> 16, Je += Ve >>> 16, $[5] = Et = Ve & 65535 | Je << 16, X[5] = Dt = Ke & 65535 | Ue << 16, Oe = Bt, Pe = $t, Ke = Pe & 65535, Ue = Pe >>> 16, Ve = Oe & 65535, Je = Oe >>> 16, Oe = $[6], Pe = X[6], Ke += Pe & 65535, Ue += Pe >>> 16, Ve += Oe & 65535, Je += Oe >>> 16, Ue += Ke >>> 16, Ve += Ue >>> 16, Je += Ve >>> 16, $[6] = Bt = Ve & 65535 | Je << 16, X[6] = $t = Ke & 65535 | Ue << 16, Oe = It, Pe = Ut, Ke = Pe & 65535, Ue = Pe >>> 16, Ve = Oe & 65535, Je = Oe >>> 16, Oe = $[7], Pe = X[7], Ke += Pe & 65535, Ue += Pe >>> 16, Ve += Oe & 65535, Je += Oe >>> 16, Ue += Ke >>> 16, Ve += Ue >>> 16, Je += Ve >>> 16, $[7] = It = Ve & 65535 | Je << 16, X[7] = Ut = Ke & 65535 | Ue << 16, Kt += 128, O -= 128;
      }
      return O;
    }
    function W($, X, ne) {
      var O = new Int32Array(8), ae = new Int32Array(8), _e = new Uint8Array(256), xe, Re = ne;
      for (O[0] = 1779033703, O[1] = 3144134277, O[2] = 1013904242, O[3] = 2773480762, O[4] = 1359893119, O[5] = 2600822924, O[6] = 528734635, O[7] = 1541459225, ae[0] = 4089235720, ae[1] = 2227873595, ae[2] = 4271175723, ae[3] = 1595750129, ae[4] = 2917565137, ae[5] = 725511199, ae[6] = 4215389547, ae[7] = 327033209, L(O, ae, X, ne), ne %= 128, xe = 0; xe < ne; xe++)
        _e[xe] = X[Re - ne + xe];
      for (_e[ne] = 128, ne = 256 - 128 * (ne < 112 ? 1 : 0), _e[ne - 9] = 0, E(_e, ne - 8, Re / 536870912 | 0, Re << 3), L(O, ae, _e, ne), xe = 0; xe < 8; xe++)
        E($, 8 * xe, O[xe], ae[xe]);
      return 0;
    }
    function de($, X) {
      var ne = n(), O = n(), ae = n(), _e = n(), xe = n(), Re = n(), qe = n(), He = n(), $e = n();
      G(ne, $[1], $[0]), G($e, X[1], X[0]), fe(ne, ne, $e), R(O, $[0], $[1]), R($e, X[0], X[1]), fe(O, O, $e), fe(ae, $[3], X[3]), fe(ae, ae, f), fe(_e, $[2], X[2]), R(_e, _e, _e), G(xe, O, ne), G(Re, _e, ae), R(qe, _e, ae), R(He, O, ne), fe($[0], xe, Re), fe($[1], He, qe), fe($[2], qe, Re), fe($[3], xe, He);
    }
    function me($, X, ne) {
      var O;
      for (O = 0; O < 4; O++)
        A($[O], X[O], ne);
    }
    function Te($, X) {
      var ne = n(), O = n(), ae = n();
      V(ae, X[2]), fe(ne, X[0], ae), fe(O, X[1], ae), S($, O), $[31] ^= w(ne) << 7;
    }
    function Fe($, X, ne) {
      var O, ae;
      for (_($[0], o), _($[1], u), _($[2], u), _($[3], o), ae = 255; ae >= 0; --ae)
        O = ne[ae / 8 | 0] >> (ae & 7) & 1, me($, X, O), de(X, $), de($, $), me($, X, O);
    }
    function H($, X) {
      var ne = [n(), n(), n(), n()];
      _(ne[0], b), _(ne[1], v), _(ne[2], u), fe(ne[3], b, v), Fe($, ne, X);
    }
    function ue($, X, ne) {
      var O = new Uint8Array(64), ae = [n(), n(), n(), n()], _e;
      for (ne || i(X, 32), W(O, X, 32), O[0] &= 248, O[31] &= 127, O[31] |= 64, H(ae, O), Te($, ae), _e = 0; _e < 32; _e++)
        X[_e + 32] = $[_e];
      return 0;
    }
    var se = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function we($, X) {
      var ne, O, ae, _e;
      for (O = 63; O >= 32; --O) {
        for (ne = 0, ae = O - 32, _e = O - 12; ae < _e; ++ae)
          X[ae] += ne - 16 * X[O] * se[ae - (O - 32)], ne = Math.floor((X[ae] + 128) / 256), X[ae] -= ne * 256;
        X[ae] += ne, X[O] = 0;
      }
      for (ne = 0, ae = 0; ae < 32; ae++)
        X[ae] += ne - (X[31] >> 4) * se[ae], ne = X[ae] >> 8, X[ae] &= 255;
      for (ae = 0; ae < 32; ae++)
        X[ae] -= ne * se[ae];
      for (O = 0; O < 32; O++)
        X[O + 1] += X[O] >> 8, $[O] = X[O] & 255;
    }
    function Ce($) {
      var X = new Float64Array(64), ne;
      for (ne = 0; ne < 64; ne++)
        X[ne] = $[ne];
      for (ne = 0; ne < 64; ne++)
        $[ne] = 0;
      we($, X);
    }
    function ze($, X, ne, O) {
      var ae = new Uint8Array(64), _e = new Uint8Array(64), xe = new Uint8Array(64), Re, qe, He = new Float64Array(64), $e = [n(), n(), n(), n()];
      W(ae, O, 32), ae[0] &= 248, ae[31] &= 127, ae[31] |= 64;
      var vt = ne + 64;
      for (Re = 0; Re < ne; Re++)
        $[64 + Re] = X[Re];
      for (Re = 0; Re < 32; Re++)
        $[32 + Re] = ae[32 + Re];
      for (W(xe, $.subarray(32), ne + 32), Ce(xe), H($e, xe), Te($, $e), Re = 32; Re < 64; Re++)
        $[Re] = O[Re];
      for (W(_e, $, ne + 64), Ce(_e), Re = 0; Re < 64; Re++)
        He[Re] = 0;
      for (Re = 0; Re < 32; Re++)
        He[Re] = xe[Re];
      for (Re = 0; Re < 32; Re++)
        for (qe = 0; qe < 32; qe++)
          He[Re + qe] += _e[Re] * ae[qe];
      return we($.subarray(32), He), vt;
    }
    function Le($, X) {
      var ne = n(), O = n(), ae = n(), _e = n(), xe = n(), Re = n(), qe = n();
      return _($[2], u), d($[1], X), z(ae, $[1]), fe(_e, ae, h), G(ae, ae, $[2]), R(_e, $[2], _e), z(xe, _e), z(Re, xe), fe(qe, Re, xe), fe(ne, qe, ae), fe(ne, ne, _e), F(ne, ne), fe(ne, ne, ae), fe(ne, ne, _e), fe(ne, ne, _e), fe($[0], ne, _e), z(O, $[0]), fe(O, O, _e), g(O, ae) && fe($[0], $[0], m), z(O, $[0]), fe(O, O, _e), g(O, ae) ? -1 : (w($[0]) === X[31] >> 7 && G($[0], o, $[0]), fe($[3], $[0], $[1]), 0);
    }
    function Y($, X, ne, O) {
      var ae, _e = new Uint8Array(32), xe = new Uint8Array(64), Re = [n(), n(), n(), n()], qe = [n(), n(), n(), n()];
      if (ne < 64 || Le(qe, O))
        return -1;
      for (ae = 0; ae < ne; ae++)
        $[ae] = X[ae];
      for (ae = 0; ae < 32; ae++)
        $[ae + 32] = O[ae];
      if (W(xe, $, ne), Ce(xe), Fe(Re, qe, xe), H(qe, X.subarray(32)), de(Re, qe), Te(_e, Re), ne -= 64, I(X, 0, _e, 0)) {
        for (ae = 0; ae < ne; ae++)
          $[ae] = 0;
        return -1;
      }
      for (ae = 0; ae < ne; ae++)
        $[ae] = X[ae + 64];
      return ne;
    }
    var Se = 32, Ae = 24, je = 32, pe = 16, Ee = 32, J = 32, Ie = 32, ke = 32, P = 32, Me = Ae, be = je, ie = pe, le = 64, ge = 32, Ge = 64, De = 32, Ne = 64;
    t.lowlevel = {
      crypto_core_hsalsa20: N,
      crypto_stream_xor: oe,
      crypto_stream: te,
      crypto_stream_salsa20_xor: D,
      crypto_stream_salsa20: re,
      crypto_onetimeauth: y,
      crypto_onetimeauth_verify: p,
      crypto_verify_16: B,
      crypto_verify_32: I,
      crypto_secretbox: a,
      crypto_secretbox_open: l,
      crypto_scalarmult: ee,
      crypto_scalarmult_base: he,
      crypto_box_beforenm: K,
      crypto_box_afternm: ce,
      crypto_box: Be,
      crypto_box_open: Q,
      crypto_box_keypair: Z,
      crypto_hash: W,
      crypto_sign: ze,
      crypto_sign_keypair: ue,
      crypto_sign_open: Y,
      crypto_secretbox_KEYBYTES: Se,
      crypto_secretbox_NONCEBYTES: Ae,
      crypto_secretbox_ZEROBYTES: je,
      crypto_secretbox_BOXZEROBYTES: pe,
      crypto_scalarmult_BYTES: Ee,
      crypto_scalarmult_SCALARBYTES: J,
      crypto_box_PUBLICKEYBYTES: Ie,
      crypto_box_SECRETKEYBYTES: ke,
      crypto_box_BEFORENMBYTES: P,
      crypto_box_NONCEBYTES: Me,
      crypto_box_ZEROBYTES: be,
      crypto_box_BOXZEROBYTES: ie,
      crypto_sign_BYTES: le,
      crypto_sign_PUBLICKEYBYTES: ge,
      crypto_sign_SECRETKEYBYTES: Ge,
      crypto_sign_SEEDBYTES: De,
      crypto_hash_BYTES: Ne,
      gf: n,
      D: h,
      L: se,
      pack25519: S,
      unpack25519: d,
      M: fe,
      A: R,
      S: z,
      Z: G,
      pow2523: F,
      add: de,
      set25519: _,
      modL: we,
      scalarmult: Fe,
      scalarbase: H
    };
    function rt($, X) {
      if ($.length !== Se)
        throw new Error("bad key size");
      if (X.length !== Ae)
        throw new Error("bad nonce size");
    }
    function ft($, X) {
      if ($.length !== Ie)
        throw new Error("bad public key size");
      if (X.length !== ke)
        throw new Error("bad secret key size");
    }
    function We() {
      for (var $ = 0; $ < arguments.length; $++)
        if (!(arguments[$] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function at($) {
      for (var X = 0; X < $.length; X++)
        $[X] = 0;
    }
    t.randomBytes = function($) {
      var X = new Uint8Array($);
      return i(X, $), X;
    }, t.secretbox = function($, X, ne) {
      We($, X, ne), rt(ne, X);
      for (var O = new Uint8Array(je + $.length), ae = new Uint8Array(O.length), _e = 0; _e < $.length; _e++)
        O[_e + je] = $[_e];
      return a(ae, O, O.length, X, ne), ae.subarray(pe);
    }, t.secretbox.open = function($, X, ne) {
      We($, X, ne), rt(ne, X);
      for (var O = new Uint8Array(pe + $.length), ae = new Uint8Array(O.length), _e = 0; _e < $.length; _e++)
        O[_e + pe] = $[_e];
      return O.length < 32 || l(ae, O, O.length, X, ne) !== 0 ? null : ae.subarray(je);
    }, t.secretbox.keyLength = Se, t.secretbox.nonceLength = Ae, t.secretbox.overheadLength = pe, t.scalarMult = function($, X) {
      if (We($, X), $.length !== J)
        throw new Error("bad n size");
      if (X.length !== Ee)
        throw new Error("bad p size");
      var ne = new Uint8Array(Ee);
      return ee(ne, $, X), ne;
    }, t.scalarMult.base = function($) {
      if (We($), $.length !== J)
        throw new Error("bad n size");
      var X = new Uint8Array(Ee);
      return he(X, $), X;
    }, t.scalarMult.scalarLength = J, t.scalarMult.groupElementLength = Ee, t.box = function($, X, ne, O) {
      var ae = t.box.before(ne, O);
      return t.secretbox($, X, ae);
    }, t.box.before = function($, X) {
      We($, X), ft($, X);
      var ne = new Uint8Array(P);
      return K(ne, $, X), ne;
    }, t.box.after = t.secretbox, t.box.open = function($, X, ne, O) {
      var ae = t.box.before(ne, O);
      return t.secretbox.open($, X, ae);
    }, t.box.open.after = t.secretbox.open, t.box.keyPair = function() {
      var $ = new Uint8Array(Ie), X = new Uint8Array(ke);
      return Z($, X), { publicKey: $, secretKey: X };
    }, t.box.keyPair.fromSecretKey = function($) {
      if (We($), $.length !== ke)
        throw new Error("bad secret key size");
      var X = new Uint8Array(Ie);
      return he(X, $), { publicKey: X, secretKey: new Uint8Array($) };
    }, t.box.publicKeyLength = Ie, t.box.secretKeyLength = ke, t.box.sharedKeyLength = P, t.box.nonceLength = Me, t.box.overheadLength = t.secretbox.overheadLength, t.sign = function($, X) {
      if (We($, X), X.length !== Ge)
        throw new Error("bad secret key size");
      var ne = new Uint8Array(le + $.length);
      return ze(ne, $, $.length, X), ne;
    }, t.sign.open = function($, X) {
      if (We($, X), X.length !== ge)
        throw new Error("bad public key size");
      var ne = new Uint8Array($.length), O = Y(ne, $, $.length, X);
      if (O < 0)
        return null;
      for (var ae = new Uint8Array(O), _e = 0; _e < ae.length; _e++)
        ae[_e] = ne[_e];
      return ae;
    }, t.sign.detached = function($, X) {
      for (var ne = t.sign($, X), O = new Uint8Array(le), ae = 0; ae < O.length; ae++)
        O[ae] = ne[ae];
      return O;
    }, t.sign.detached.verify = function($, X, ne) {
      if (We($, X, ne), X.length !== le)
        throw new Error("bad signature size");
      if (ne.length !== ge)
        throw new Error("bad public key size");
      var O = new Uint8Array(le + $.length), ae = new Uint8Array(le + $.length), _e;
      for (_e = 0; _e < le; _e++)
        O[_e] = X[_e];
      for (_e = 0; _e < $.length; _e++)
        O[_e + le] = $[_e];
      return Y(ae, O, O.length, ne) >= 0;
    }, t.sign.keyPair = function() {
      var $ = new Uint8Array(ge), X = new Uint8Array(Ge);
      return ue($, X), { publicKey: $, secretKey: X };
    }, t.sign.keyPair.fromSecretKey = function($) {
      if (We($), $.length !== Ge)
        throw new Error("bad secret key size");
      for (var X = new Uint8Array(ge), ne = 0; ne < X.length; ne++)
        X[ne] = $[32 + ne];
      return { publicKey: X, secretKey: new Uint8Array($) };
    }, t.sign.keyPair.fromSeed = function($) {
      if (We($), $.length !== De)
        throw new Error("bad seed size");
      for (var X = new Uint8Array(ge), ne = new Uint8Array(Ge), O = 0; O < 32; O++)
        ne[O] = $[O];
      return ue(X, ne, !0), { publicKey: X, secretKey: ne };
    }, t.sign.publicKeyLength = ge, t.sign.secretKeyLength = Ge, t.sign.seedLength = De, t.sign.signatureLength = le, t.hash = function($) {
      We($);
      var X = new Uint8Array(Ne);
      return W(X, $, $.length), X;
    }, t.hash.hashLength = Ne, t.verify = function($, X) {
      return We($, X), $.length === 0 || X.length === 0 || $.length !== X.length ? !1 : M($, 0, X, 0, $.length) === 0;
    }, t.setPRNG = function($) {
      i = $;
    }, function() {
      var $ = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if ($ && $.getRandomValues) {
        var X = 65536;
        t.setPRNG(function(ne, O) {
          var ae, _e = new Uint8Array(O);
          for (ae = 0; ae < O; ae += X)
            $.getRandomValues(_e.subarray(ae, ae + Math.min(O - ae, X)));
          for (ae = 0; ae < O; ae++)
            ne[ae] = _e[ae];
          at(_e);
        });
      } else
        typeof pc < "u" && ($ = Ay(), $ && $.randomBytes && t.setPRNG(function(ne, O) {
          var ae, _e = $.randomBytes(O);
          for (ae = 0; ae < O; ae++)
            ne[ae] = _e[ae];
          at(_e);
        }));
    }();
  })(e.exports ? e.exports : self.nacl = self.nacl || {});
})(zb);
var Ux = zb.exports, My = { exports: {} };
(function(e) {
  (function(t, n) {
    e.exports ? e.exports = n() : (t.nacl || (t.nacl = {}), t.nacl.util = n());
  })(Ze, function() {
    var t = {};
    function n(i) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(i))
        throw new TypeError("invalid encoding");
    }
    return t.decodeUTF8 = function(i) {
      if (typeof i != "string")
        throw new TypeError("expected string");
      var s, r = unescape(encodeURIComponent(i)), o = new Uint8Array(r.length);
      for (s = 0; s < r.length; s++)
        o[s] = r.charCodeAt(s);
      return o;
    }, t.encodeUTF8 = function(i) {
      var s, r = [];
      for (s = 0; s < i.length; s++)
        r.push(String.fromCharCode(i[s]));
      return decodeURIComponent(escape(r.join("")));
    }, typeof atob > "u" ? typeof Buffer.from < "u" ? (t.encodeBase64 = function(i) {
      return Buffer.from(i).toString("base64");
    }, t.decodeBase64 = function(i) {
      return n(i), new Uint8Array(Array.prototype.slice.call(Buffer.from(i, "base64"), 0));
    }) : (t.encodeBase64 = function(i) {
      return new Buffer(i).toString("base64");
    }, t.decodeBase64 = function(i) {
      return n(i), new Uint8Array(Array.prototype.slice.call(new Buffer(i, "base64"), 0));
    }) : (t.encodeBase64 = function(i) {
      var s, r = [], o = i.length;
      for (s = 0; s < o; s++)
        r.push(String.fromCharCode(i[s]));
      return btoa(r.join(""));
    }, t.decodeBase64 = function(i) {
      n(i);
      var s, r = atob(i), o = new Uint8Array(r.length);
      for (s = 0; s < r.length; s++)
        o[s] = r.charCodeAt(s);
      return o;
    }), t;
  });
})(My);
var Fx = My.exports, Hx = Ze && Ze.__createBinding || (Object.create ? function(e, t, n, i) {
  i === void 0 && (i = n);
  var s = Object.getOwnPropertyDescriptor(t, n);
  (!s || ("get" in s ? !t.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
    return t[n];
  } }), Object.defineProperty(e, i, s);
} : function(e, t, n, i) {
  i === void 0 && (i = n), e[i] = t[n];
}), zx = Ze && Ze.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), Ry = Ze && Ze.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null)
    for (var n in e)
      n !== "default" && Object.prototype.hasOwnProperty.call(e, n) && Hx(t, e, n);
  return zx(t, e), t;
};
Object.defineProperty(Mr, "__esModule", { value: !0 });
Mr.getEncryptionPublicKey = Mr.decryptSafely = Mr.decrypt = Mr.encryptSafely = Mr.encrypt = void 0;
const Mn = Ry(Ux), jr = Ry(Fx), Wr = Vt;
function By({ publicKey: e, data: t, version: n }) {
  if ((0, Wr.isNullish)(e))
    throw new Error("Missing publicKey parameter");
  if ((0, Wr.isNullish)(t))
    throw new Error("Missing data parameter");
  if ((0, Wr.isNullish)(n))
    throw new Error("Missing version parameter");
  switch (n) {
    case "x25519-xsalsa20-poly1305": {
      if (typeof t != "string")
        throw new Error("Message data must be given as a string");
      const i = Mn.box.keyPair();
      let s;
      try {
        s = jr.decodeBase64(e);
      } catch {
        throw new Error("Bad public key");
      }
      const r = jr.decodeUTF8(t), o = Mn.randomBytes(Mn.box.nonceLength), u = Mn.box(r, o, s, i.secretKey);
      return {
        version: "x25519-xsalsa20-poly1305",
        nonce: jr.encodeBase64(o),
        ephemPublicKey: jr.encodeBase64(i.publicKey),
        ciphertext: jr.encodeBase64(u)
      };
    }
    default:
      throw new Error("Encryption type/version not supported");
  }
}
Mr.encrypt = By;
function Vx({ publicKey: e, data: t, version: n }) {
  if ((0, Wr.isNullish)(e))
    throw new Error("Missing publicKey parameter");
  if ((0, Wr.isNullish)(t))
    throw new Error("Missing data parameter");
  if ((0, Wr.isNullish)(n))
    throw new Error("Missing version parameter");
  const i = 2 ** 11, s = 16;
  if (typeof t == "object" && t && "toJSON" in t)
    throw new Error("Cannot encrypt with toJSON property.  Please remove toJSON property");
  const r = {
    data: t,
    padding: ""
  }, u = Buffer.byteLength(JSON.stringify(r), "utf-8") % i;
  let c = 0;
  u > 0 && (c = i - u - s), r.padding = "0".repeat(c);
  const h = JSON.stringify(r);
  return By({ publicKey: e, data: h, version: n });
}
Mr.encryptSafely = Vx;
function Iy({ encryptedData: e, privateKey: t }) {
  if ((0, Wr.isNullish)(e))
    throw new Error("Missing encryptedData parameter");
  if ((0, Wr.isNullish)(t))
    throw new Error("Missing privateKey parameter");
  switch (e.version) {
    case "x25519-xsalsa20-poly1305": {
      const n = Ty(t), i = Mn.box.keyPair.fromSecretKey(n).secretKey, s = jr.decodeBase64(e.nonce), r = jr.decodeBase64(e.ciphertext), o = jr.decodeBase64(e.ephemPublicKey), u = Mn.box.open(r, s, o, i);
      try {
        if (!u)
          throw new Error();
        const c = jr.encodeUTF8(u);
        if (!c)
          throw new Error();
        return c;
      } catch (c) {
        throw c && typeof c.message == "string" && c.message.length ? new Error(`Decryption failed: ${c.message}`) : new Error("Decryption failed.");
      }
    }
    default:
      throw new Error("Encryption type/version not supported.");
  }
}
Mr.decrypt = Iy;
function Kx({ encryptedData: e, privateKey: t }) {
  if ((0, Wr.isNullish)(e))
    throw new Error("Missing encryptedData parameter");
  if ((0, Wr.isNullish)(t))
    throw new Error("Missing privateKey parameter");
  return JSON.parse(Iy({ encryptedData: e, privateKey: t })).data;
}
Mr.decryptSafely = Kx;
function Zx(e) {
  const t = Ty(e), n = Mn.box.keyPair.fromSecretKey(t).publicKey;
  return jr.encodeBase64(n);
}
Mr.getEncryptionPublicKey = Zx;
function Ty(e) {
  const t = Buffer.from(e, "hex").toString("base64");
  return jr.decodeBase64(t);
}
(function(e) {
  var t = Ze && Ze.__createBinding || (Object.create ? function(s, r, o, u) {
    u === void 0 && (u = o);
    var c = Object.getOwnPropertyDescriptor(r, o);
    (!c || ("get" in c ? !r.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
      return r[o];
    } }), Object.defineProperty(s, u, c);
  } : function(s, r, o, u) {
    u === void 0 && (u = o), s[u] = r[o];
  }), n = Ze && Ze.__exportStar || function(s, r) {
    for (var o in s)
      o !== "default" && !Object.prototype.hasOwnProperty.call(r, o) && t(r, s, o);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.normalize = e.concatSig = void 0, n(ln, e), n($b, e), n(Mr, e);
  var i = Vt;
  Object.defineProperty(e, "concatSig", { enumerable: !0, get: function() {
    return i.concatSig;
  } }), Object.defineProperty(e, "normalize", { enumerable: !0, get: function() {
    return i.normalize;
  } });
})(Tv);
var Gx = Ze && Ze.__createBinding || (Object.create ? function(e, t, n, i) {
  i === void 0 && (i = n), Object.defineProperty(e, i, { enumerable: !0, get: function() {
    return t[n];
  } });
} : function(e, t, n, i) {
  i === void 0 && (i = n), e[i] = t[n];
}), Wx = Ze && Ze.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), Jx = Ze && Ze.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null)
    for (var n in e)
      n !== "default" && Object.prototype.hasOwnProperty.call(e, n) && Gx(t, e, n);
  return Wx(t, e), t;
};
Object.defineProperty(Ga, "__esModule", { value: !0 });
Ga.createWalletMiddleware = void 0;
const hr = pr, Xx = Jx(Tv), Nr = Zt;
function Yx({ getAccounts: e, processDecryptMessage: t, processEncryptionPublicKey: n, processEthSignMessage: i, processPersonalMessage: s, processTransaction: r, processSignTransaction: o, processTypedMessage: u, processTypedMessageV3: c, processTypedMessageV4: h }) {
  if (!e)
    throw new Error("opts.getAccounts is required");
  return hr.createScaffoldMiddleware({
    // account lookups
    eth_accounts: hr.createAsyncMiddleware(f),
    eth_coinbase: hr.createAsyncMiddleware(b),
    // tx signatures
    eth_sendTransaction: hr.createAsyncMiddleware(v),
    eth_signTransaction: hr.createAsyncMiddleware(m),
    // message signatures
    eth_sign: hr.createAsyncMiddleware(E),
    eth_signTypedData: hr.createAsyncMiddleware(M),
    eth_signTypedData_v3: hr.createAsyncMiddleware(B),
    eth_signTypedData_v4: hr.createAsyncMiddleware(I),
    personal_sign: hr.createAsyncMiddleware(T),
    eth_getEncryptionPublicKey: hr.createAsyncMiddleware(j),
    eth_decrypt: hr.createAsyncMiddleware(N),
    personal_ecRecover: hr.createAsyncMiddleware(k)
  });
  async function f(D, re) {
    re.result = await e(D);
  }
  async function b(D, re) {
    const te = await e(D);
    re.result = te[0] || null;
  }
  async function v(D, re) {
    if (!r)
      throw Nr.ethErrors.rpc.methodNotSupported();
    const te = D.params[0] || {};
    te.from = await q(te.from, D), re.result = await r(te, D);
  }
  async function m(D, re) {
    if (!o)
      throw Nr.ethErrors.rpc.methodNotSupported();
    const te = D.params[0] || {};
    te.from = await q(te.from, D), re.result = await o(te, D);
  }
  async function E(D, re) {
    if (!i)
      throw Nr.ethErrors.rpc.methodNotSupported();
    const te = await q(D.params[0], D), oe = D.params[1], U = D.params[2] || {}, y = Object.assign(Object.assign({}, U), { from: te, data: oe });
    re.result = await i(y, D);
  }
  async function M(D, re) {
    if (!u)
      throw Nr.ethErrors.rpc.methodNotSupported();
    const te = D.params[0], oe = await q(D.params[1], D), U = "V1", y = D.params[2] || {}, p = Object.assign(Object.assign({}, y), { from: oe, data: te });
    re.result = await u(p, D, U);
  }
  async function B(D, re) {
    if (!c)
      throw Nr.ethErrors.rpc.methodNotSupported();
    const te = await q(D.params[0], D), oe = D.params[1], U = "V3", y = {
      data: oe,
      from: te,
      version: U
    };
    re.result = await c(y, D, U);
  }
  async function I(D, re) {
    if (!h)
      throw Nr.ethErrors.rpc.methodNotSupported();
    const te = await q(D.params[0], D), oe = D.params[1], U = "V4", y = {
      data: oe,
      from: te,
      version: U
    };
    re.result = await h(y, D, U);
  }
  async function T(D, re) {
    if (!s)
      throw Nr.ethErrors.rpc.methodNotSupported();
    const te = D.params[0], oe = D.params[1], U = D.params[2] || {};
    let y, p;
    if (rc(te) && !rc(oe)) {
      let l = "The eth_personalSign method requires params ordered ";
      l += "[message, address]. This was previously handled incorrectly, ", l += "and has been corrected automatically. ", l += "Please switch this param order for smooth behavior in the future.", re.warning = l, y = te, p = oe;
    } else
      p = te, y = oe;
    y = await q(y, D);
    const a = Object.assign(Object.assign({}, U), { from: y, data: p });
    re.result = await s(a, D);
  }
  async function k(D, re) {
    const te = D.params[0], oe = D.params[1], U = Xx.recoverPersonalSignature({
      data: te,
      signature: oe
    });
    re.result = U;
  }
  async function j(D, re) {
    if (!n)
      throw Nr.ethErrors.rpc.methodNotSupported();
    const te = await q(D.params[0], D);
    re.result = await n(te, D);
  }
  async function N(D, re) {
    if (!t)
      throw Nr.ethErrors.rpc.methodNotSupported();
    const te = D.params[0], oe = await q(D.params[1], D), U = D.params[2] || {}, y = Object.assign(Object.assign({}, U), { from: oe, data: te });
    re.result = await t(y, D);
  }
  async function q(D, re) {
    if (typeof D == "string" && D.length > 0 && rc(D)) {
      const oe = (await e(re, {
        suppressUnauthorized: !1
      })).map((y) => y.toLowerCase()), U = D.toLowerCase();
      if (oe.includes(U))
        return U;
      throw Nr.ethErrors.provider.unauthorized();
    }
    throw Nr.ethErrors.rpc.invalidParams({
      message: "Invalid parameters: must provide an Ethereum address."
    });
  }
}
Ga.createWalletMiddleware = Yx;
function rc(e) {
  return e.length === 2 + 20 * 2;
}
(function(e) {
  var t = Ze && Ze.__createBinding || (Object.create ? function(i, s, r, o) {
    o === void 0 && (o = r), Object.defineProperty(i, o, { enumerable: !0, get: function() {
      return s[r];
    } });
  } : function(i, s, r, o) {
    o === void 0 && (o = r), i[o] = s[r];
  }), n = Ze && Ze.__exportStar || function(i, s) {
    for (var r in i)
      r !== "default" && !Object.prototype.hasOwnProperty.call(s, r) && t(s, i, r);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), n(Ca, e), n(Fa, e), n(Ha, e), n(za, e), n(Yn, e), n(Va, e), n(Qn, e), n(ji, e), n(Ka, e), n(Za, e), n(Ga, e);
})(Ec);
const Oy = (e) => {
  switch (e) {
    case "ethereum":
      return {
        rpcUrl: "https://mainnet.infura.io/v3/69e7888727b84a5ab6a06cac0294ff6b",
        chainId: "0x" + 1 .toString(16)
      };
    case "evmeth-goerli":
      return {
        rpcUrl: "https://goerli.infura.io/v3/69e7888727b84a5ab6a06cac0294ff6b",
        chainId: "0x" + 5 .toString(16)
      };
    case "klaytn":
      return {
        rpcUrl: "https://gateway-v2.dcentwallet.com/klaytn/mainnet",
        chainId: "0x" + 8217 .toString(16)
      };
    case "klaytn-testnet":
      return {
        rpcUrl: "https://gateway-v2.dcentwallet.com/klaytn/testnet",
        chainId: "0x" + 1001 .toString(16)
      };
    case "evmsongbird":
      return {
        rpcUrl: "https://songbird-api.flare.network/ext/C/rpc",
        chainId: "0x" + 19 .toString(16)
      };
    case "evmpolygon":
      return {
        rpcUrl: "https://polygon-rpc.com",
        chainId: "0x" + 137 .toString(16)
      };
    case "evmpolygon-testnet":
      return {
        rpcUrl: "https://gateway-v2.dcentwallet.com/matic/testnet",
        chainId: "0x" + 80001 .toString(16)
      };
    default:
      throw new Error(
        `There is No network info about provided network : ${e}`
      );
  }
};
let Qx = class Py extends Up {
  constructor({
    network: t,
    wepin: n
  }) {
    const i = hg({ wepin: n, network: t }), { rpcUrl: s, chainId: r } = Oy(t), o = Ec.createFetchMiddleware({
      rpcUrl: s
    });
    super({ rpcMiddleware: [i, o] }), this._initializeState({
      accounts: [],
      chainId: r
    });
  }
  static generate(t) {
    const n = new Py(t);
    return window.evmproviders = window.evmproviders || {}, window.evmproviders[n.name] = n, n;
  }
};
const eE = ({
  wepin: e,
  network: t
}) => pr.createScaffoldMiddleware({
  klay_requestAccounts: ya({ wepin: e, network: t }),
  klay_accounts: ya({ wepin: e, network: t }),
  klay_signTransaction: Fp({ wepin: e, network: t }),
  klay_sendTransaction: Hp({ wepin: e, network: t }),
  klay_signTypedData_v1: Vn({ wepin: e, network: t, version: "V1" }),
  klay_signTypedData_v3: Vn({ wepin: e, network: t, version: "V3" }),
  klay_signTypedData_v4: Vn({ wepin: e, network: t, version: "V4" }),
  klay_sign: ga({ wepin: e, network: t, isPersonal: !1 }),
  personal_sign: ga({ wepin: e, network: t, isPersonal: !0 })
});
class M0 extends Up {
  constructor({
    network: t,
    wepin: n
  }) {
    const i = eE({ wepin: n, network: t }), { rpcUrl: s, chainId: r } = Oy(t), o = Ec.createFetchMiddleware({
      rpcUrl: s
    });
    super({
      rpcMiddleware: [i, o]
    }), this._initializeState({
      accounts: [],
      chainId: r
    });
  }
  static generate(t) {
    const n = new M0(t);
    return window.evmproviders = window.evmproviders || {}, window.evmproviders[n.name] = n, n;
  }
}
const tE = "wepin-js-sdk-provider", rE = "0.0.2-alpha", nE = "Wepin providers for Web SDK", iE = "./dist/wepin-provider.umd.js", aE = {
  build: "vite build"
}, fE = "https://github.com/IotrustGitHub/wepin-js-sdk-provider.git", oE = "IOTrust", sE = "MIT", uE = {
  "eth-json-rpc-middleware": "^9.0.1",
  "json-rpc-engine": "^6.1.0"
}, cE = {
  "@types/node": "^18.13.0",
  "@typescript-eslint/eslint-plugin": "^5.53.0",
  "@typescript-eslint/parser": "^5.53.0",
  eslint: "^8.34.0",
  "eslint-config-prettier": "^8.6.0",
  "eslint-plugin-prettier": "^4.2.1",
  "node-stdlib-browser": "^1.2.0",
  prettier: "^2.8.4",
  typescript: "^4.9.5",
  vite: "^4.1.1",
  "vite-plugin-node-stdlib-browser": "^0.1.1"
}, hE = "yarn@3.6.3", lE = {
  name: tE,
  version: rE,
  description: nE,
  main: iE,
  scripts: aE,
  repository: fE,
  author: oE,
  license: sE,
  dependencies: uE,
  devDependencies: cE,
  packageManager: hE
};
window.Wepin && (console.log(`WepinJavaScript SDK provider v${lE.version} Initialized`), window.Wepin.getProvider = dE);
function dE({ network: e }) {
  var i;
  if (!this._isInitialized)
    throw new Error("Wepin must be initialized to get Provider.");
  if ((i = window.evmproviders) != null && i.wepin)
    return window.evmproviders.wepin;
  const t = e.toLowerCase(), n = window.Wepin;
  switch (t) {
    case "ethereum":
    case "evmeth-goerli":
    case "evmsongbird":
    case "evmpolygon":
    case "evmpolygon-testnet":
      return Qx.generate({ network: t, wepin: n });
    case "klaytn":
    case "klaytn-testnet":
      return M0.generate({
        network: t,
        wepin: n
      });
    default:
      throw new Error(`Can not resolve network name: ${e}`);
  }
}
